<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Category: Omnet-Veins | Blog</title><meta name="author" content="xqiao"><meta name="copyright" content="xqiao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="没记错应该是第二次刷这套练习了，很经典，能够逐步代入 Omnet++ 各部分功能的使用。这里简单总结下不同部分的更新，方便后期复习查看。在每节的开头都粘贴了官方原版的注释，个人觉得很简洁概况了每节的功能，一言以蔽之，希望我也能达其一二。">
<meta property="og:type" content="article">
<meta property="og:title" content="Omnet++ Samples 学习 1 - TicToc 练习汇总">
<meta property="og:url" content="http://qiaoxu123.github.io/posts/Omnet-Veins/20220921-omnet++-samples-tictoc-practice.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="没记错应该是第二次刷这套练习了，很经典，能够逐步代入 Omnet++ 各部分功能的使用。这里简单总结下不同部分的更新，方便后期复习查看。在每节的开头都粘贴了官方原版的注释，个人觉得很简洁概况了每节的功能，一言以蔽之，希望我也能达其一二。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://qiaoxu123.github.io/img/avatar.png">
<meta property="article:published_time" content="2022-09-21T05:04:15.000Z">
<meta property="article:modified_time" content="2023-12-10T14:17:27.928Z">
<meta property="article:author" content="xqiao">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="经验总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiaoxu123.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://qiaoxu123.github.io/posts/Omnet-Veins/20220921-omnet++-samples-tictoc-practice.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Category: Omnet-Veins',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-10 22:17:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 7.0.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Omnet++ Samples 学习 1 - TicToc 练习汇总</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-09-21T05:04:15.000Z" title="Created 2022-09-21 13:04:15">2022-09-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-12-10T14:17:27.928Z" title="Updated 2023-12-10 22:17:27">2023-12-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Omnet-Veins/">Omnet-Veins</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Omnet++ Samples 学习 1 - TicToc 练习汇总"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>官方 Tictoc Tutorials 链接：<a href="https://docs.omnetpp.org/tutorials/tictoc/">Introduction - OMNeT++ Technical Articles</a></p>
<p>国内比较好的翻译链接：<a href="https://www.cnblogs.com/ShineLeBlog/category/1972607.html">omnet++ - 随笔分类 - ShineLe - 博客园</a></p>
<span id="more"></span>
<h3 id="tictoc-1">Tictoc 1</h3>
<blockquote>
<p>Derive the Txc1 class from cSimpleModule. In the Tictoc1 network, both the <code>tic</code> and <code>toc</code> modules are Txc1 objects, created by OMNeT++ at the beginning of the simulation.</p>
</blockquote>
<p>一切都从新手村开始，在最开始的例子里，我们首先要了解 Tictoc 仿真的大致框架。</p>
<ul>
<li>
<p><code>Tictoc.ned</code></p>
<p>包含 tictoc module 以及 network 的定义</p>
</li>
<li>
<p><code>tictoc.cc</code> &amp; <code>tictoc.h</code></p>
<p>每个 module 的功能实现</p>
</li>
<li>
<p><code>ompetpp.ini</code></p>
<p>仿真的启动文件，也会声明和初始化一些 module 或 network 中的参数</p>
</li>
</ul>
<p>太过细节的不再过多赘述了，可以自己查阅官方链接。目前只需要知道每个 module 实现都要继承 cSimpleModule 模块并 override 两个基本函数 <code>initlaize()</code> 和 <code>handleMessage()</code> ，如下所示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Txc1</span> : <span class="keyword">public</span> cSimpleModule</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// The following redefined virtual function holds the algorithm.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleMessage</span><span class="params">(cMessage *msg)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>handleMessage</code> 函数的功能是对收到的 Message 作出反应，在这里是直接再向外发送一个 Message，最后效果便像是 ping-pang 一样互发。</p>
<p>在 initialize() 中可以看到调用 Omnet++ 的 API 来获取当前 module 的name</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc1::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize is called at the beginning of the simulation.</span></span><br><span class="line">    <span class="comment">// To bootstrap the tic-toc-tic-toc process, one of the modules needs</span></span><br><span class="line">    <span class="comment">// to send the first message. Let this be `tic&#x27;.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Am I Tic or Toc?</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;tic&quot;</span>, <span class="built_in">getName</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// create and send first message on gate &quot;out&quot;. &quot;tictocMsg&quot; is an</span></span><br><span class="line">        <span class="comment">// arbitrary string which will be the name of the message object.</span></span><br><span class="line">        cMessage *msg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">send</span>(msg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也即确保第一发包是从 tic module 开始的。</p>
<hr>
<h3 id="tictoc-2">Tictoc 2</h3>
<blockquote>
<p>In this step we add some debug messages to Txc1. When you run the simulation in the OMNeT++ Qtenv GUI, the log will appear in the bottom panel of the Qtenv window. To see only the log from <code>tic</code> or <code>toc</code> alone, go into them by double-clicking their icons, and the bottom panel will be filtered accordingly. (You can go back with the up arrow button on the toolbar.)</p>
</blockquote>
<p>相比 Tictoc1 增加了 debug 信息</p>
<hr>
<h3 id="tictoc-3">Tictoc 3</h3>
<blockquote>
<p>In this class we add a counter, and delete the message after ten exchanges.</p>
</blockquote>
<ul>
<li>
<p><code>Initialize()</code> 函数中添加了 WATCH 函数，可以实时在 Qtenv 显示 counter 的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc3::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize counter to ten. We&#x27;ll decrement it every time and delete</span></span><br><span class="line">    <span class="comment">// the message when it reaches zero.</span></span><br><span class="line">    counter = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The WATCH() statement below will let you examine the variable under</span></span><br><span class="line">    <span class="comment">// Qtenv. After doing a few steps in the simulation, click either</span></span><br><span class="line">    <span class="comment">// `tic&#x27; or `toc&#x27;, and you&#x27;ll find its `counter&#x27; variable and its</span></span><br><span class="line">    <span class="comment">// current value displayed in the inspector panel (bottom left).</span></span><br><span class="line">    <span class="built_in">WATCH</span>(counter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;tic&quot;</span>, <span class="built_in">getName</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Sending initial message\n&quot;</span>;</span><br><span class="line">        cMessage *msg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">send</span>(msg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="tictoc-4">Tictoc 4</h3>
<blockquote>
<p>In this step you’ll learn how to add input parameters to the simulation: we’ll turn the “magic number” 10 into a parameter.</p>
</blockquote>
<ul>
<li>
<p>将仿真参数添加在 ned 文件中进行设置，避免在 cc 文件中进行设置绑定。首先在 ned 文件中对变量进行定义，可以通过 default 变量设置默认值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">simple Txc4</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        <span class="type">bool</span> sendMsgOnInit = <span class="built_in">default</span>(<span class="literal">false</span>); <span class="comment">// whether the module should send out a message on initialization</span></span><br><span class="line">        <span class="type">int</span> limit = <span class="built_in">default</span>(<span class="number">2</span>);   <span class="comment">// another parameter with a default value</span></span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=block/routing&quot;</span>);</span><br><span class="line">    gates:</span><br><span class="line">        input in;</span><br><span class="line">        output out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 cc 文件中通过 <code>par()</code> 函数进行变量读取，如下所示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc4::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize the counter with the &quot;limit&quot; module parameter, declared</span></span><br><span class="line">    <span class="comment">// in the NED file (tictoc4.ned).</span></span><br><span class="line">    counter = <span class="built_in">par</span>(<span class="string">&quot;limit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we no longer depend on the name of the module to decide</span></span><br><span class="line">    <span class="comment">// whether to send an initial message</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">par</span>(<span class="string">&quot;sendMsgOnInit&quot;</span>).<span class="built_in">boolValue</span>() == <span class="literal">true</span>) &#123;</span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Sending initial message\n&quot;</span>;</span><br><span class="line">        cMessage *msg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">send</span>(msg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="tictoc-5">Tictoc 5</h3>
<blockquote>
<p>Same as Txc4. This module will be the base of the Tic and Toc types.</p>
</blockquote>
<p>相比 Tictoc 4，仅在 ned 文件中进行了修改，让其继承一个特定的 module，可以更定制化地进行修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">simple Txc5</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        <span class="type">bool</span> sendMsgOnInit = <span class="built_in">default</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">int</span> limit = <span class="built_in">default</span>(<span class="number">2</span>);</span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=block/routing&quot;</span>);</span><br><span class="line">    gates:</span><br><span class="line">        input in;</span><br><span class="line">        output out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Specialize the module by defining parameters. We could have left the whole body</span></span><br><span class="line"><span class="comment">// empty, because the default value of the sendMsgOnInit parameter is false anyway.</span></span><br><span class="line"><span class="comment">// Note that the limit parameter is still unbound here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">simple Tic5 extends Txc5</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=,cyan&quot;</span>);</span><br><span class="line">        sendMsgOnInit = <span class="literal">true</span>;   <span class="comment">// Tic modules should send a message on init</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Specialize the module by defining parameters. We could have left the whole body</span></span><br><span class="line"><span class="comment">// empty, because the default value of the sendMsgOnInit parameter is false anyway.</span></span><br><span class="line"><span class="comment">// Note that the limit parameter is still unbound here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">simple Toc5 extends Txc5</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=,gold&quot;</span>);</span><br><span class="line">        sendMsgOnInit = <span class="literal">false</span>;  <span class="comment">// Toc modules should NOT send a message on init</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="tictoc-6">Tictoc 6</h3>
<blockquote>
<p>In the previous models, <code>tic</code> and <code>toc</code> immediately sent back the received message. Here we’ll add some timing: tic and toc will hold the message for 1 simulated second before sending it back. In OMNeT++ such timing is achieved by the module sending a message to itself.</p>
<p>Such messages are called <code>self-messages</code> (but only because of the way they are used, otherwise they are completely ordinary messages) or events. Self-messages can be “sent” with the <code>scheduleAt() </code>function, and you can specify when they should arrive back at the module. We leave out the counter, to keep the source code small.</p>
</blockquote>
<ul>
<li>
<p>引入 self-messages 的概念，不同于接收到的其他类型 Message，它是 module 自己产生的，可以自己设定产生的逻辑，用来定时发送，又或者对其他 Message 的接收作出反应等。</p>
<p>其通过 <code>scheduleAt()</code> 函数来设置发送，如下所示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc6::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create the event object we&#x27;ll use for timing -- just any ordinary message.</span></span><br><span class="line">    event = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;event&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No tictoc message yet.</span></span><br><span class="line">    tictocMsg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;tic&quot;</span>, <span class="built_in">getName</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t start right away, but instead send an message to ourselves</span></span><br><span class="line">        <span class="comment">// (a &quot;self-message&quot;) -- we&#x27;ll do the first sending when it arrives</span></span><br><span class="line">        <span class="comment">// back to us, at t=5.0s simulated time.</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Scheduling first send to t=5.0s\n&quot;</span>;</span><br><span class="line">        tictocMsg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="number">5.0</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里设置发送包消息仍为 cMessage 类型</p>
</li>
<li>
<p>handleMessage() 针对 self-messages 进行修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc6::handleMessage</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// There are several ways of distinguishing messages, for example by message</span></span><br><span class="line">    <span class="comment">// kind (an int attribute of cMessage) or by class using dynamic_cast</span></span><br><span class="line">    <span class="comment">// (provided you subclass from cMessage). In this code we just check if we</span></span><br><span class="line">    <span class="comment">// recognize the pointer, which (if feasible) is the easiest and fastest</span></span><br><span class="line">    <span class="comment">// method.</span></span><br><span class="line">    <span class="keyword">if</span> (msg == event) &#123;</span><br><span class="line">        <span class="comment">// The self-message arrived, so we can send out tictocMsg and nullptr out</span></span><br><span class="line">        <span class="comment">// its pointer so that it doesn&#x27;t confuse us later.</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Wait period is over, sending back message\n&quot;</span>;</span><br><span class="line">        <span class="built_in">send</span>(tictocMsg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">        tictocMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If the message we received is not our self-message, then it must</span></span><br><span class="line">        <span class="comment">// be the tic-toc message arriving from our partner. We remember its</span></span><br><span class="line">        <span class="comment">// pointer in the tictocMsg variable, then schedule our self-message</span></span><br><span class="line">        <span class="comment">// to come back to us in 1s simulated time.</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Message arrived, starting to wait 1 sec...\n&quot;</span>;</span><br><span class="line">        tictocMsg = msg;</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+<span class="number">1.0</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加了单独的 msg 类型判断，当收到 self-message 时发送 message 给其他模块；如果是其他模块发来的消息则制定 message 任务，延时 1s 后再发送 self-message 消息。</p>
</li>
</ul>
<hr>
<h3 id="tictoc-7">Tictoc 7</h3>
<blockquote>
<p>In this step we’ll introduce random numbers. We change the delay from 1s to a random value which can be set from the NED file or from omnetpp.ini. In addition, we’ll “lose” (delete) the packet with a small probability.</p>
</blockquote>
<ul>
<li>
<p>引入随机数，使用 Omnet++ 下 uniform 函数生成随机数，设置判断条件随机地删除收到的报文。这里可以算是最简单模拟了下实际环境的信道，可能随时出现丢包的情况。<br>
uniform 函数如下图所示</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a random variate with uniform distribution in the range [a,b).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param a, b the interval, a&lt;b</span></span><br><span class="line"><span class="comment"> * @param rng index of the component RNG to use, see getRNG(int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">uniform</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">int</span> rng=<span class="number">0</span>)</span> <span class="type">const</span>  </span>&#123;<span class="keyword">return</span> omnetpp::<span class="built_in">uniform</span>(<span class="built_in">getRNG</span>(rng), a, b);&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>增加 <code>delay</code> 变量，在 ned 文件中进行设置，用于调整循环发送包的间隔。通过 <code>delay</code> 可以简单模拟报文处理的时延；<br>
ned 文件设置为</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">double</span> delayTime @<span class="built_in">unit</span>(s);   <span class="comment">// delay before sending back message</span></span><br></pre></td></tr></table></figure>
<p>cc 文件设置为</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The &quot;delayTime&quot; module parameter can be set to values like</span></span><br><span class="line"><span class="comment">// &quot;exponential(5)&quot; (tictoc7.ned, omnetpp.ini), and then here</span></span><br><span class="line"><span class="comment">// we&#x27;ll get a different delay every time.</span></span><br><span class="line"> <span class="type">simtime_t</span> delay = <span class="built_in">par</span>(<span class="string">&quot;delayTime&quot;</span>);</span><br><span class="line"></span><br><span class="line"> EV &lt;&lt; <span class="string">&quot;Message arrived, starting to wait &quot;</span> &lt;&lt; delay &lt;&lt; <span class="string">&quot; secs...\n&quot;</span>;</span><br><span class="line"> tictocMsg = msg;</span><br><span class="line"> <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+delay, event);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="tictoc-8">Tictoc 8</h3>
<blockquote>
<p>Let us take a step back, and remove random delaying from the code. We’ll leave in, however, losing the packet with a small probability. And, we’ll we do something very common in telecommunication networks: if the packet doesn’t arrive within a certain period, we’ll assume it was lost and create another one. The timeout will be handled using  (what else?) a self-message.</p>
</blockquote>
<p>基于<strong>通信中一个很常见的逻辑</strong>重新设计了本节 – 如果未在规定时间到达则默认该 packet 丢失，然后重新创建一个。下面是几个部分的变化</p>
<p><img src="../../post-images/e0ff0ed439a3d6db48e67495f7f4ad84_MD5.png" alt=""></p>
<ul>
<li>
<p>将 tic 和 toc 分开两部分，分别承担发送方和接收方的功能。tic 发送的报文，当 toc 收到后需要发回一个确认包（acknowledgement），并且有一定概率丢失接收的包（不再设置定时主动发送包，只被动发送）。</p>
</li>
<li>
<p>将前面一直使用的 self message（也可以理解为发包间隔 interval）修改为 timeout，仍然是在收包位置修改了判断逻辑 -&gt; 如果收到 timeout 包，则说明没有在规定时间内收到对面发来的回复包（acknowledgement），于是重新发送 packet 并更新  timer 计时；如果收到了对面的回复包，则确定包发送成功。之后需要取消掉前面规划的 timeoutEvent，重新发送报文并更新 timeout 计时。</p>
<p>简单理解就是，收到 timeout 包运行丢包处理逻辑，收到 acknowledgement 包则正常运行下一次发包逻辑。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tic8::handleMessage</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg == timeoutEvent) &#123;</span><br><span class="line">        <span class="comment">// If we receive the timeout event, that means the packet hasn&#x27;t</span></span><br><span class="line">        <span class="comment">// arrived in time and we have to re-send it.</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Timeout expired, resending message and restarting timer\n&quot;</span>;</span><br><span class="line">        cMessage *newMsg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">send</span>(newMsg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+timeout, timeoutEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// message arrived</span></span><br><span class="line">            <span class="comment">// Acknowledgement received -- delete the received message and cancel</span></span><br><span class="line">            <span class="comment">// the timeout event.</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Timer cancelled.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">cancelEvent</span>(timeoutEvent);</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ready to send another one.</span></span><br><span class="line">        cMessage *newMsg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">send</span>(newMsg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+timeout, timeoutEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加一种新的显示方法（在 toc handleMessage 下），可以运行的图标上直接显示提示字符串，如上图所示。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bubble</span>(<span class="string">&quot;message lost&quot;</span>);  <span class="comment">// making animation more informative...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="tictoc-9">Tictoc 9</h3>
<blockquote>
<p>In the previous model we just created another packet if we needed to retransmit. This is OK because the packet didn’t contain much, but in real life it’s usually more practical to keep a copy of the original packet so that we can re-send it without the need to build it again.</p>
</blockquote>
<ul>
<li>
<p>相比 Tictoc 8 增加了 <code>sendCopyOf(message)</code> 功能，对比直接发送的过程如下</p>
<p>Current</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cMessage *<span class="title">Tic9::generateNewMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Generate a message with a different name every time.</span></span><br><span class="line">    <span class="type">char</span> msgname[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(msgname, <span class="string">&quot;tic-%d&quot;</span>, ++seq);</span><br><span class="line">    cMessage *msg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(msgname);</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tic9::sendCopyOf</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Duplicate message and send the copy.</span></span><br><span class="line">    cMessage *copy = (cMessage *)msg-&gt;<span class="built_in">dup</span>();</span><br><span class="line">    <span class="built_in">send</span>(copy, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Before</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cMessage *newMsg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line"><span class="built_in">send</span>(newMsg, <span class="string">&quot;out&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>个人觉得这里可能体现的不是很明显，new cMessage(msgname) 和 (cMessage *)msg-&gt;dup() 对比感觉差别并不是很大。不过原作者也说过 ”but in real life it’s usually more practical to keep a copy of the original packet“ ，在实际项目中确实可能构建包的开销很大，这里通过 <code>sendCopyOf</code> 函数为后续的功能提供了封装接口。</p>
<p>补充下里面提到的这个接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns an exact copy of this object, except for the</span></span><br><span class="line"><span class="comment"> * message ID (the clone is assigned a new ID). Note that the message</span></span><br><span class="line"><span class="comment"> * creation time is also copied, so clones of the same message object</span></span><br><span class="line"><span class="comment"> * have the same creation time. See cObject for more details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> cMessage *<span class="title">dup</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span>  </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">cMessage</span>(*<span class="keyword">this</span>);&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="tictoc-10">Tictoc 10</h3>
<blockquote>
<p>Let’s make it more interesting by using several (n) `tic’ modules, and connecting every module to every other. For now, let’s keep it simple what they do: module 0 generates a message, and the others keep tossing it around in random directions until it arrives at module 2.</p>
</blockquote>
<p>和之前的例程差别很大，这个例子第一次引入了多模块 vector 以及 forward message 的概念，下面来看下</p>
<ul>
<li>
<p>多模块 vector</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">simple Txc10</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=block/routing&quot;</span>);</span><br><span class="line">    gates:</span><br><span class="line">        input in[];  <span class="comment">// declare in[] and out[] to be vector gates</span></span><br><span class="line">        output out[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network Tictoc10</span><br><span class="line">&#123;</span><br><span class="line">    @<span class="built_in">display</span>(<span class="string">&quot;bgb=364,261&quot;</span>);</span><br><span class="line">    submodules:</span><br><span class="line">        tic[<span class="number">6</span>]: Txc10 &#123;</span><br><span class="line">            @<span class="built_in">display</span>(<span class="string">&quot;p=165,119&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    connections:</span><br><span class="line">        tic[<span class="number">0</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">1</span>].in++;</span><br><span class="line">        tic[<span class="number">0</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">1</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">1</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">2</span>].in++;</span><br><span class="line">        tic[<span class="number">1</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">2</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">1</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">4</span>].in++;</span><br><span class="line">        tic[<span class="number">1</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">4</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">3</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">4</span>].in++;</span><br><span class="line">        tic[<span class="number">3</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">4</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">4</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">5</span>].in++;</span><br><span class="line">        tic[<span class="number">4</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">5</span>].out++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看这里的 gates 描述，<code>input in[]</code> 和 <code>output out[]</code> 代表多个接口，然后 submodules 中也相应修改，需要明确指定模块的个数，然后 <code>connections</code> 里按照数字大小依次连接各个模块。</p>
<p>当这里使用 vector 后，在代码中可以通过 <code>getIndex()</code> 函数来获取到模块的 ID 从而针对性地进行处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the module in a module vector. If the module is not</span></span><br><span class="line"><span class="comment"> * member of a module vector, an exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>forward message</p>
<p>这次初始化从 0 模块开始发送，然后再从 3 模块等待接收</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc10::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getIndex</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Boot the process scheduling the initial message as a self-message.</span></span><br><span class="line">        <span class="type">char</span> msgname[<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(msgname, <span class="string">&quot;tic-%d&quot;</span>, <span class="built_in">getIndex</span>());</span><br><span class="line">        cMessage *msg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(msgname);</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="number">0.0</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc10::handleMessage</span><span class="params">(cMessage *msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getIndex</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Message arrived.</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Message &quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot; arrived.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We need to forward the message.</span></span><br><span class="line">        forwardMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc10::forwardMessage</span><span class="params">(cMessage *msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// In this example, we just pick a random gate to send it on.</span></span><br><span class="line">    <span class="comment">// We draw a random number between 0 and the size of gate `out[]&#x27;.</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">gateSize</span>(<span class="string">&quot;out&quot;</span>);</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">intuniform</span>(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Forwarding message &quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot; on port out[&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">    <span class="built_in">send</span>(msg, <span class="string">&quot;out&quot;</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面介绍下 forwardMessage 里的两个函数</p>
<ul>
<li>
<p><code>gateSize(&quot;out&quot;)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the size of the gate vector with the given name. Gate names with</span></span><br><span class="line"><span class="comment"> * the &quot;$i&quot; or &quot;$o&quot; suffix are also accepted.  Throws an error if there is</span></span><br><span class="line"><span class="comment"> * no such gate, or it is not a gate vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see cGate::getVectorSize()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">gateSize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *gatename)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Intuniform(0, n-1)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a random integer with uniform distribution in the range [a,b],</span></span><br><span class="line"><span class="comment"> * inclusive. (Note that the function can also return b.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param a, b  the interval, a&lt;=b</span></span><br><span class="line"><span class="comment"> * @param rng index of the component RNG to use, see getRNG(int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">intuniform</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> rng=<span class="number">0</span>)</span> <span class="type">const</span>  </span>&#123;<span class="keyword">return</span> omnetpp::<span class="built_in">intuniform</span>(<span class="built_in">getRNG</span>(rng), a, b);&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>​		这里也第一次出现三个参数的 <code>send(msg, &quot;out&quot;, k)</code>，<code>k</code> 代表着发送到连接的第几个 module，也只有连接多		个 module 时才能使用。</p>
<hr>
<h3 id="tictoc-11-12">Tictoc 11-12</h3>
<blockquote>
<p>Let’s make it more interesting by using several (n) `tic’ modules, and connecting every module to every other. For now, let’s keep it simple what they do: module 0 generates a message, and the others keep tossing it around in random directions until it arrives at  module 2.</p>
</blockquote>
<p>对比 Tictoc 10，11 和 12 在代码实现上没有差别，仅在 ned 文件上更改了实现，变化如下<br>
<img src="../../post-images/82319851718f5022f413a85315e9addb_MD5.png" alt=""><br>
这里的 channel 暂时没有搜索相关资料，后续补充。</p>
<hr>
<h3 id="tictoc-13">Tictoc 13</h3>
<blockquote>
<p>In this step the destination address is no longer node 2 – we draw a random destination, and we’ll add the destination address to the message. The best way is to subclass cMessage and add destination as a data member. Hand-coding the message class is usually tiresome because it contains a lot of boilerplate code, so we let OMNeT++ generate the class for us.<br>
The message class specification is in <code>tictoc13.msg</code> – <code>tictoc13_m.h</code> and <code>.cc</code> will be generated from this file automatically. To make the model execute longer, after a message arrives to its destination the destination node will generate another message with a random destination address, and so forth.</p>
</blockquote>
<ul>
<li>
<p>Tictoc 13 第一次引入了自定义 message 的概念，文件后缀为 .msg，在其中定义 message 的字段，然后其它的便不需要写了，直接交给 Omnet ++ 自行生成处理即可，当系统运行后会自动生成了类似“ 文件名_m.h 和文件名_m.cc” 的两个文件，其中包括了所有获取 message 内字段的接口（读取写入）。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message TicTocMsg13</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> source;</span><br><span class="line">    <span class="type">int</span> destination;</span><br><span class="line">    <span class="type">int</span> hopCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>既然 Message 变为自定义的，那么 Handle Message 的方式也要相应发生改变。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc13::handleMessage</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     TicTocMsg13 *ttmsg = <span class="built_in">check_and_cast</span>&lt;TicTocMsg13 *&gt;(msg);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (ttmsg-&gt;<span class="built_in">getDestination</span>() == <span class="built_in">getIndex</span>()) &#123;</span><br><span class="line">         <span class="comment">// Message arrived.</span></span><br><span class="line">         EV &lt;&lt; <span class="string">&quot;Message &quot;</span> &lt;&lt; ttmsg &lt;&lt; <span class="string">&quot; arrived after &quot;</span> &lt;&lt; ttmsg-&gt;<span class="built_in">getHopCount</span>() &lt;&lt; <span class="string">&quot; hops.\n&quot;</span>;</span><br><span class="line">         <span class="built_in">bubble</span>(<span class="string">&quot;ARRIVED, starting new one!&quot;</span>);</span><br><span class="line">         <span class="keyword">delete</span> ttmsg;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Generate another one.</span></span><br><span class="line">         EV &lt;&lt; <span class="string">&quot;Generating another message: &quot;</span>;</span><br><span class="line">         TicTocMsg13 *newmsg = <span class="built_in">generateMessage</span>();</span><br><span class="line">         EV &lt;&lt; newmsg &lt;&lt; endl;</span><br><span class="line">         forwardMessage(newmsg);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// We need to forward the message.</span></span><br><span class="line">         forwardMessage(ttmsg);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到处理报文的第一步首先要把收到的 msg 转换为自定义的 Message 的格式，这里个人有点不理解，如果 msg 本身不是自定义格式，那么转换会有什么结果呢？（可能需要再深入理解下 C++ 语法）<br>
之后在判断语句位置可以看到 ttmsg 调用自定义 Message 的接口，格式大致就是 <code>getDestination()</code> 或者 <code>setDestination()</code>。通过将 destination 包含在 Message 中，可以更加灵活地指定，避免代码和参数的过度耦合。从 generateMessage 函数改变也可以看到自定义 Message 是如何写入的。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> msgname[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(msgname, <span class="string">&quot;tic-%d-to-%d&quot;</span>, src, dest);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// Create message object and set source and destination field.</span></span><br><span class="line">TicTocMsg13 *msg = <span class="keyword">new</span> <span class="built_in">TicTocMsg13</span>(msgname);</span><br><span class="line">msg-&gt;<span class="built_in">setSource</span>(src);</span><br><span class="line">msg-&gt;<span class="built_in">setDestination</span>(dest);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="tictoc-14">Tictoc 14</h3>
<blockquote>
<p>In this step we keep track of how many messages we send and received. and display it above the icon.</p>
</blockquote>
<ul>
<li>
<p>ned 和 msg 文件和之前没有多少变化，最主要地是增加了 WATCH 函数的使用，方便我们更清楚地感知系统的状态。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc14::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize variables</span></span><br><span class="line">    numSent = <span class="number">0</span>;</span><br><span class="line">    numReceived = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WATCH</span>(numSent);</span><br><span class="line">    <span class="built_in">WATCH</span>(numReceived);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Module 0 sends the first message</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getIndex</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Boot the process scheduling the initial message as a self-message.</span></span><br><span class="line">        TicTocMsg14 *msg = <span class="built_in">generateMessage</span>();</span><br><span class="line">        numSent++;</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="number">0.0</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下<br>
<img src="../../post-images/34f2d8af3d2ac5eb558504b69966cec9_MD5.png" alt=""></p>
</li>
<li>
<p>Override 系统的 refreshDisplay 函数，打印出上图的效果，关于这部分没有具体查阅资料，后续补上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc14::refreshDisplay</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;rcvd: %ld sent: %ld&quot;</span>, numReceived, numSent);</span><br><span class="line">    <span class="built_in">getDisplayString</span>().<span class="built_in">setTagArg</span>(<span class="string">&quot;t&quot;</span>, <span class="number">0</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="tictoc-15">Tictoc 15</h3>
<blockquote>
<p>This model is exciting enough so that we can collect some statistics. We’ll record in output vectors the hop count of every message upon arrival. Output vectors are written into the omnetpp.vec file and can be visualized with the Plove program. We also collect basic statistics (min, max, mean, std.dev.) and histogram about the hop count which we’ll print out at the end of the simulation.</p>
</blockquote>
<p>增加了数据统计的功能，对于后续的数据分析很重要。</p>
<ul>
<li>
<p>首先要在 omnetpp.ini 中开启 record-evertlog，只有开启这个之后才能在代码中调用 <code>recordScalar</code> 函数，用了录制收集特定的数据，在该模块中是在 <code>finish()</code> 函数中开启的调用。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Tictoc15]</span><br><span class="line"> network = Tictoc15</span><br><span class="line"> record-eventlog = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在私有成员中<strong>加入统计属性的变量</strong>，关于这两个类型的具体介绍见 Omnet++ manual 第 7.9 节。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cHistogram hopCountStats;</span><br><span class="line">cOutVector hopCountVector;</span><br></pre></td></tr></table></figure>
<p>其使用之前首先要在 <code>initlaize()</code> 中进行初始化</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hopCountStats.<span class="built_in">setName</span>(<span class="string">&quot;hopCountStats&quot;</span>);</span><br><span class="line">hopCountVector.<span class="built_in">setName</span>(<span class="string">&quot;HopCount&quot;</span>);			</span><br></pre></td></tr></table></figure>
<p>调用方式</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hopcount = ttmsg-&gt;<span class="built_in">getHopCount</span>();</span><br><span class="line">EV &lt;&lt; <span class="string">&quot;Message &quot;</span> &lt;&lt; ttmsg &lt;&lt; <span class="string">&quot; arrived after &quot;</span> &lt;&lt; hopcount &lt;&lt; <span class="string">&quot; hops.\n&quot;</span>;</span><br><span class="line"><span class="built_in">bubble</span>(<span class="string">&quot;ARRIVED, starting new one!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update statistics.</span></span><br><span class="line">numReceived++;</span><br><span class="line">hopCountVector.<span class="built_in">record</span>(hopcount);</span><br><span class="line">hopCountStats.<span class="built_in">collect</span>(hopcount);</span><br></pre></td></tr></table></figure>
<p>以及最后调用 finish 收尾</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc15::finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This function is called by OMNeT++ at the end of the simulation.</span></span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Sent:     &quot;</span> &lt;&lt; numSent &lt;&lt; endl;</span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; numReceived &lt;&lt; endl;</span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Hop count, min:    &quot;</span> &lt;&lt; hopCountStats.<span class="built_in">getMin</span>() &lt;&lt; endl;</span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Hop count, max:    &quot;</span> &lt;&lt; hopCountStats.<span class="built_in">getMax</span>() &lt;&lt; endl;</span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Hop count, mean:   &quot;</span> &lt;&lt; hopCountStats.<span class="built_in">getMean</span>() &lt;&lt; endl;</span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Hop count, stddev: &quot;</span> &lt;&lt; hopCountStats.<span class="built_in">getStddev</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">recordScalar</span>(<span class="string">&quot;#sent&quot;</span>, numSent);</span><br><span class="line">    <span class="built_in">recordScalar</span>(<span class="string">&quot;#received&quot;</span>, numReceived);</span><br><span class="line"></span><br><span class="line">    hopCountStats.<span class="built_in">recordAs</span>(<span class="string">&quot;hop count&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结束可以看到一个 results 文件夹，里面内容如下<br>
<img src="../../post-images/9f59cc2a59b2106bf843a3bac9742108_MD5.png" alt="image-20220922223953758"></p>
</li>
</ul>
<p>具体每个文件如何使用，可以查看如下 <a href="https://www.cnblogs.com/ShineLeBlog/p/14767734.html">omnet++：官方文档翻译总结（五） - ShineLe - 博客园</a></p>
<hr>
<h3 id="tictoc-16">Tictoc 16</h3>
<blockquote>
<p>The main problem with the previous step is that we must modify the model’s code if we want to change what statistics are gathered. Statistic calculation is woven deeply into the model code which is hard to modify and understand.<br>
OMNeT++ 4.1 provides a different mechanism called ‘signals’ that we can use to gather statistics. First we have to identify the events where the state of the model changes. We can emit signals at these points that carry the value of chosen state variables. This way the C++ code only emits signals, but how those signals are processed are determined only by the listeners that are attached to them.<br>
The signals the model emits and the listeners that process them can be defined in the NED file using the ‘signal’ and ‘statistic’ property. We will gather the same statistics as in the previous step, but notice that we will not need any private member variables to calculate these values. We will use only a single signal that is emitted when a message arrives and carries the hopcount in the message.</p>
</blockquote>
<p>在 Tictoc 15 中</p>
<p>详见 <a href="https://www.cnblogs.com/ShineLeBlog/p/14765282.html">omnet++：官方文档翻译总结（四） - ShineLe - 博客园</a></p>
<ul>
<li>
<p>使用同一的接口 arrivalSignal 来替代之前的两个变量<br>
Before</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cHistogram hopCountStats;</span><br><span class="line">cOutVector hopCountVector;</span><br></pre></td></tr></table></figure>
<p>Now</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">simsignal_t</span> arrivalSignal;</span><br></pre></td></tr></table></figure>
<p>通过这个接口避免了与特定的统计变量进行绑定，使其更加灵活。取而代之，原先的统计也相应地进行了修改。<br>
Before</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hopCountVector.<span class="built_in">record</span>(hopcount);</span><br><span class="line">hopCountStats.<span class="built_in">collect</span>(hopcount);</span><br></pre></td></tr></table></figure>
<p>Now</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// send a signal</span><br><span class="line">emit(arrivalSignal, hopcount);</span><br></pre></td></tr></table></figure>
<p>同时需要注意在使用 arrivalSignal 之前必须先注册所有的 signals，注册代码通常放在 <code>initlaize()</code> 函数中。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrivalSignal = <span class="built_in">registerSignal</span>(<span class="string">&quot;arrival&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>由于我们不用保存任何数据，所以 <code>finish()</code>方法可以删去了。</p>
</li>
<li>
<p>最后是 ned 文件中定义 signal 的相关信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">simple Txc16</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @signal[arrival](type=<span class="string">&quot;long&quot;</span>);</span><br><span class="line">        @statistic[hopCount](title=<span class="string">&quot;hop count&quot;</span>; source=<span class="string">&quot;arrival&quot;</span>; record=vector,stats; interpolationmode=none);</span><br><span class="line"></span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=block/routing&quot;</span>);</span><br><span class="line">    gates:</span><br><span class="line">        inout gate[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该节中我们仍然是统计 hop count的信息（最大值、最小值、均值、总和等），所以让我们在本例中收集相同的数据。<code>source</code> 关键字指明了附加我们的统计数据的 signal；<code>record</code> 关键字告诉我们需要如何处理收到的数据。本例中我们需要将每个值都保存到 vector file（<code>vector</code> 关键字）中，此外还要统计上段中说到的那些统计信息（<code>stats</code> 关键字）。NED文件写完之后，我们就完成了我们的 model。</p>
<p>现在我们需要查看 tic[1] module 中关于hopCount的直方图，此外我们不需要记录tic 0,1,2的vector data。我们可以不用修改 C++ 和 NED 文件来实现添加直方图并且移除不需要的 vector 的目的，只需要打开 ini 文件并且修改统计数据的记录语句即可。如下所示</p>
</li>
<li>
<p><code>Omnetpp.ini</code> 修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Tictoc16]</span><br><span class="line">network = Tictoc16</span><br><span class="line">**.tic[<span class="number">1</span>].hopCount.result-recording-modes = +histogram</span><br><span class="line">**.tic[<span class="number">0.</span><span class="number">.2</span>].hopCount.result-recording-modes = -vector</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="tictoc-17">Tictoc 17</h3>
<blockquote>
<p>官方没有注释</p>
</blockquote>
<p>OMNET++可以在 canvas 上展示一系列的 figures，例如文本、几何图形、图像。这些figures可以是静态的，也可以根据仿真过程中发生的事件动态变化。本例中，我们展示了静态描述文本、动态显示hop count的文本。</p>
<ul>
<li>
<p>在ned文件中创建figures，需要在parameters用@figure说明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">network Tictoc17</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @figure[description](type=text;pos=<span class="number">5</span>,<span class="number">20</span>;font=,,bold;</span><br><span class="line">                    text=<span class="string">&quot;Random routing example - displaying last hop count&quot;</span>);</span><br><span class="line">        @figure[lasthopcount](type=text;pos=<span class="number">5</span>,<span class="number">35</span>;text=<span class="string">&quot;last hopCount: N/A&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这里创建了两个文本 figure，它们的名字是 <code>description</code> 和 <code>lasthopcount</code>，并且设置了它们的位置坐标。font 参数说明了文本字体，有三个分量——typeface, size, style。这三个分量中的每一个都可以略去，这样实际中会代之以默认值。本例中我们只是设置了字体的 style 为 bold。</p>
</li>
<li>
<p>默认情况下 lasthopcount 中的文本是静态的，但是当消息到达时需要修改它。要做到这一点，需要修改<code>handleMessage()</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">hasGUI</span>())&#123;</span><br><span class="line">    <span class="type">char</span> label[<span class="number">50</span>];</span><br><span class="line">    <span class="comment">//把last hop count写为string形式</span></span><br><span class="line">    <span class="built_in">sprintf</span>(label,<span class="string">&quot;last hopCount = %d&quot;</span>,hopcount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个指向figure的指针</span></span><br><span class="line">    cCanvas * canvas = <span class="built_in">getParentModule</span>()-&gt;<span class="built_in">getCanvas</span>();</span><br><span class="line">    cTextFigure *textFigure = <span class="built_in">check_and_cast</span>&lt;cTextFigure*&gt;(canvas-&gt;<span class="built_in">getFigure</span>(<span class="string">&quot;lasthopcount&quot;</span>));</span><br><span class="line">    <span class="comment">//更新文本</span></span><br><span class="line">    textFigure-&gt;<span class="built_in">setText</span>(label);&#125;</span><br></pre></td></tr></table></figure>
<p>文件中用 <code>cTextFigure</code> 这个 class 代表 figure。figure types有很多种，所有都是继承自<code>cFigure</code>的子类。我们在得到<code>hopCount</code>变量之后，即可写入代码并更新文本。</p>
<p>对上文代码的解释，我们要在 network 的 canvas 上画 figures，<code>getParentModule()</code>函数返回这个节点的父 module，比如 network。<code>getCanvas()</code>函数返回 network 的 canvas，<code>getFigure()</code>可以通过 Figure 名得到figure。之后我们用<code>setText()</code>函数更新 figure 文本。</p>
<p>当我们运行仿真时，在第一个消息到达前，figure 会显示 “last hopCount：N/A”。之后，每当一个消息到达它的目的地时，这个文本都会更新。</p>
<p><img src="../../post-images/5eda3d270cb76b1c46fb969db66fcf18_MD5.png" alt="img"></p>
</li>
<li>
<p>如果对布局不满意，比如figure文本和节点重叠在一块了，可以点击“re-layout”</p>
<p><img src="../../post-images/52ca65052a17614d3c7f74b1a7dba977_MD5.png" alt="img"></p>
</li>
</ul>
<hr>
<h3 id="tictoc-18">Tictoc 18</h3>
<ul>
<li>
<p>哑铃型的网络拓扑结构，两端各两个节点连接，中间 <code>numCentralNodes</code> 个节点连接。中心节点数目为 4 时形状大致如下</p>
<p><img src="../../post-images/ab798846cb30ebef1bae08bbff92d8e9_MD5.png" alt="img"></p>
<p>对比下面代码可能更容易理解些，for 循环前是左端两个节点的连接，for 循环则是中间多个节点依次连接，for 循环后则是右端两个节点的连接。因为 tictoc 中节点是从 0 开始的，因此右端节点连接时注意 + 1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">simple Txc18 extends Txc16</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network TicToc18</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        <span class="type">int</span> numCentralNodes = <span class="built_in">default</span>(<span class="number">2</span>);</span><br><span class="line">    types:</span><br><span class="line">        channel Channel extends ned.DelayChannel &#123;</span><br><span class="line">            delay = <span class="number">100</span>ms;</span><br><span class="line">        &#125;</span><br><span class="line">    submodules:</span><br><span class="line">        tic[numCentralNodes+<span class="number">4</span>]: Txc18;</span><br><span class="line">    connections:</span><br><span class="line">        <span class="comment">// connect the 2 nodes in one side to the central nodes</span></span><br><span class="line">        tic[<span class="number">0</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[<span class="number">2</span>].gate++;</span><br><span class="line">        tic[<span class="number">1</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[<span class="number">2</span>].gate++;</span><br><span class="line">        <span class="comment">// connect the central nodes together</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">2.</span>.numCentralNodes+<span class="number">1</span> &#123;</span><br><span class="line">            tic[i].gate++ &lt;--&gt; Channel &lt;--&gt; tic[i+<span class="number">1</span>].gate++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// connect the 2 nodes on the other side to the central nodes</span></span><br><span class="line">        tic[numCentralNodes+<span class="number">2</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[numCentralNodes+<span class="number">1</span>].gate++;</span><br><span class="line">        tic[numCentralNodes+<span class="number">3</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[numCentralNodes+<span class="number">1</span>].gate++;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指定中心节点的数量 N 从 2 到 100，步长为 2，产生 50 次仿真；</p>
<p>为了提高仿真准确度，我们需要用不同的随机数运行多次运行相同的仿真。这样的运行称为 Repetitions 并且在 ini 文件中加以指定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*.numCentralNodes = $&#123;N=<span class="number">2.</span><span class="number">.100</span> step <span class="number">2</span>&#125;</span><br><span class="line">repeat = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>每个仿真都要被运行4次，每次都有不同的 seed。这可以提供更多的样本，使结果更加平均。重复的越多，结果将会越来越变成期望的结果。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://qiaoxu123.github.io">xqiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://qiaoxu123.github.io/posts/Omnet-Veins/20220921-omnet++-samples-tictoc-practice.html">http://qiaoxu123.github.io/posts/Omnet-Veins/20220921-omnet++-samples-tictoc-practice.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/">经验总结</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/Omnet-Veins/20220924-omnet++-samples-2-FIFO.html" title="Omnet++ Samples 学习 2 - FIFO"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">Omnet++ Samples 学习 2 - FIFO</div></div></a></div><div class="next-post pull-right"><a href="/posts/Omnet-Veins/20220918-veins-analoguemodels.html" title="Veins Module 浅析1 -- AnalogueModels 的调用逻辑"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Veins Module 浅析1 -- AnalogueModels 的调用逻辑</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xqiao</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><a id="card-info-btn" href="https://github.com/qiaoxu123"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/qiaoxu123" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:george.x.qiao@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">个人的技术小站，随性记录问题或整理学习。文章内容如有疑问请邮件联系，备注关键字博客，会尽力解答，有的时间太长已不再维护，望理解，谢谢！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-1"><span class="toc-text">Tictoc 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-2"><span class="toc-text">Tictoc 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-3"><span class="toc-text">Tictoc 3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-4"><span class="toc-text">Tictoc 4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-5"><span class="toc-text">Tictoc 5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-6"><span class="toc-text">Tictoc 6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-7"><span class="toc-text">Tictoc 7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-8"><span class="toc-text">Tictoc 8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-9"><span class="toc-text">Tictoc 9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-10"><span class="toc-text">Tictoc 10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-11-12"><span class="toc-text">Tictoc 11-12</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-13"><span class="toc-text">Tictoc 13</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-14"><span class="toc-text">Tictoc 14</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-15"><span class="toc-text">Tictoc 15</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-16"><span class="toc-text">Tictoc 16</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-17"><span class="toc-text">Tictoc 17</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tictoc-18"><span class="toc-text">Tictoc 18</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/FPGA/20240301-Interface-Synthesis.html" title="HLS Learning P13 - Interface Synthesis">HLS Learning P13 - Interface Synthesis</a><time datetime="2024-02-29T16:00:00.000Z" title="Created 2024-03-01 00:00:00">2024-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/FPGA/20240229-Implementing-Arrays-as-RTL-Interfaces.html" title="HLS Learning P12 - Implementing Arrays as RTL Interfaces">HLS Learning P12 - Implementing Arrays as RTL Interfaces</a><time datetime="2024-02-28T16:00:00.000Z" title="Created 2024-02-29 00:00:00">2024-02-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/FPGA/20240227-Basic-Introduction-of-Interface-synthesis.html" title="HLS Learning P11 - Basic Introduction of Interface Synthesis">HLS Learning P11 - Basic Introduction of Interface Synthesis</a><time datetime="2024-02-26T16:00:00.000Z" title="Created 2024-02-27 00:00:00">2024-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/FPGA/20240218-Quartus-RTL-Analyzer.html" title="Quartus RTL Analyzer 使用笔记">Quartus RTL Analyzer 使用笔记</a><time datetime="2024-02-17T16:00:00.000Z" title="Created 2024-02-18 00:00:00">2024-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/uncategorized/20240208-blog-directory.html" title="博客内容目录">博客内容目录</a><time datetime="2024-02-07T16:00:00.000Z" title="Created 2024-02-08 00:00:00">2024-02-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By xqiao</div><div class="framework-info"><span>Framework </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>