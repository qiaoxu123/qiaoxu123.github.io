<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HLS Learning P16 - Optimization of for-loop - Loop Merging</title>
      <link href="/posts/FPGA/20240305-Optimization-of-for-loop-loop-merging.html"/>
      <url>/posts/FPGA/20240305-Optimization-of-for-loop-loop-merging.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-introduction">1. Introduction</h1><p>接着上讲继续来说 for-loop 的另一种方法：loop merging。</p><p>如下图中例子，两个 for-loop 分别执行 add 和 sub 操作，彼此互不干涉，理论上我们希望它们能够是并行执行的，最后生成的电路应该如下图右侧所示。<br><img src="../../../post-images/Pasted%20image%2020240114142341.png" alt=""><br>而实际上 HLS 生成的电路，两个 for 循环是按顺序进行的，如下图所示分别占用了 8 个时钟周期，考虑到进入 for 循环和离开 for 循环需要 2 个时钟周期，一共占用了 18 个时钟周期。<br><img src="../../../post-images/Pasted%20image%2020240114142350.png" alt=""></p><h1 id="2-merge-loops">2. Merge loops</h1><p>为了解决上面的问题，在 Vivado 中使用 Merge 的方法来解决。先引入一个新的概念：Region，Region 下所包含的 for 循环是它的作用域，类似 for-loop 上的关键字，用一个关键字加大括号对想要覆盖的 logic 进行包含。当 GUI 右侧 Directive 窗口出现对应关键字时说明生效。</p><p><img src="../../../post-images/Pasted%20image%2020240114142407.png" alt=""><br>使用 Regions 进行合并后 loop 变成了一个，latency 和 interval 也大大降低。<br><img src="../../../post-images/Pasted%20image%2020240114142418.png" alt=""></p><p>实际 for-loop 在运行时，会创建包含多种状态的状态机，因此会消耗较多资源。通过合并操作可以减少资源使用并降低时钟周期。</p><p><img src="../../../post-images/Pasted%20image%2020240114142434.png" alt=""></p><h1 id="3-different-bound">3. Different bound</h1><p>上面例子中循环边界是相同的常数，实际中循环边界情况各种各样，merge 又会遇到什么情况呢？</p><h2 id="a-different-constant-loop-bound">a. Different constant loop bound</h2><p>如果 for 循环边界是不同的常数，合并后是以最大的作为合并后的边界。<br><img src="../../../post-images/Pasted%20image%2020240114142442.png" alt=""></p><h2 id="b-variable-bound-and-constant-bound">b. Variable Bound and Constant Bound</h2><p>其次，如果边界一个常数一个变量，那么是没有办法合并的。这里 sub for-loop 的循环边界是一个 <code>ap_uint&lt;4&gt;</code> 的变量，因此其范围是 0~15。<br><img src="../../../post-images/Pasted%20image%2020240114143825.png" alt=""></p><h2 id="c-variable-loop-bounds">c. Variable Loop Bounds</h2><p>在两个循环边界都是变量的情况下直接进行 merge 也是会报错的，但可以通过一些技巧来解决。</p><p><img src="../../../post-images/Pasted%20image%2020240114142449.png" alt=""><br>假设这里 J 小于 K，可以将上面的 for 循环拆解开。然后进行 merge<br><img src="../../../post-images/Pasted%20image%2020240114142456.png" alt=""></p><h1 id="4-summary">4. Summary</h1><p>以上合并规则总结如下<br><img src="../../../post-images/Pasted%20image%2020240114142503.png" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240114142529.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P14 - Optimization of for-loop - Performance Metrics</title>
      <link href="/posts/FPGA/20240303-Optimization-of-for-loop-performance-metrics.html"/>
      <url>/posts/FPGA/20240303-Optimization-of-for-loop-performance-metrics.html</url>
      
        <content type="html"><![CDATA[<p>从这一节起开始一个新的 Chapter -&gt; Optimization of for-loop，大约有 5 节课程的内容，从不同方面介绍如何对 C 语言下最常见的 for-loop 从底层角度进行优化。</p><p>这节课所要讲解的内容如下，包括与 for-loop 相关的基本概念，对 for-loop 进行 pipelining 和 unrolling，以及迭代变量类型的影响。</p><p><img src="../../../post-images/Pasted%20image%2020240113143926.png" alt=""></p><h1 id="1-basic-concepts-associated-with-for-loop">1. Basic concepts associated with for-loop</h1><p>下图中的一段代码按照 clock cycle 进行拆分，for-loop 对应 1,2,3 步。其中的 Loop Interation Latency 以及 Loop II 都是 for-loop 中很重要的指标，从 report 中后续可以查看到。</p><p><img src="../../../post-images/Pasted%20image%2020240113143935.png" alt=""></p><p>下图便是代码编译后得到的 report 信息，可以看到 Loop 一栏中有上面图中提到的几个参数。从波形图来看，当 ap_start 为高时开始，ap_done 为高时结束，便可以得到每次 loop 的 latency 以及 interval。有一点需要注意的是，硬件电路在执行 for 循环时并不能在每次 loop 结束后马上进入下一个 loop，而是需要判断循环变量是否超出了边界，这便是多出来的一个时钟周期的原因。</p><p><img src="../../../post-images/Pasted%20image%2020240113143943.png" alt=""></p><h1 id="2-pipelining-the-loop">2. Pipelining the Loop</h1><p>这种方法算是对 for-loop 最常规的一种优化了，设置方法也很简单，如下图所示。思路也很简单，将原先的串行改为并行，把不同指令操作的执行给并行化。</p><p><img src="../../../post-images/Pasted%20image%2020240113143951.png" alt=""></p><p>从波形图中可以看到 latency 和 interval 都大大减少了。</p><p><img src="../../../post-images/Pasted%20image%2020240113143958.png" alt=""></p><h1 id="3-unrolling-the-loop">3. Unrolling the Loop</h1><p>既然提到了 Unrolling（展开），那么就要说到默认情况下 for-loop 其实是被折叠的。意思是，每次 for-loop 都是使用同一套电路，只是他们被分时复用了。展开就意味着这个 for-loop 被复制了多份，占用资源变多，相当于以面积换时间。</p><p><img src="../../../post-images/Pasted%20image%2020240113144006.png" alt=""></p><p>也可以进行部分展开，用 C 语言表示的话可以拆分成如下代码</p><p><img src="../../../post-images/Pasted%20image%2020240113144013.png" alt=""></p><p>在 Directive 中需要修改 factor，其参数代表将 for-loop 复制了几份。从硬件层面来看如下图右侧所示</p><p><img src="../../../post-images/Pasted%20image%2020240113144020.png" alt=""></p><p>变量 <code>i</code> 声明为 <code>int</code> 或者 <code>ap_int&lt;4&gt;</code> 没有影响，vivado HLS 主要考虑的是变量的范围，这个范围决定了资源的使用量。</p><p><img src="../../../post-images/Pasted%20image%2020240113144026.png" alt=""></p><h1 id="4-summary">4. Summary</h1><p><img src="../../../post-images/image-20240304092928910.png" alt="image-20240304092928910"></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P13 - Interface Synthesis</title>
      <link href="/posts/FPGA/20240301-Interface-Synthesis.html"/>
      <url>/posts/FPGA/20240301-Interface-Synthesis.html</url>
      
        <content type="html"><![CDATA[<p>Vivado HLS 提供了多种灵活的方式来修改子函数的 interface，课程中讲解了三种方式，最后总结中的 Setting the property of reset 方式没讲。</p><h1 id="1-adding-registers-to-io-ports">1. Adding Registers to IO Ports</h1><p>给输入输出端口添加寄存器是解决时序收敛的很有效的方式，但默认情况下 Vivado HLS 不会给我们添加寄存器的，需要我们手动在 Driective 中选择。下图中间选择 register 后相当于给输出端口添加了寄存器，对于输入端口则需要像右侧图所示，选择对应的端口名称去添加寄存器。<br><img src="../../../post-images/Pasted%20image%2020240107154750.png" alt=""><br>如下图所示修改完 Directive 后三个输入端口，return 返回值输出端口都添加了寄存器。此外，对于控制电路 ap_CS_fsm 也消耗了寄存器，总共消耗了 44 个。需要注意的是，添加IO 寄存器时需要确保 Directive 中 Interface 的 Protocol 是 <code>ap_ctrl_hs</code> 。<br><img src="../../../post-images/Pasted%20image%2020240107154540.png" alt=""></p><h1 id="2-implementing-design-with-global-ce">2. Implementing Design with Global CE</h1><p>添加全局的时钟使能信号，最后生成 ap_ce 信号。具体操作是在 Solution 层面勾选 config_interface 并选中 clock_enable。通过这样，确保全局的电路只有在时钟使能的情况下才能工作。</p><p><img src="../../../post-images/Pasted%20image%2020240107154555.png" alt=""></p><p>在 GUI 中操作大致如下：右击 solution，在 General 中选择 Add，从 Command 中选中 config_interface，最后勾选 clock_enable 即可。</p><p><img src="../../../post-images/image-20240301105556022.png" alt="image-20240301105556022"></p><h1 id="3-controlling-the-number-of-design-ios">3. Controlling the Number of Design IOs</h1><p>以矩阵加法为例，可以通过对 for-loop 设置 pipeline 来实现低的 latency，后面课程会具体讲 for-loop 的优化方式。</p><p><img src="../../../post-images/Pasted%20image%2020240107154615.png" alt=""></p><p>设置 pipeline 的效果如下，可以看到 latency 明显降低但 IO 个数增加了些。</p><p><img src="../../../post-images/Pasted%20image%2020240107154626.png" alt=""></p><p>采用折中的方式，使用 Single Port RAM 进行约束。右击 Directive 列表中作为函数参数的数组，然后存储类型选择 RESOURCE，之后在下面的 core 中的 下拉栏中选择 RAM_1P 即可。</p><p><img src="../../../post-images/image-20240301104616001.png" alt="image-20240301104616001"></p><p>可以看到左侧 port 数目不变，虽然 latency 相比纯 Pipeline 方式要高一些但仍然是比最开始的要低。</p><p><img src="../../../post-images/Pasted%20image%2020240107154633.png" alt=""></p><p>通过修改 config_rtl 可以指定状态机的编码方式，如 auto、binary、onehot 以及 gray 等，此外还可以指定 reset 方式比如是高有效还是低有效。</p><p><img src="../../../post-images/Pasted%20image%2020240107154641.png" alt=""></p><h1 id="4-summary">4. Summary</h1><p><img src="../../../post-images/Pasted%20image%2020240107154901.png" alt=""></p><h1 id="5-demo">5. Demo</h1><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatAdd.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MatAdd</span><span class="params">(<span class="type">data_t</span> mat_a[M][N], <span class="type">data_t</span> mat_b[M][N], <span class="type">data_t</span> sum[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">loop_i:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">&#123;</span><br><span class="line">loop_j:</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">&#123;</span><br><span class="line">sum[i][j] = mat_a[i][j] + mat_b[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P12 - Implementing Arrays as RTL Interfaces</title>
      <link href="/posts/FPGA/20240229-Implementing-Arrays-as-RTL-Interfaces.html"/>
      <url>/posts/FPGA/20240229-Implementing-Arrays-as-RTL-Interfaces.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-array-arguments">1. Array Arguments</h1><p>这里所说的 Arrays 是作为 <font color="#95b3d7">top-level functions</font> arguments，后面会说当其作为 arguments of <font color="#95b3d7">sub-module</font> 时如何进行优化。如下图中所说，Synthesis 时默认会把 array arguments 转为 RAM ports，这个过程是允许你通过修改 diretives 选择 RAM interface 是单口还是双口的，但如果 Vivado HLS 认为只需要 single port 就够了，那么它最后会帮你替换为 single port。另外通过修改 directives 还可以选择使用 FIFO interfaces 以及 partition（这里其实 Arrays can be <font color="#95b3d7">partitioned</font> according to <font color="#95b3d7">the data rate requirements</font>，后面课程中会讲解）。<br><img src="../../../post-images/Pasted%20image%2020240107104831.jpeg" alt=""></p><h1 id="2-case-analysis">2. Case Analysis</h1><h2 id="a-memory-interface-default">a. Memory Interface (Default)</h2><p>只要 array 作为 top-level function 的 arguments，无论什么类型，默认 protocol 都是 ap_memory。</p><p>补充：<code>d_o_ce0</code> 是片选信号。</p><p><img src="../../../post-images/Pasted%20image%2020240107104902.jpeg" alt=""></p><p>从时序波形图上看每个信号的作用</p><p><img src="../../../post-images/Pasted%20image%2020240107104916.png" alt=""></p><p>将 top-level function 综合后得到的 IP 与 RAM 模块进行连接，此时需要我们手动添加 RAM 进去，通过片选信号来决定是否激活连接。<br><img src="../../../post-images/Pasted%20image%2020240107104928.jpeg" alt=""></p><h2 id="b-fifo-interface">b. FIFO Interface</h2><p>当数据是 stream 时可以修改 directives 选择 ap_fifo mode，会生成两组 ports（FIFO 的 input 和 output ），Protocol 均为 ap_fifo。<br><img src="../../../post-images/Pasted%20image%2020240107104936.png" alt=""></p><p>同样需要手动连接一块 memory</p><p><img src="../../../post-images/Pasted%20image%2020240107104943.jpeg" alt=""></p><h1 id="3-summary">3. Summary</h1><p><img src="../../../post-images/Pasted%20image%2020240107105009.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P11 - Basic Introduction of Interface Synthesis</title>
      <link href="/posts/FPGA/20240227-Basic-Introduction-of-Interface-synthesis.html"/>
      <url>/posts/FPGA/20240227-Basic-Introduction-of-Interface-synthesis.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-interface-synthesis">1. Interface Synthesis</h1><p>这一部分首先区分了两部分端口，他们二者是独立的。一个是 Block-level interface，是 HLS 综合后默认生成的，与函数的参数列表无关，用来管理和查看 module 的状态如 start，done 或 idle 等；另一个是 Port-level interface，包括了函数形参以及返回值所生成的 signal，这部分是代码中能看到的。以上两种对应的 Protocol 在下面会一一介绍。</p><p>为什么 clock port 没有什么生成呢？我猜测可能是其实际运行时背后已经包含了 <code>ap_clk</code> 和 <code>ap_rsn</code> ，后面图中的波形图里也可以看到。</p><p><img src="../../../post-images/Pasted%20image%2020240106211153.jpeg" alt=""></p><h2 id="a-block-level-interface-protocol">a. Block-level Interface Protocol</h2><p>这类 Protocol 只会作用于函数和函数的返回值。在 mode 设置上，常用 <code>ap_ctrl_hs</code> (handshake) ，其包含了一组控制和状态信号。但有时候没有必要查看其状态，此时便可设置为 <code>ap_ctrl_none</code>。</p><p><img src="../../../post-images/Pasted%20image%2020240106211207.jpeg" alt=""></p><p>显而易见，不再赘述</p><p><img src="../../../post-images/Pasted%20image%2020240106211214.jpeg" alt=""></p><p>从下图可以很直观地看到几个信号之间的变化关系。</p><p><img src="../../../post-images/Pasted%20image%2020240106211221.png" alt=""></p><h2 id="b-port-level-interface">b. Port-level Interface</h2><p>对于函数形参，pass-by-value 类型只会有一个方向，对应生成的也只有一个 Port，默认为 <code>ap_none</code> 类型。而 pass-by-pointer 则既是 input 也是 output，默认会生成三个 port（包含一个 valid 信号），默认是 <code>ap_ovld</code> 类型。</p><p><code>ap_none</code> 只针对于输入是 scalar ,<code>ap_stable</code> 只作用于 configuration inputs，只有当设备处在 reset mode 时才会发生改变。<br><img src="../../../post-images/Pasted%20image%2020240106211228.jpeg" alt=""><br>只有 argument 为指针或者引用时（ in-out 模式）才会使用 <code>ap_ovld</code> mode，当 in-out 被拆分为 input 和 output 时 input port 会被设置为 <code>ap_none</code> mode，而 output 会被设置为 <code>ap_vld</code> mode。<br><img src="../../../post-images/Pasted%20image%2020240106211235.png" alt=""><br>Directive 修改有三种选择，从下图可以看到 <code>ap_hs</code> 其实是最复杂的，包含了 <code>ap_vld</code> 和 <code>ap_ack</code> 两种，后者是一个应答信号，并且分为了 in 和 out。<br><img src="../../../post-images/Pasted%20image%2020240106211243.jpeg" alt=""></p><p>以上所有总结如下图</p><p><img src="../../../post-images/Pasted%20image%2020240106211250.png" alt=""></p><h1 id="2-summary">2. Summary</h1><p>简单总结下，Block Level Protocol 包括三类。而 Port Level Protocol 主要分为 Scalar 和 Pointer &amp; Reference 以及 Return 三种，其中 Scalar 和 Return 都只有一类，而 Pointer &amp; Reference 可以分成 In，out 以及 In/Out 三种，这三种分别对应不同的 Protocol。从下图中可以看到，对于 Input 而言默认均为 <code>ap_none</code> 类型，而对于 Output 而言默认则都是 <code>ap_vld</code>  类型，只有 In/Out 默认才是 <code>ap_ovld</code> 类型(额外记住这个&quot;o&quot;即可，代表 output)。</p><p><img src="../../../post-images/Pasted%20image%2020240106211257.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartus RTL Analyzer 使用笔记</title>
      <link href="/posts/FPGA/20240218-Quartus-RTL-Analyzer.html"/>
      <url>/posts/FPGA/20240218-Quartus-RTL-Analyzer.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博客中图片截取自参考链接 1 和 2 中官方视频，二个视频有许多共同之处，对比参考。</p><p>参考链接 3 给出了官方文档中相关说明</p></blockquote><h2 id="0-advantages-of-the-enable-early-design-analysis">0. Advantages of the Enable Early Design Analysis</h2><p>RTL Analyzer 工具可以看做是 Early Design Analysis，作为 Quartus 独有的功能，有如下几个优点或者说必要（来自官方说明）：</p><ul><li>第一点，方便在工程编译初期总览全局，随着工程变得越来越大，越早发现问题就越能节约成本。虽然此时的 Analysis 还不能反应总体的 Placement，但也是综合之后的结果。</li><li>第二点，运行完这步后 Quartus 会生成 report 来反应 design 中的问题，比如某些接口连接问题或者逻辑判断不完备等，常见的几种类型后面会有介绍；</li><li>第三点，交叉交互即后面的 Cross Probing，使用该工具可以在多个不同 viewer 下进行相应 module 的跳转，只需右击 Locate Node -&gt; RTL Analyzer 即可，这点当进行交互分析时非常地方便；</li></ul><p><img src="../../../post-images/image-20240219200428767.png" alt="image-20240219200428767"></p><h2 id="1-rtl-analyzer-compilation-dashboard-quick-description">1. RTL Analyzer - Compilation Dashboard quick description</h2><p>RTL Analyzer 这部分功能是在 Compilation 的第二步 Analysis &amp; Synthesis，其中第二条 Analysis &amp; Elaboration 中可以看到四个图标，如下图所示。其中前两个作用不大，重点是第三个 Constrint 以及 Swept。简单来说就是 Constrained 下仍然可以看到所有的 netlist，其中有问题或者即将被优化的部分会以黄色显示，而在 Swept 部分则仅显示综合器认为正确部分，去掉了 Constrained viewer 中显示黄色部分。另外 Constrained Viewer 中有个很重要的部分是 Swept hints，以上部分后面会详细展开说。</p><p>从开始编译到运行结束 Analysis &amp; Synthesis 一般只需要 10 分钟左右，因此可以借助 RTL Analyzer 工具快速排除或者定位设计中的一些问题，减少时间成本。</p><p><img src="../../../post-images/image-20240218214441460.png" alt="image-20240218214441460"></p><p>下图为 RTL Analyzer GUI 结构，主要看左侧的 Hierarchy 以及中间的 Schematic viewer。<br><img src="../../../post-images/image-20240219214310646.png" alt="image-20240219214310646"></p><p>下面来看下 features，从上图 3 或 4 任意一个打开进入 RTL Analysis，便可以看到下图中所示界面。可以自己手动点击中间图查找，或从左侧可以展开看到所有层级 modules 以及相关的 ports 和 nets，一般点击一下中间图会自动跳转到该 module 位置，也可以从右侧 Find 索引到目标的 modules 以及其相应的层级等。以上三种方法均可，并且在以上三种方法基础上，右击选中部分点击 Locate Node 下 Code 便可以跳转到该 module 对应的代码行，非常的方便。</p><p><img src="../../../post-images/image-20240218214003891.png" alt="image-20240218214003891"></p><h2 id="2-rtl-analyzer-features-and-sweep-hints-viewer-application">2. RTL Analyzer features and Sweep Hints Viewer application</h2><p>接下来看下 Constrained 下的 Swept hints 功能的使用。这些 Swept hints 其实就是在 Synthesis 过程中发现的 design 中的一些问题，有二种方式可以打开进入到这个 Viewer。第一种如下图所示，点击 RTL Analyzer 任务栏的 Tools-&gt;View Sweep Hints，便可以直接进入查看。</p><p><img src="../../../post-images/image-20240219214934547.png" alt="image-20240219214934547"></p><p>第二种是直接右击 Schematic 图中黄色高亮的 module 或者 port，选择 View Sweep Hints。如下图所示</p><img src="../../../post-images/image-20240219215253508.png" alt="image-20240219215253508" style="zoom:50%;" /><p>以上两种均可，最后会跳转到下图所示的 Viewer。可以看到有三栏功能，其中的 Root Causes 罗列了所有问题 modules 以及其下的 Object，并包括了对应的 Object Type，Root Reason（被 Swept away 的原因）和因此被 Swept away 的 Objects 数量（默认按此递减排序）。</p><p><img src="../../../post-images/image-20240219215036154.png" alt="image-20240219215036154"></p><p>当点击第三栏 Sweep Hints 时便会显示下图，可以通过 Filter 来过滤对应层级的 Sweep Hints，下方会显示对应被 Swept away 的 Objects 以及原因等，方便进行 debug。</p><p><img src="../../../post-images/image-20240220211452418.png" alt="image-20240220211452418"></p><p>根据官方文档(p28)所述，大致有一下几种类型的 Root Causes（下图中也有说明，而且结合来看）</p><ul><li><p><strong>A node stuck at constant 0 or 1 (Stuck at Constant).</strong></p><p>比如某个 module 的 input 直接置为 0 或者恒定值 1.</p></li><li><p><strong>A node behaved as a wire and was deleted.</strong></p><p>比如某个乘法器的 select wire line 连接到某个恒定值</p></li><li><p><strong>A node was modified during the sweep but it was not deleted (modified).</strong></p></li><li><p><strong>A node lost all fan-outs and it was deleted (lost fanout).</strong></p><p>当某个 module 确定为无效时，此时连接到它的其他 module 的 port 都会是 lost fan-outs 状态.</p></li><li><p><strong>A port or instance port got disconnected because the parent or child did not have a fan-out</strong></p></li></ul><p><img src="../../../post-images/image-20240218214338850.png" alt="image-20240218214338850"></p><h1 id="summary">Summary</h1><p>简单总结下，RTL Analyzer 工具主要是用来在了解综合后网表框图，并借助 Swept hints 尽可能在早期发现代码编写 bug，以及调试工程时加快找到问题所在。希望以上介绍对大家有帮助！</p><h1 id="reference">Reference</h1><ol><li><a href="https://www.intel.com/content/www/us/en/content-details/789883/enabling-early-design-analysis.html">Enabling Early Design Analysis (intel.com)</a></li><li><a href="https://www.youtube.com/watch?v=CzcTCobCC80">RTL Analyzer Demo (youtube.com)</a></li><li><a href="https://www.intel.com/programmable/technical-pdfs/qpp-ugs.pdf">Intel® Quartus® Prime Pro Edition User Guides - Combined</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> FPGA </tag>
            
            <tag> Quartus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客内容目录</title>
      <link href="/posts/uncategorized/20240208-blog-directory.html"/>
      <url>/posts/uncategorized/20240208-blog-directory.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-工程相关笔记">1. 工程相关笔记</h1><blockquote><p>FPGA 开发相关(持续更新)</p></blockquote><ul><li><a href="https://qiaoxu123.github.io/posts/FPGA/20231203-quartus-debugs-notes.html">Quartus 下 常用命令 &amp; debugs 记录（更新中）</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20231127-Vivado-debugs-notes.html">Vivado 下 常用命令 &amp; debugs 记录（更新中）</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20231201-HDL-Programming-Notes.html">VerilogHDL &amp; VHDL 重要语法记录&amp;备忘</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20231128-%20Quartus-compare-with-Vivado.html">Quartus 与 Vivado 资源对比</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240218-Quartus-RTL-Analyzer.html">Quartus RTL Analyzer 使用笔记</a></li></ul><blockquote><p>自动驾驶相关</p></blockquote><ul><li><a href="https://qiaoxu123.github.io/posts/Automotive/20191025-amazing-automotive-course.html">推荐：可能是目前最好的自动驾驶教程</a></li><li><a href="https://qiaoxu123.github.io/posts/Automotive/20191120-smooth-local-planning.html">Smooth Local Planning 实现</a></li><li><a href="https://qiaoxu123.github.io/posts/Automotive/20191127-reactive-planner.html">Reactive Planner的原理及实现</a></li><li><a href="https://qiaoxu123.github.io/posts/Automotive/20190627-scan-line-run-algorithm.html">Scan Line Run 聚簇算法原理与实现</a></li><li><a href="https://qiaoxu123.github.io/posts/Automotive/20190210-lane-changing-model-note.html">论文笔记：Lane-changing model</a></li></ul><blockquote><p>系统开发相关(大部分都时间较长或钻研较浅不再维护)</p></blockquote><p>Ceph 开发相关</p><ul><li><a href="https://qiaoxu123.github.io/posts/Ceph/20230729-Ubuntu-20-04-ceph-quincy-installation-by-source-code.html">Ubuntu 20.04 下 Ceph quincy 源码编译&amp;集群搭建</a></li><li><a href="https://qiaoxu123.github.io/posts/Ceph/20231128-Ceph%20OSD%20clear%20status%20&amp;%20rejoin%20cluster.html">Ceph OSD 清除状态 &amp; 重新加入集群</a></li><li><a href="https://qiaoxu123.github.io/posts/Ceph/20231203-cephadm-problems-and-notes.html">Cephadm 使用相关问题 &amp; 笔记</a></li><li><a href="https://qiaoxu123.github.io/posts/Ceph/20231125-Ceph%20cluster%20stop%20&amp;%20start.html">Ceph-源码编译集群正常关闭-开启</a></li><li><a href="https://qiaoxu123.github.io/posts/Ceph/20231125-Ceph-notes.html">Ceph 学习随记</a></li><li><a href="https://qiaoxu123.github.io/posts/Ceph/20231207-cephfs-metadata-destroy-recovery-test.html">CephFS 元数据破坏 &amp; 恢复测试</a></li><li><a href="">CephFS 学习记录</a></li><li><a href="https://qiaoxu123.github.io/posts/Ceph/20231126-Ceph%20Errors%20in%20compiling%20source%20code.html">Ceph 源码编译报错问题收集</a></li><li><a href="https://qiaoxu123.github.io/posts/Ceph/20231125-Ceph-cluster-debug-notes.html">Ceph-集群调试&amp;问题记录</a></li></ul><p>Unity 相关（兴趣使然）</p><ul><li><a href="https://qiaoxu123.github.io/posts/Unity/20230729-unity-learning-note-0.html">Unity 学习笔记 0 - 动机 &amp; 环境 &amp; 坐标系 &amp; 生命周期函数</a></li><li><a href="https://qiaoxu123.github.io/posts/Unity/20230811-unity-learning-note-3-movement.html">Unity 学习笔记 1 - 运动方式</a></li><li><a href="https://qiaoxu123.github.io/posts/Unity/20230812-Unity-learning-note-2-script-data-communication.html">Unity 学习笔记 2 - 脚本数据传递与事件通知</a></li></ul><p>前端相关</p><ul><li><a href="https://qiaoxu123.github.io/posts/System-development/20221103-python-restful-api-learn-practice.html">Python 实现 RESTful 服务器端学习 – 实践参考</a></li><li><a href="https://qiaoxu123.github.io/posts/System-development/20230309-vue-file-header-check.html">Vue 中文件校验功能实现</a></li></ul><p>Windows开发相关</p><ul><li><a href="https://qiaoxu123.github.io/posts/System-development/20220622-windows11-build-ceres.html">Windows 11 下编译 Ceres</a></li><li><a href="https://qiaoxu123.github.io/posts/System-development/20220622-windows-cmake-glog-error.html">Windows CMake 引用自编译 glog 库和 gflag 库报错问题</a></li></ul><p>Oment-Veins 相关</p><ul><li><a href="https://qiaoxu123.github.io/posts/Omnet-Veins/20220921-omnet++-samples-tictoc-practice.html">Omnet++ Samples 学习 1 - TicToc 练习汇总</a></li><li><a href="https://qiaoxu123.github.io/posts/Omnet-Veins/20220924-omnet++-samples-2-FIFO.html">Omnet++ Samples 学习 2 - FIFO</a></li><li><a href="https://qiaoxu123.github.io/posts/Omnet-Veins/20220918-veins-analoguemodels.html">Veins Module 浅析1 – AnalogueModels 的调用逻辑</a></li><li><a href="https://qiaoxu123.github.io/posts/Omnet-Veins/20221001-veins-module-read2-connectionmanager.html">Veins Module 浅析2 – connectionManager 作用与实现</a></li><li><a href="https://qiaoxu123.github.io/posts/Omnet-Veins/20221030-veins-module-basephylayer-cca.html">Veins Module 浅析3 – BasePhyLayer 中 CCA 实现细节</a></li><li><a href="https://qiaoxu123.github.io/posts/Omnet-Veins/20221103-veins-basephylayer-initially-learn.html">Veins Module 浅析4 – BasePhyLayer 外部报文处理逻辑简析</a></li><li><a href="https://qiaoxu123.github.io/posts/Omnet-Veins/20220918-veins-omnet-simsignal-management.html">结合 Veins 来看 Omnet 的 Signal 机制</a></li></ul><p>嵌入式相关</p><ul><li><a href="https://qiaoxu123.github.io/posts/System-development/20190806-ubuntu18-ros-protobuf-shared-memory-communication.html">Ubuntu18下 ROS 使用 Protobuf 共享内存实现节点通信</a></li><li><a href="https://qiaoxu123.github.io/posts/System-development/20191127-ros-protobuf-template-insights.html">个人在 ROS 工程使用Protobuf的模板和一点心得</a></li><li><a href="https://qiaoxu123.github.io/posts/System-development/20180324-ARM-linux-socketCAN-driver-compilation-note.html">ARM Linux SocketCAN驱动编译记录</a></li><li><a href="https://qiaoxu123.github.io/posts/System-development/20190314-ARM-board-autostart.html">ARM 开发板开机自启</a></li></ul><p>软件无线电相关</p><ul><li><a href="https://qiaoxu123.github.io/posts/System-development/20180206-gr-analysis-installation-error-fix.html">gr-analysis 安装问题解决</a></li><li><a href="https://qiaoxu123.github.io/posts/System-development/20180221-install-gnuradio-with-pybombs.html">使用Pybombs安装GNURadio</a></li></ul><blockquote><p>其他(考研以及生活经验之类)</p></blockquote><p>吉大软件学院考研相关(水博文系列，自己以及师弟或者朋友总结)</p><ul><li><a href="https://qiaoxu123.github.io/posts/Others/20181231-2019-JLU-kaoyan-note.html">2019年吉林大学软件学院学硕初试专业课考题回忆</a></li><li><a href="https://qiaoxu123.github.io/posts/Others/20171225-2018-JLU-kaoyan-note-1.html">2018年吉林大学软件工程979学硕初试题目回忆版</a></li><li><a href="https://qiaoxu123.github.io/posts/Others/20180324-2018-JLU-kaoyan-note-2.html">2018年吉林大学软件学院软件工程学硕复试笔试题回忆</a></li><li><a href="https://qiaoxu123.github.io/posts/Others/20180324-2018-JLU-kaoyan-note-3.html">2018年吉林大学软件学院软件工程学硕复试回忆</a></li><li><a href="https://qiaoxu123.github.io/posts/Others/20181220-2018-JLU-kaoyan-note-4.html">2018年吉林大学软件学院软件工程专硕复试题目回忆</a></li><li><a href="https://qiaoxu123.github.io/posts/Others/20170302-2017-JLU-kaoyan.html">2017年吉林大学软件学院学硕高级程序设计复试题回忆</a></li></ul><p>生活经验相关</p><ul><li><a href="https://qiaoxu123.github.io/posts/Others/20231204-mac-power-error-fix.html">Mac电量耗尽关机后时间错误–三种解决方法</a></li></ul><h1 id="2-学习笔记">2. 学习笔记</h1><blockquote><p>FPGA 相关</p></blockquote><p>《中国大学MOOC – 硬件加速设计方法》系列</p><ul><li><a href="">硬件加速设计方法 - 学习笔记（第一章 ）</a></li><li><a href="">硬件加速设计方法 - 学习笔记（第二章 - 高质量 VerilogHDL 编写方法）</a></li></ul><p>《从电路设计的角度入门 VerilogHDL》</p><ul><li><a href="https://qiaoxu123.github.io/posts/FPGA/20231210-fpga-learning-notes.html">从电路设计的角度入门 VerilogHDL - 学习笔记</a></li></ul><p>《使用 Vivado HLS 加速 FPGA 算法开发》</p><ul><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240130-FPGA-Architecture-Overview-for-Software-Engineer.html">P0 - FPGA Architecture Overview for Software Engineer</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240131-The-Principle-of-Vivado-HLS.html">P1 - The Principle of Vivado HLS</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240131-Vivado-HLS-Design-Flow-1-Conceptual-Overview.html">P2 - Vivado HLS Design Flow(1): Conceptual Overview</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240131-Vivado-HLS-Design-Flow-2.html">P3- Vivado HLS Design Flow(2) - Demo</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240201-Data-type-Arbitrary-Precision.html">P4 - Data Type - Arbitrary Precision</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240201-Data-Type-Type-Conversion.html">P5 - Data Type - Type Conversion</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240205-Composite-Data-Type.html">P6 - Composite Data Type</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240206-C++-Basic-Operator.html">P7 - C++ Basic Operator</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240207-Write-Efficient-C-Test-Bench-1.html">P8 - Write Efficient C Test Bench(1)</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240207-Write-Efficient-C-Test-Bench-2.html">P9 - Write Efficient C Test Bench(2)</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240208-Write-Efficient-C-Test-Bench-3.html">P10 - Write Efficient C Test Bench(3)</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240227-Basic-Introduction-of-Interface-synthesis.html">P11 - Basic Introduction of Interface Synthesis</a></li><li><a href="https://qiaoxu123.github.io/posts/FPGA/20240229-Implementing-Arrays-as-RTL-Interfaces.html">P12 - Implementing Arrays as RTL Interfaces</a></li><li><a href="">P13 - Interface Synthesis - Other Cases</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P10 - Write Efficient C Test Bench(3)</title>
      <link href="/posts/FPGA/20240208-Write-Efficient-C-Test-Bench-3.html"/>
      <url>/posts/FPGA/20240208-Write-Efficient-C-Test-Bench-3.html</url>
      
        <content type="html"><![CDATA[<p>主要讲了很基础的 C++ Cout 输出数据格式控制，如输出不同类型数据，精度以及输出字符串等。</p><p>提到了两种数据的比较形式，毕竟浮点数比较情况居多，满足一定精度就好。</p><h1 id="1-comparison">1. Comparison</h1><p><img src="../../../post-images/Pasted%20image%2020240106205358.jpeg" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240106205406.jpeg" alt=""></p><h1 id="2-output">2. Output</h1><p><img src="../../../post-images/Pasted%20image%2020240106205416.jpeg" alt=""></p><p>几种常用的对 cout 输出进行调整的方式</p><ul><li><p><code>setw</code> 是用来设置字段宽度的，可以用来控制输出的字符数，不足的部分会用空格填充。</p></li><li><p><code>left</code> 和 <code>right</code> 是用来设置输出的对齐方式的。<code>left</code> 表示左对齐，<code>right</code> 表示右对齐。</p></li><li><p><code>internal</code> 是用来设置输出的对齐方式的，表示在字段宽度内部对齐，即<strong>在字段宽度内部填充空格，使得输出内容居中</strong>。</p></li></ul><p><img src="../../../post-images/Pasted%20image%2020240106205423.jpeg" alt=""></p><p>Integer 数据的进制显示，包含特定头文件之后加对应关键字控制下显示即可。</p><p><img src="../../../post-images/Pasted%20image%2020240106205433.jpeg" alt=""></p><p>定点数数据类型显示，此时小数点的位置是固定的。</p><p><img src="../../../post-images/Pasted%20image%2020240106205441.jpeg" alt=""></p><p>浮点数类型显示，需要控制下小数点位数以及使用科学计数法显示。</p><p><img src="../../../post-images/Pasted%20image%2020240106205451.jpeg" alt=""></p><h1 id="2-summary">2. Summary</h1><p>总结：一般用 <code>to_string()</code> 显示更方便高效</p><p><img src="../../../post-images/Pasted%20image%2020240106205457.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P9 - Write Efficient C Test Bench(2)</title>
      <link href="/posts/FPGA/20240207-Write-Efficient-C-Test-Bench-2.html"/>
      <url>/posts/FPGA/20240207-Write-Efficient-C-Test-Bench-2.html</url>
      
        <content type="html"><![CDATA[<p>在本节中主要使用 External File 的方式来保存待测试数据，其它步骤并没有什么不同。</p><h1 id="1-stimulus">1. Stimulus</h1><p>Stimulus 的三种形式，其中 Array 和 External File 适用于数据量大的情况。</p><p><img src="../../../post-images/Pasted%20image%2020240106204054.jpeg" alt=""></p><h2 id="a-array">a. Array</h2><p><img src="../../../post-images/Pasted%20image%2020240106204103.jpeg" alt=""></p><h2 id="b-external-files">b. External Files</h2><p><img src="../../../post-images/Pasted%20image%2020240106204111.jpeg" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240106204118.jpeg" alt=""></p><p>C 编程中常用的 fstream 文件读取形式，这里建议是将 data source file 直接作为工程中 test bench files 来使用，避免路径变动导致文件不可用。</p><p>需要注意的是，代码中的 val 不能被定义为 Vivado 所支持的 <code>ap_int&lt;8&gt;</code>，因为实测会报错，所以这里先定义为 <code>int</code> 类型进行数据读取之后，再进行 type conversion 赋值。</p><p><img src="../../../post-images/Pasted%20image%2020240106204125.jpeg" alt=""></p><p>可以编写成 Template 形式方便进行各种类型数据的读取，将其作为头文件。</p><p><img src="../../../post-images/Pasted%20image%2020240106204131.jpeg" alt=""></p><h1 id="2-summary">2. Summary</h1><p><img src="../../../post-images/Pasted%20image%2020240106204149.jpeg" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240106204139.png" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240106204201.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P8 - Write Efficient C Test Bench(1)</title>
      <link href="/posts/FPGA/20240207-Write-Efficient-C-Test-Bench-1.html"/>
      <url>/posts/FPGA/20240207-Write-Efficient-C-Test-Bench-1.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-introduction">1. Introduction</h1><p><img src="../../../post-images/Pasted%20image%2020240103215744.jpeg" alt=""></p><p>相比 RTL 而言 C test bench 写起来更快，效率更高。并且可以直接转换为 RTL 的 Testbench 方便生成 <code>.v</code> 文件后进行进一步的验证。</p><p>建议是使用一个独立的 <code>_tb.c</code> 文件来组织 Test Bench 不要和 top-level function 混在一起。</p><p><img src="../../../post-images/Pasted%20image%2020240103215757.jpeg" alt=""></p><p>main() 函数的返回值必须设置为 0（表示结果正确）和非 0 值两种（结果不正确）<br><img src="../../../post-images/Pasted%20image%2020240103220547.jpeg" alt=""></p><h1 id="2-test-bench-architecture-in-c">2. Test Bench Architecture in C++</h1><p>包含如下这几个部分，每个部分具体功能后面有介绍。</p><p><img src="../../../post-images/Pasted%20image%2020240103220557.png" alt=""></p><p>参与 Test Bench 的数据可能来自或者生成到 Exteranl file（数据量比较大时候），当包括这部分功能时需要调用相关的库文件来实现外部文件的读取和写入。具体后面一节可能会讲到。</p><p><img src="../../../post-images/Pasted%20image%2020240103220604.jpeg" alt=""></p><h1 id="3-summary">3. Summary</h1><p><img src="../../../post-images/Pasted%20image%2020240103220610.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P7 - C++ Basic Operator</title>
      <link href="/posts/FPGA/20240206-C++-Basic-Operator.html"/>
      <url>/posts/FPGA/20240206-C++-Basic-Operator.html</url>
      
        <content type="html"><![CDATA[<p>这节课主要是关于 C++ 基本运算在 HLS 中的注意事项，C++ 基本运算的语法并不是可以直接完全在 HLS 中应用的。仔细想也能理解，在软件编程中 C++ 特性的易用和高效有很大一部分原因要归功于编译器。而在 HLS 中并没有那么高级的优化处理，因此在编写时需要遵循一些规则。</p><h1 id="1-operators">1. Operators</h1><p>当我们进行定点数的算术运算时，需要注意位宽的处理。遵循的原则是：<strong>大数据不溢出，小数据不损失</strong>。<br><img src="../../../post-images/Pasted%20image%2020240104202852.jpeg" alt=""></p><p>没有什么特别的，支持缩写形式</p><p><img src="../../../post-images/Pasted%20image%2020240104202859.jpeg" alt=""></p><p>在 Vivado HLS 中，当进行算术运算时，一定要保证运算符两侧的类型是一致的，<strong>如果存在不一致一定要手动进行数据类型的转换</strong>。因为 Vivado HLS 不支持自动类型转换，不然会报如下错误<br><img src="../../../post-images/Pasted%20image%2020240104202921.jpeg" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240104204922.jpeg" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240104202928.jpeg" alt=""></p><p>对于逻辑运算返回的结果是 True or False，而对于位运算，返回值和操作数的宽度有关系。<br><img src="../../../post-images/Pasted%20image%2020240104202941.jpeg" alt=""></p><h1 id="2-case-analysis">2. Case Analysis</h1><p>这部分主要想让我们明白，使用 HLS 加速算法时需要对算法理解到位，关键部分使用什么资源要做到心里有数，以及实现上根据 HLS 特性做相应的调整。</p><h2 id="a-complex-multiplier">a. Complex Multiplier</h2><p>如下实例所示，声明并使用了 complex 这个 library 来实现复数运算。可以看到正常的实现形式会消耗 4 个 multipliers 和 2 个 adders<img src="../../../post-images/Pasted%20image%2020240104202951.jpeg" alt=""></p><p>对公式进行变换，减少了 multiply 的使用，修改后同样的运算变成只使用 3 个加法器<br><img src="../../../post-images/Pasted%20image%2020240104202958.jpeg" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240104203005.jpeg" alt=""></p><h2 id="b-euclidean-algorithm">b. Euclidean Algorithm</h2><p>计算最大公约数的算法（主要是取余运算）<br><img src="../../../post-images/Pasted%20image%2020240104203011.jpeg" alt=""></p><p>这里采用循环方式来实现</p><p><img src="../../../post-images/Pasted%20image%2020240104203017.jpeg" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240104203024.jpeg" alt=""></p><p>Vivado HLS 不支持递归，提示的报错信息如下所示<br><img src="../../../post-images/Pasted%20image%2020240104203030.jpeg" alt=""></p><h1 id="3-summary">3. Summary</h1><p><img src="../../../post-images/Pasted%20image%2020240104203035.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P6 - Composite Data Type</title>
      <link href="/posts/FPGA/20240205-Composite-Data-Type.html"/>
      <url>/posts/FPGA/20240205-Composite-Data-Type.html</url>
      
        <content type="html"><![CDATA[<p>HLS 支持的复合数据类型包括两种：Struct 和 Enumeration。</p><h1 id="1-struct">1. Struct</h1><p>如果 top-level functions 的参数是 Arrays，最终会被转译为 memory ports。<br>和 C/C++ 编程相同，建议是将 struct 定义在 header 文件中方便引用。<br>在 struct 中使用的 elements 最终会被 packed into a single vector（类似 C 中顺序排列组成的内存块），有两种形式：field_level 和 struct_level。<br><img src="../../../post-images/Pasted%20image%2020240106151519.jpeg" alt=""><br>示例如何规范定义和使用 struct<br>这里 sizeof(data_t) 大小为 5 的原因是，A 是 ap_int&lt;4&gt; 宽度为 4bits，占用一个 1 byte；同样 B 为 ap_uint&lt;4&gt; 数组会占用 4 byte，总共是 5 byte。<br><img src="../../../post-images/Pasted%20image%2020240106151533.jpeg" alt=""><br>对于 struct 类型对应的 Directive 叫作 DATA_PACK，下方选择目标的 byte_pad 形式（上面提到的两种)。<br><img src="../../../post-images/Pasted%20image%2020240106151545.jpeg" alt=""></p><h2 id="a-byte-pad-field-level">a. Byte Pad: field_level</h2><p>field_level 模式下，struct 中每个 elements 都需要扩展到 8 bit 倍数。<br>上图示例中由于每个元素都是 4 bits 所有最后都扩展为了 8 bits，最后总大小为 5x8=40 bits。<br><img src="../../../post-images/Pasted%20image%2020240106151556.jpeg" alt=""></p><h2 id="b-byte-pad-struct-level">b. Byte Pad: struct_level</h2><p>另一个是 struct_level，每个元素的实际位宽保留，要求 packed 后的 single vector 总的 bits 是 8 的倍数。<br>上图示例中原先大小为 20bits，packed 后大小变为 24bits。<br><img src="../../../post-images/Pasted%20image%2020240106151613.jpeg" alt=""><br>从下图资源利用率，Interval 以及 latency 等来看，两种形式没有明显差别，并且都使系统的吞吐率提高了。<br>这种 Data Pack Mode 相当于把 for-loop 展开<br><img src="../../../post-images/Pasted%20image%2020240106151637.jpeg" alt=""><br>在仿真时为了便于查看，可以将我们创建的 struct 中的元素，按照其实际的位宽拿出来，创建 virtual bus 便于查看。<br><img src="../../../post-images/Pasted%20image%2020240106151645.jpeg" alt=""></p><h1 id="2-enumerated-type">2. Enumerated Type</h1><p>所谓枚举类型，就是把需要的数值定义为符号常量便于使用，其中的元素会按照顺序被自动分配一个整数。<br><img src="../../../post-images/Pasted%20image%2020240106151658.jpeg" alt=""><br>通过枚举类型提高了代码的可读性<br><img src="../../../post-images/Pasted%20image%2020240106151708.jpeg" alt=""><br>如上图中代码所示，当定义的 enum 类型作为 function arguments 使用时，HLS 会自动推断该类型的 data width，其默认是 int 类型。<br><img src="../../../post-images/Pasted%20image%2020240106151715.png" alt=""></p><h1 id="3-summary">3. Summary</h1><p><img src="../../../post-images/Pasted%20image%2020240106151724.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P5 - Data Type - Type Conversion</title>
      <link href="/posts/FPGA/20240201-Data-Type-Type-Conversion.html"/>
      <url>/posts/FPGA/20240201-Data-Type-Type-Conversion.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-variable-definition-and-initialization">1. Variable Definition and Initialization</h1><p>目前 Vivado HLS 支持 copy initialization，direct initialization 以及指定 radix format（2 进制，10 进制和 16 进制）的初始化,不支持 uniform initialization（如下图中代码第四行描述的那种初始化方式）。下面是对任意精度类型进行初始化<br><img src="../../../post-images/Pasted%20image%2020240106160827.jpeg" alt="1075"><br>Q 表明了量化模式（Quantization Mode），O 表示 Overflow 溢出模式（Overflow mode)针对高位。</p><p>示例 1.25 用二进制表示为 0101，小数点在中间。其中的 0.25 用二进制表示为 0.01，这是因为在二进制表示中，小数点的右边是 0 乘以 2 的负几次方，0.01 的话就是 0 乘以 2 的负二次方也就是 1/4 = 0.25。<br>对于 var2，采用 AP_RND 的量化模式，相当于进位了，所以是 1.5<br>对于 var3，由于是只取 4 位因此是 0011 大小为 3，而 var4 设置为 AP_SAT 模式后取了 4 位有效位宽有符号数的最大值也就是 7。<br><img src="../../../post-images/Pasted%20image%2020240106160807.jpeg" alt=""></p><h1 id="2-浮点类型处理">2. 浮点类型处理</h1><p>The Vivado HLS Math library (hls_math.h) provides extensive support for the synthesis of the standard C(math.h) and C++(cmath.h) libraries.<br>The support includes floating point and fixed-point functions.</p><h2 id="a-implicit-type-conversion：numeric-promotion">a. Implicit Type Conversion：Numeric Promotion</h2><p>隐式数据类型转换。如下图所示有两种形式，一种是 Numeric promotion，另一种是 Numeric conversion。之所以称为隐式是因为不需要在代码中显式地指定，编译器会根据需要自动进行。<br>Numeric Promotion 在编程中指的是将较低精度的数据类型在表达式中提升为较高精度的数据类型的过程。<br><img src="../../../post-images/Pasted%20image%2020240106160931.jpeg" alt=""><br>这里有符号数赋值给无符号数时，会发生符号位扩展，以保证数值的相对大小不变。如上图中的示例，-4 有符号数（以补码表示是 252)将其赋值给 res 这个无符号数时，符号扩展后数值就是 252。</p><h2 id="b-implicit-type-conversion：-numeric-conversion">b. Implicit Type conversion： Numeric Conversion</h2><p>如下图中所描述的，将一个大数据类型转换为小数据类型。<br><img src="../../../post-images/Pasted%20image%2020240106160956.jpeg" alt=""><br>当把 v5 赋值给 res2 时，由于只取了低两位即 11，因此表示的数值大小就是 -1。对于 v6 的赋值也是如此<br>当把 v1 赋值给 v3 时，采用了 AP_RND 量化模式，因此变为了 1.5。</p><h2 id="c-explicit-type-conversion-casting-：c-style">c. Explicit Type Conversion（casting）：C-Style</h2><p><img src="../../../post-images/Pasted%20image%2020240106161010.jpeg" alt=""><br>对应算术运算的位宽处理方式<br><img src="../../../post-images/Pasted%20image%2020240106161027.jpeg" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240106161037.png" alt=""></p><h1 id="3-summary">3. Summary</h1><p><img src="../../../post-images/Pasted%20image%2020240106161047.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P4 - Data Type - Arbitrary Precision</title>
      <link href="/posts/FPGA/20240201-Data-type-Arbitrary-Precision.html"/>
      <url>/posts/FPGA/20240201-Data-type-Arbitrary-Precision.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-c-based-data-types">1. C-based Data Types</h1><p>为了避免 C 语言中固定数据类型长度带来的资源浪费，提供了任意精度数据类型的描述。首先来看下传统的 C 语言所支持的数据类型，需要注意的是对于 Vivado HLS 而言 Char 类型是不支持的。</p><p><img src="../../../post-images/Pasted%20image%2020240118215511.png" alt=""></p><p>传统的 C 语言的数据类型，受限于冯若依曼架构设计以及编译器等，都是以 8 为单位。这样的数据宽度在 FPGA 硬件设计上是难以接受的，一是 FPGA 本身是支持任意宽度的，二是为了满足这样的位宽，很容易导致资源浪费。比如设计一个 18x18 的乘法器，在 综合时为了满足要求只能使用 32x32 的硬件资源来实现，导致直接浪费掉了 4 个 DSP48E1 在 7 系列 FPGA 上。<br><img src="../../../post-images/Pasted%20image%2020240118215522.png" alt=""></p><h1 id="2-arbitrary-precision-data-types">2. Arbitrary Precision Data Types</h1><p>W 的取值范围可以是 1~1024，注意使用 ap_int 类型时要包括头文件。</p><p>HLS 也支持 System C 的任意精度类型，感兴趣参考下图中提示的文件<br><img src="../../../post-images/Pasted%20image%2020240118215528.png" alt=""></p><p>修改为任意精度的数据类型后可以使用更少的资源，获得更高的时钟频率以及更低的时延,并且 ap_int 支持基本所有的 C int 的运算。</p><p><img src="../../../post-images/Pasted%20image%2020240118215535.png" alt=""></p><p>将数据类型定义在头文件中方便后期 Debug</p><p><img src="../../../post-images/Pasted%20image%2020240118215540.png" alt=""></p><h1 id="3-sizeof">3. Sizeof()</h1><p>获取数据类型占用了几个 Bytes<br><img src="../../../post-images/Pasted%20image%2020240118215547.png" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240118215552.png" alt=""></p><h1 id="4-used-in-microsoft-vs">4. Used in Microsoft VS</h1><p><img src="../../../post-images/Pasted%20image%2020240118215557.png" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240118215603.png" alt=""></p><h1 id="5-summary">5. Summary</h1><p><img src="../../../post-images/Pasted%20image%2020240118215609.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P1 - The Principle of Vivado HLS</title>
      <link href="/posts/FPGA/20240131-The-Principle-of-Vivado-HLS.html"/>
      <url>/posts/FPGA/20240131-The-Principle-of-Vivado-HLS.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-history-of-esl">1. History of ESL</h1><p>从 EDA 到 ESL，设计变得越来越方便也越来越抽象。如下图框中文字所说的，适当的抽象增加对系统的理解，开发功能的效率也会有一定提升。</p><p>Xilinx 有两种形式支持抽象开发：HLS 和 System Generator。前者使用高级语言如 C/C++，后者则是使用模型设计工具。</p><p><img src="../../../post-images/Pasted%20image%2020240113153545.png" alt=""></p><h1 id="2-high-level-synthesis-benefits">2. High-level Synthesis Benefits</h1><p>对于硬件工程师而言，采用 VHDL/VerilogHDL 语言进行开发，主要精力都会放在实现并行性和时序设计上。就比如汇编语言开发时，大部分精力都会放在寻址和访存上。而在进行算法功能模块开发时，更倾向于将精力放在算法设计，优化和验证上，底层并行实现和时序设计更希望能有相应的工具来对应完成。因此，对于 hardware designers 而言 HLS 可以减少功能模块实现所占用的精力，提高生产力，同样，对于 software designers 而言将算法模块使用 FPGA 实现可以提升运行效率（三个方面：并行性、吞吐率、功耗）。</p><p>第 4 条需要注意的是，HLS 中是使用 C/C++ 编写程序的同时，也需要使用 C/C++ 编写相应的测试脚本。这主要是因为 HLS 生成的 RTL 程序可读性很差，因此我们只能是在 C/C++ 层面进行优化调整，同时编写激励进行测试验证。</p><p>第 5 条是 HLS 开发的重点，根据需要调整 optimization directives。简单理解就是，HLS 将 C/C++ 编写的程序生成 RTL 之后，会有很多地方需要进行调整优化，如 for 循环调整为并行或者 Pipeline 。这也需要 HLS 设计者对 FPGA 开发也有一定的功底。</p><p><img src="../../../post-images/Pasted%20image%2020240113153555.png" alt=""></p><h1 id="3-phases-of-high-level-synthesis-in-vivado-hls">3. Phases of High-level Synthesis in Vivado HLS</h1><p>转换过程分为两个阶段：Scheduling/Control Logic Extraction、Binding<br><img src="../../../post-images/Pasted%20image%2020240113153636.png" alt=""></p><p>Scheduling/Control Logic Extraction 完成的是每个时钟周期该做什么样的工作，以及用几个时钟周期来完成，一些操作是否可以并行来执行。控制逻辑的提取通常会生成一个状态机。</p><p>Binding 负责管理<font color="#fac08f">每个操作需要用什么样的资源去实现</font>，完成这种映射。</p><p>Vivado HLS 实际上是通过 FSM 去控制算法或者程序的状态变化。</p><h2 id="a-scheduling-and-bind-example">a. Scheduling and Bind Example</h2><p>下图示例比较简单，编写的代码在右侧分别执行了 Scheduling 和 Binding，乘法最后映射为了 DPS48。</p><p>注意，<code>foo</code> 函数执行的操作只用一个控制状态 C0，而并不是说其只使用了一个时钟周期。另外从 Operation 中可以看到对于变量执行的操作以及变量的读写状态（read/write）。</p><p><img src="../../../post-images/Pasted%20image%2020240113153644.png" alt=""></p><h2 id="b-control-logic-extraction-example">b. Control Logic Extraction Example</h2><p>对于循环，一般需要多个状态，形成一个有限状态机，下图示例使用了 4 个状态，需要注意的是，HLS 的控制状态和最后生成的 RTL FSM 状态并不是一一对应的，只是二者之间有紧密的关系。</p><p><img src="../../../post-images/Pasted%20image%2020240113153653.png" alt=""></p><p>数组按位相加的示例（左侧流程图最后一步写错了，应该是 <code>Write C[i][j]</code>）。由算法流程图可以很清晰地推断出 HLS 生成状态的变化，辅助我们进行理解和优化。</p><p>另外可以看到 for 循环 有一个 row 和 col 关键字或标记，这种语法是 HLS 支持的，课程后面会提到其作用。<img src="../../../post-images/Pasted%20image%2020240113153700.png" alt=""></p><h1 id="4-summary">4. Summary</h1><p>注意 control states 只是为了 schedule operations into clock cycles，和 RTL FSM 的 final states 没有一一对应关系，只是关系很紧密。</p><p><img src="../../../post-images/Pasted%20image%2020240113153707.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P2 - Vivado HLS Design Flow(1) - Conceptual Overview</title>
      <link href="/posts/FPGA/20240131-Vivado-HLS-Design-Flow-1-Conceptual-Overview.html"/>
      <url>/posts/FPGA/20240131-Vivado-HLS-Design-Flow-1-Conceptual-Overview.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-deisgn-flow-traditional-vs-high-level">1. Deisgn Flow - Traditional vs High-level</h1><p>下图描述的是典型的 RTL 开发流程图，和灰色箭头一起形成了每个部分以及整个系统调试的闭环。大致可以分成三部分：</p><p>第一部分：使用硬件描述语言进行功能设计和开发，并编写测试激励，通过仿真进行功能验证；</p><p>第二部分：Synthesis 和 Implementation，在这一阶段实现设计的收敛，从 Latency、Timing 和 Resource 三个角度考察；</p><p>第三部分：系统级的测试验证（上板验证）；</p><p>以上三个部分均需要反复迭代，保证各个部分满足要求后才能达到最终想要的方案。</p><p><img src="../../../post-images/Pasted%20image%2020240114093230.png" alt="1075"></p><p>当 HLS 参与之后，我们就可以站在更高和更抽象的层次来开发和调试工程，C Synthesis 实现将 C/C++ 代码和 TestBench 转换为 RTL，注意在这一步时就需要考虑到 Latency、Timing 以及 Resource。后续的流程便与传统的 RTL 开发没有区别了。</p><p><img src="../../../post-images/Pasted%20image%2020240114093238.png" alt="1075"></p><h1 id="2-vivado-hls-design-flow">2. Vivado HLS Design Flow</h1><p>Vivado HLS 的设计输入除了需要高级语言编写的 Source code 和 Test bench 以外，还需要 Contraints 和 Directives 用来约束收敛和优化（有相应的图形界面）。另外提供了一系列的 library 来辅助高级语言编写特定功能。</p><p>Vivado HLS 在 C Syntheis 后会生成两种版本，一种是生成 IP 直接输入给 IP Catalog 中来使用，另一种则是支持在 System Generator 中以模块化的形式来使用。<br><img src="../../../post-images/Pasted%20image%2020240114093253.png" alt="1075"></p><p>C testbench 非常重要，包含真实的结果，来和仿真的结果做对比，此外还用于自动生成 RTL Testbench。</p><p><img src="../../../post-images/Pasted%20image%2020240114093337.png" alt="1075"></p><p>具体操作可以分成如下四步，其中每一步都会单独生成一个文件夹保存生成的数据。</p><p><img src="../../../post-images/Pasted%20image%2020240114093347.png" alt="1075"></p><h1 id="3-solutions">3. Solutions</h1><p>每个工程可以创建若干个 Solutions，一般是用来测试不同的 directives 的优化效果。不同的 solution 有不同的 constraints 和 optimization directives，Directives 可以写在 source code 中，也可以写在单独的文件中，一般建议写在单独的文件中方便调试对比。<br><img src="../../../post-images/Pasted%20image%2020240114093356.png" alt="1075"></p><p><img src="../../../post-images/Pasted%20image%2020240114093404.png" alt="1075"></p><p><img src="../../../post-images/Pasted%20image%2020240114093412.png" alt="1075"></p><h1 id="4-summary">4. Summary</h1><p><img src="../../../post-images/Pasted%20image%2020240114093419.png" alt="1075"></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P3 - Vivado HLS Design Flow(2) - Demo</title>
      <link href="/posts/FPGA/20240131-Vivado-HLS-Design-Flow-2.html"/>
      <url>/posts/FPGA/20240131-Vivado-HLS-Design-Flow-2.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-vivado-hls-design-flow">1. Vivado HLS Design Flow</h1><p>最终生成的文件中大体包含如下三部分内容：IP Catalog、DCP（Design Check Point) 以及 SysGen。</p><p><img src="../../../post-images/Pasted%20image%2020240114093515.png" alt=""></p><p>对于 HLS 只允许有一个 top-level function</p><p>一般 HLS 生成的结构与 C 语言中函数的结构基本是一致的，但也有例外，<font color="#fac08f">默认情况下，如果函数内容逻辑非常简单，那么 HLS 在生成时可能会进行 Inline 处理来优化函数结构，将其提取出来不单独视为一个 function</font>。为了避免这种情况，可以通过修改 Directive 禁止这种 Inline 处理。</p><p>并不是所有的 C 语言程序都是 allowed Synthesis，当程序中出现 Dynamic memory allocation 或者其中有 Operation system operations 时程序是不能够被 Synthesis 的。前者需要编译器支持，后者需要系统库支持。<br><img src="../../../post-images/Pasted%20image%2020240114093525.png" alt=""></p><h1 id="2-directives">2. Directives</h1><p>有两种保存 Directives 设置的方式，一种是直接在源码中进行修改（下图右侧所示），另一个种是存放在单独的文件中。</p><p>这里注意，如下图所示，如果在 GUI 中这个 Directive 前面符号是<code>%</code>，那么这个 Directive 就是存放在单独的 directive 文件里面，以 <code>set_directive_xxx</code> tcl command 形式存放。如果是<code>#</code>, 说明是存放在相应的 source code 里面。<br><img src="../../../post-images/Pasted%20image%2020240114093541.png" alt=""></p><p>下面是这两种保存方式的优缺点，推荐是采用第一种即放在单独的 directive files 中，大多数情况下我们都会创建多个 solution 来进行优化性能对比，每个 solution 调取对应的 directives，这样更直观简洁。当然如果确定需要进行迁移或者分享的话，便采用第二种。</p><p><img src="../../../post-images/Pasted%20image%2020240114093619.png" alt=""></p><h1 id="3-example">3. Example</h1><p>下图展示的是一个数组加法的例子，列出了函数形参 Synthesized 后生成的接口，其他提到了 Block-level IO Handshake 这一类型，后面课程会具体展开讲。</p><p><img src="../../../post-images/Pasted%20image%2020240114093629.png" alt=""></p><h1 id="4-summary">4. Summary</h1><p>总结以下推荐的 Coding Style:</p><ol><li>为每一个 for-loop 创建一个 label 方便后期设置 directives 优化；</li><li>directive files 放在独立的文件夹中；</li><li>main() 函数结果为真的返回值应该是 0，其余为 1；</li></ol><p><img src="../../../post-images/Pasted%20image%2020240114093637.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HLS Learning P0 - FPGA Architecture Overview for Software Engineer</title>
      <link href="/posts/FPGA/20240130-FPGA-Architecture-Overview-for-Software-Engineer.html"/>
      <url>/posts/FPGA/20240130-FPGA-Architecture-Overview-for-Software-Engineer.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-orientation-and-overview-of-this-course">1. Orientation and Overview of this Course</h1><p>整个课程大纲，一共 25 节 5 章。这里补充一页来自最后一课的 Summay 方便看的更清楚<br><img src="../../../post-images/Pasted%20image%2020240113150643.png" alt=""></p><p><img src="../../../post-images/Pasted%20image%2020240128151300.png" alt=""></p><h1 id="2-introduction">2. Introduction</h1><p>FPGA 也被称为“Liquid Hardware”。从底层结构来看，FPGA、CPLD 和 SPLD 在逻辑单元的组织和连接方式上有所不同。</p><p>FPGA通常由大量的可编程逻辑单元（PLU）组成，这些逻辑单元可以配置成各种不同的逻辑功能，如逻辑门、寄存器等。FPGA还包括大量的可编程连线（Interconnect）和存储单元（如查找表或存储器单元），这些单元可以用于存储逻辑功能的配置信息。</p><p>CPLD通常由一系列可编程逻辑模块（PLM）组成，这些模块包含了逻辑门和触发器，以及连接这些模块的可编程连线。<strong>CPLD通常具有更快的时钟速度和更低的延迟，这是因为它们通常使用了静态逻辑技术，而不是动态逻辑技术</strong>。</p><p>SPLD通常由少量的逻辑门和触发器组成，通常用于实现相对简单的逻辑功能，如组合逻辑或状态机。<br><img src="../../../post-images/Pasted%20image%2020240113150651.png" alt=""></p><p>FPGA 与 GPU 谁是未来的趋势一直都争论不休，但其实和 CPU 一样，二者的架构不同各自擅长的领域也不同。</p><p>GPU的优势之一是能够同时执行多个进程，以及对大块数据进行流处理。这使得GPU在处理需要大规模并行计算的应用中表现出色，比如图形渲染、科学计算、深度学习等。</p><p>相比之下，FPGA（现场可编程门阵列）也可以执行并行计算,但其主要优势在于其灵活性和可定制性。FPGA可以根据特定的应用需求进行定制化设计（因为其总线位宽可以任意定制，因此可以定制特定位宽的数据处理，减少资源使用开销等）因此在某些特定的应用场景下，FPGA可以提供更高的性能和效率，功耗一般也更低。<br><img src="../../../post-images/Pasted%20image%2020240113150701.png" alt=""></p><h1 id="3-fpga-architecture">3. FPGA Architecture</h1><p>Xilinx 嵌入 ARM 的 FPGA 系列有：Zynq-7000 和 UltraScale+ MPSoC。左侧描述的是 FPGA 的架构，由横竖交叉的 routing 将密密麻麻的 Programmable Logic 连接起来，四周则是 Programmable I/O。右侧则是 FPGA 一般包括的资源<br><img src="../../../post-images/Pasted%20image%2020240113150714.png" alt=""></p><p>上图右侧资源中，比较陌生的几个在这简单整理下起功能</p><ul><li>XADC（Xilinx Analog-to-Digital Converter）：XADC是赛灵思（Xilinx）FPGA系列中的模拟数字转换器模块，用于将模拟信号转换为数字信号。XADC可以用于采集和处理模拟信号，例如温度传感器、电压监测等</li><li>Transceiver：Transceiver是FPGA中的高速收发器模块，通常用于支持高速串行通信协议，如PCIe、SATA、以太网等。这些模块可以实现高速数据传输，支持不同的协议和数据速率</li><li>CMT（Clock Management Tile）：CMT是赛灵思FPGA中的时钟管理模块，用于生成、分配和管理时钟信号。CMT模块可以实现时钟频率的分频、倍频、延迟等功能，以满足不同的时序要求</li></ul><p>SliceM 和 SliceL 应该是最熟悉也是最重要的两个，这里也记录下：</p><ul><li>SLICEL（Slice LUT）：SLICEL是FPGA中的<strong>逻辑单元模块</strong>，通常包括查找表（LUT）、寄存器、算术逻辑单元（ALU）等。SLICEL通常用于实现逻辑功能和算术运算，是FPGA中的基本计算单元。</li><li>SLICEM（Slice Memory）：SLICEM是FPGA中的<strong>存储单元模块</strong>，用于实现存储器和存储器相关的功能。SLICEM通常包括存储器单元、存储器控制器等，用于实现存储器的读写操作和存储器相关的逻辑功能。</li></ul><p>需要注意的是，当 LUTs 被用于组成存储器时，通常会消耗 SLICEM 而不是 SLICEL（如果组成 memory 所需的 SLICEM 不够，也不会消耗 SLICEL）。这是因为SLICEM（Slice Memory）专门用于实现存储器单元和存储器相关的功能，包括存储器单元、存储器控制器等。SLICEM通常包含更多的存储器资源和相关的控制逻辑，可以更好地支持存储器的读写操作和存储器相关的功能。相比之下，SLICEL（Slice LUT）通常用于实现逻辑功能和算术运算，包括查找表（LUT）、寄存器、算术逻辑单元（ALU）等。虽然LUT也可以用于实现存储器功能，但SLICEM更适合用于实现大规模的存储器单元和相关的存储器控制逻辑。</p><p>另外还有一个没有提及的资源是 FF（Flip-Flop) 触发器资源，每个 FF 通常包含一个存储器单元，用于存储一个比特的信息，并且具有时钟信号控制的输入端，用于在时钟信号的上升沿或下降沿触发状态的更新。是的，FF 和时序逻辑直接相关，可以理解为每个使用类似 always @(posedge clk) 都会占用一个或多个 FF 资源。这是因为时序逻辑通常需要使用触发器来存储状态信息，以响应时钟信号的边沿触发状态更新。</p><h2 id="a-logic-unit">a. Logic Unit</h2><p>Logic Unit 包括 LUT、MUX 以及 carry chain。在实现加法器时可以使用 LUT 实现（其本质也是数字逻辑组成的），也可以通过 Arithmetic-logic Unit 如 DSP48 这样的资源来实现。<br><img src="../../../post-images/Pasted%20image%2020240113150727.png" alt=""></p><h2 id="b-arithmetic-logic-unit">b. Arithmetic-logic Unit</h2><p>图中的 ALU 模块能够实现很多算术运算，在 Xilinx FPGA 中，ALU 指的是 DSP48<br><img src="../../../post-images/Pasted%20image%2020240113150752.png" alt=""></p><h2 id="c-memory-unit">c. Memory Unit</h2><p>Memory Unit 中 LUT 位于 SliceM 中，主要用来存放一些小块的数据（&lt; 1kb）。<br>Block RAM 的结构如下<br><img src="../../../post-images/Pasted%20image%2020240113150810.png" alt=""></p><p>在 T 系列的 FPGA 中，一个 Block RAM 是由两个 18Kb 组成，可以被拆分重组成如上图的几种形式。<br>另外，RAM  可以被配置成如下几种形式：</p><ul><li><strong>Single port RAM</strong>：只能通过一个端口进行读写操作</li><li><strong>Simple-dual port RAM</strong>：具有两个独立的读写端口，但读操作和写操作不能同时进行。举个例子，如果一个端口正在进行读操作，那么同一时刻另一个端口就不能进行读操作，但可以进行写操作。</li><li><strong>True-dual port RAM</strong>：具有两个完全独立的读写端口，端口彼此之间的读写操作不会影响，相比上面的 Simple-dual port RAM。这是因为在它内部的存储单元，每个都有两个独立的数据输出端口，分别连接到两个读写端口。这样，即使两个端口同时访问同一个存储单元，也不会发生冲突，因为每个端口都有自己的数据输出路径。作为代价，其需要复杂的控制逻辑来确保并发的读写操作不会相互影响，通常会使用时序控制和状态机来实现这一点。</li><li><strong>Single port ROM</strong>：只能通过一个端口进行读取操作（仅读取）</li><li><strong>Dual port ROM</strong>：具有两个独立的读写端口，可以同时进行两个独立的读取操作（仅读取）</li><li><strong>FIFO</strong>：用在两个时钟域之间进行数据传输的存储器结构，可以实现数据的先进先出的顺序。</li></ul><h1 id="4-focus">4. Focus</h1><p>在使用 C/C++ 进行开发时候，需要了解每个 function 的功能大致实现以及资源使用情况<br><img src="../../../post-images/Pasted%20image%2020240113150820.png" alt=""></p><h1 id="5-summary">5. Summary</h1><p><img src="../../../post-images/Pasted%20image%2020240113150837.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从电路设计的角度入门 VerilogHDL 学习笔记</title>
      <link href="/posts/FPGA/20231210-fpga-learning-notes.html"/>
      <url>/posts/FPGA/20231210-fpga-learning-notes.html</url>
      
        <content type="html"><![CDATA[<h1 id="main">Main</h1><blockquote><p>视频链接：<a href="https://www.bilibili.com/video/BV1PS4y1s7XW/">从电路设计的角度入门VerilogHDL_哔哩哔哩_bilibili</a></p></blockquote><h2 id="概述">概述</h2><p>VerilogHDL（HDL – Hardware Description Language）<br>高层次综合语言 – HLS、Chisel<br>VerilogHDL 设计基本流程如下<br><img src="../../../post-images/Pasted%20image%2020231210223140.jpeg" alt="|500"><br>Placement &amp; Routing 与 Synthesis/Netlist 最大的区别在于前者在板子上已经有了坐标了，而后者阶段还没有。<br>Verilog 既可以用来进行算法级设计，也可以用在底层来直接进行描述。（有点类似于 C++ 和汇编混合在一起的样子）。但可综合语句仅占 Verilog 中很小的子集，如上图粉色背景部分描述的。其中很大部分用来描述电路一般并没有掌握或者学习到（类似汇编部分）<br>务必注意数字电路设计的规模会变得越来越大，重用性和可扩展性。（原理图形式设计基本不可用）</p><h3 id="相关的-eda-工具">相关的 EDA 工具</h3><p><img src="../../../post-images/Pasted%20image%2020231210223116.jpeg" alt="|500"></p><h3 id="veriloghdl-的缺陷">VerilogHDL 的缺陷</h3><p><img src="../../../post-images/Pasted%20image%2020231210223052.jpeg" alt="|500"><br>针对这些缺陷有很多挑战者，最知名的如 HLS，Chisel 以及 SpinalHDL.</p><h2 id="编写方法">编写方法</h2><h3 id="电路设计对象">电路设计对象</h3><p><img src="../../../post-images/Pasted%20image%2020231211091255.jpeg" alt="|500"><br><strong>Reference 和 Cell</strong> ：有时候我们会把同一个电路复制几份，最原始的那个叫作 Reference，每复制一个就叫做一个 Cell，一个电路上 Cell 的数量是远远大于 Reference 的。 结合上图和下图简单理解就是，我定义了一个 ENCODER module，这是一个设计文件。之后利用它实例化了其他模块如 U1。那么这个最初的参考的设计文件就称为 Reference，而利用它实例化出来的模块就称为 Cell。</p><p>关于 Port，Pin 以及 Net，课程中所说感觉不太好理解和记忆，chatgpt 总结了下他们大致区别是：</p><ul><li><strong>Port</strong>（端口）：<font color="#fbd5b5">Port是模块（module）的接口</font>，用于与其他模块进行通信。在Verilog中，端口可以是输入（input）、输出（output）或双向（inout）。端口定义了模块与外部世界之间的通信接口。</li><li><strong>Pin</strong>（引脚）：<font color="#fbd5b5">Pin通常指的是芯片或电路板上的物理引脚</font>，用于连接到其他芯片或电路板。在Verilog中，引脚通常用于描述模块实例与电路板上的物理引脚之间的连接关系。</li><li><strong>Net</strong>（网络）：<font color="#fbd5b5">Net是连接模块内部元素的电气连接</font>。在Verilog中，net用于连接模块内部的信号线，可以是wire、reg等数据类型。net用于传输信号和数据，连接模块内部的各个元素。</li></ul><p>对应上图中描述的代码应该是这个样的<br><img src="../../../post-images/Pasted%20image%2020231210222958.jpeg" alt="|475"></p><p>综上所述，port是模块的接口，用于模块之间的通信（<code>A,B,C,D,OUT1</code>) ；pin是物理引脚，用于连接模块实例与电路板上的引脚（<code>clk</code>）；net是连接模块内部元素的电气连接（<code>INV1, INV0, bus1, bus0</code>），用于传输信号和数据（如果 module 实例化失败，则与之相关的 net signal 可能都会被 optimized away）。</p><h3 id="执行顺序">执行顺序</h3><p>在 Verilog 的 module 结构中，所有<strong>描述语句</strong>（包括连续赋值语句、行为语句块 always initial 以及模块实例化等）都是并行发生的，而 begin…end 中存在的语句是内部串行的。</p><h3 id="变量">变量</h3><ul><li><code>wire</code> 型：表示电路模块中的连线，仿真波形中不可见；</li><li><code>reg</code> 型：占用仿真环境的物理内存，均显示在仿真波形中；<br>两个凡是：</li><li>凡是在 <code>always initial</code> 语句中赋值的变量，一定是 <code>reg</code> 型；</li><li>凡是在 <code>assign</code> 语句中赋值的变量，一定是 <code>wire</code> 型；<br>务必注意：<code>reg</code> 变量仅仅是语法定义，不等于电路中的寄存器。<strong>只有时序电路中的 <code>reg</code> 变量才会被逻辑综合工具认为是寄存器</strong>。</li></ul><p>补充一个知识点，在Verilog中，当你定义一个模块时，如果你没有明确指定端口类型，默认情况下端口类型被假定为<code>wire</code>。那么什么时候需要显式地将端口定义为 reg 类型呢？大致有下面两种：<br><strong>第一种，输出端口需要在时钟的上升沿或下降沿触发时进行赋值</strong>。在这种情况下，输出端口应该被定义为<code>reg</code>类型，以便在时序逻辑中使用。如下代码所示</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> example_module (</span><br><span class="line">  <span class="keyword">input</span> clk,</span><br><span class="line">  <span class="keyword">input</span> rst,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data_in,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] data_out</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">      data_out &lt;= <span class="number">8&#x27;b0</span>;  <span class="comment">// 在复位时对输出端口进行赋值</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      data_out &lt;= data_in;  <span class="comment">// 在时钟上升沿触发时对输出端口进行赋值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p><strong>第二种，当端口需要在组合逻辑中存储中间结果时</strong>，你也需要将端口定义为<code>reg</code>类型。如下代码所示</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> example_module (</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] a,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] b,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">always</span> @* <span class="keyword">begin</span></span><br><span class="line">    result = a + b;  <span class="comment">// 将输出端口定义为reg类型，以存储中间计算结果</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="可综合描述四个关键字">可综合描述四个关键字</h3><p><code>always + If-else + assign + case</code><br>禁止：<code>function + for + fork-join + while</code><br><code>assign</code> 关键字主要用来对信号进行连接，重命名，简单组合逻辑（复杂的难以阅读）等，“=” 右边的任何变化都会被立即计算并驱动给等号左边<br><code>always@(*)</code> 会自动将该 always 块中所有引用的信号都自动添加到敏感列表中（适用于敏感信号特别多的情况）</p><p>只使用这四个关键字编写的程序一定是可综合的</p><h2 id="电路结构描述方法">电路结构描述方法</h2><h3 id="mux-多路选择器-输出结果由输入的选择条件决定">MUX – 多路选择器（输出结果由输入的选择条件决定）</h3><p>完全可以用 if-else 来描述<br>下图是一个选择加法器设计，同一个功能由两种不一样的逻辑实现，既可以先加后选，也可以先选后加，如下图所示<br><img src="../../../post-images/Pasted%20image%2020231210222934.jpeg" alt="|500"><br><img src="../../../post-images/Pasted%20image%2020231210222911.jpeg" alt="|500"><br>对于数字电路而言，加法器是比较复杂的，所以先选后加面积会比较小。可以看到不同代码产生的逻辑电路是完全不一样的，在进行代码优化时可以考虑性能优先还是面积优先来设计（类似 C 语言代码产生的汇编一样，也是有性能差异，只是编译器做了很多优化工作所以差异甚小）。</p><h3 id="触发器与锁存器">触发器与锁存器</h3><p>两者对比如下图所示（这里寄存器应该是指的触发器）<br><img src="../../../post-images/Pasted%20image%2020231210222835.jpeg" alt="|500"><br>这里锁存器“输入-输出透明”是指有效期间 D 和 Q 是完全相同的，这种透明就很容易引入一个问题。假设此时 D 信号是有毛刺的，那么就会原封不动地搬给 Q，容易传播毛刺。</p><p>有两种容易引入 latch 的途径，它们的本质都是因为使用了<strong>不完备的条件判断语句</strong>（这里所说的引入 latch 我个人理解可能更多地是指“锁存”这种行为，并不全是指锁存器这个元件）<br>如果引入了意外的锁存器，可能会导致设计的行为与预期不符，甚至会产生时序故障或逻辑错误。而在另外一些情况下，可以有意地引入锁存器，来实现特定的功能或者优化设计。<br><img src="../../../post-images/Pasted%20image%2020231210222805.jpeg" alt="|500"><br>上面两种情况都是因为缺少完备的判断条件，这会导致一些条件下没有赋值语句执行，在这些条件下触发器或锁存器的值不会更新，最后导致意外的行为。也就是说，如果某些条件不满足，触发器或锁存器的值可能会保持不变，而不是按预期的方式更新。<br><strong>对于触发器，需要注意的是输出信号会比输入信号要晚一个时钟周期，每使用一个触发器，时钟周期就会晚一拍。</strong><br>这点是由于触发器的原理导致的，CMU 产生的时钟信号的上升沿或下降沿会触发触发器的状态变化，从而将输入信号暂时存储起来，并在下一个时钟周期的上升沿或下降沿将数据输出。因此输出的信号会比输入信号晚一个时钟周期。由此可以联想到，当使用多个触发器时，每个触发器的时序延迟会累加，导致输出信号相对于输入信号的延迟时间增加。<br>提醒：时序是在 Verilog 编程得到实际电路的过程中设计出来的，而不是通过仿真得到的。</p><h3 id="组合逻辑">组合逻辑</h3><p>组合逻辑描述多使用 <code>assign</code> 和 <code>: ?</code> 语句来描述，适用于比较简单的组合逻辑。对于复杂的组合逻辑，太多的 assign 类型语句不易解读，此时推荐使用 always 块来描述，二者效果是等价的。<br>组合逻辑赋值必须使用 <code>=</code> 阻塞赋值<br><strong>组合逻辑无保存或者锁存功能</strong>，因此，没有复位信号与相关的复位逻辑</p><h3 id="时序逻辑">时序逻辑</h3><p>时序逻辑其实就是&quot;<strong>组合逻辑+触发器</strong>&quot;的实现，如下图所示，可以把他们两个拆开来写，也可以组合来写<br><img src="../../../post-images/Pasted%20image%2020231210222636.jpeg" alt="|500"></p><h3 id="存储器">存储器</h3><p>主要指常见的单口 RAM、双口 RAM 和 ROM 等类型的存储器。Verilog 语法中基本的存储单元定义格式如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [WORD_WIDTH-<span class="number">1</span>:<span class="number">0</span>] MemoryName [DEPTH-<span class="number">1</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>举例如定义一个数据位宽为 8 bit，地址为 64 位宽的 RAM 8x64，则可以定义为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] RAM8x64 [<span class="number">63</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>在使用时需要注意，<strong>不能直接引用存储器某地址的某比特位值</strong>，而是应该先将存储单元赋值给某个寄存器，然后再对该寄存器的某位进行相关操作。（有点类似于软件编程时先将硬盘数据读入寄存器再进行操作）<br>课程中提到不推荐使用 Verilog 直接建模 RAM，推荐使用内嵌的 IP 生成器，在 GUI 中配置生成。</p><h2 id="流水线设计">流水线设计</h2><p>不考虑其他因素的情况下，流水线级数越多，工作效率越高<br>下图是流水线设计的一个例子<br><img src="../../../post-images/Pasted%20image%2020231210222725.jpeg" alt="|500"><br>左边框图里只使用了一个DFF，逻辑路径上的操作包括 + 和 *，此时他们两个的执行是串行关系。当在其中插入一个 DFF 变成一级流水之后，如右边框图所示，此时虽然第一次计算 Q 在第二个周期才得到计算结果（因为第一次时只能等加法计算完成后才能计算乘），但之后运算时二者都是并行进行处理的。简单理解就是在同一个时刻，乘法器在计算上一个周期的 f 与 d 相乘时，加法器正在计算当前 a 和 b 的加法，之后执行也是如此，因此逻辑路径上的延迟相当于减少了原来的二分之一。</p><h2 id="参数化和实例化">参数化和实例化</h2><h3 id="参数化">参数化</h3><p>如下代码所示，其中 <code>#</code> 之后的延迟其实是<strong>仿真时可见时序的延迟</strong>，在实际综合时只有真实门电路的延迟</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> and_delay = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">parameter</span> xor_delay = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">and</span> #and_delay u1(co, a, b);</span><br><span class="line"><span class="keyword">xor</span> #xor_delay u2(sum, a, b);</span><br></pre></td></tr></table></figure><p>这里可以通过 <code>parameter</code>（类似 C 语言中的 <code>define</code>）来实现后续的改写，常用在<strong>位宽修改</strong>上<br><code>define</code> 多用在全局的定义上，而 <code>parameter</code> 更多使用在局部定义上</p><h2 id="仿真">仿真</h2><h3 id="波形文件">波形文件</h3><p>常见的波形文件格式主要如下三个：</p><ul><li><strong>VCD</strong>（Value Change Dump），标准波形文件，所有仿真器都必须支持</li><li><strong>fsdb</strong>（Fast Signal DataBase），Verdi 支持</li><li><strong>WLF</strong>（Wave Log File），modelsim 产生</li></ul><p>各家仿真或调试工具支持的波形文件类型，互不通用，但<strong>基本都可以由 VCD 文件转换而来</strong>（其实就是 VCD 文件的压缩版），有的还提供与 VCD 文件的互转换功能）</p><p><strong>推荐调试方法</strong>：使用各种仿真器后台完成仿真，生成 fsdb 波形，然后使用 verdi 查看波形与调试（功能非常强大）<br>VCD 是 VerilogHDL 语言标准的一部分，因此所有的 Verilog 仿真器都能够查看该文件，允许用户在 Verilog 代码中通过系统函数来 dump VCD 文件。并且其包含了信号的变化信息，记录了整个仿真的信息。其优点是可以通过 VCD 文件来估计设计的功耗，这一点其他波形文件不具备。缺点是体积巨大</p><p>一般来说需要只抽取需要的信号来生成 VCD 查看，不然文件太大<br><img src="../../../post-images/f899244affdd3a270dc74ffa0970ee0e_MD5.jpeg" alt="|500"><br>这种方法比较常见，也更加轻量级<br><img src="../../../post-images/86947e922d0942e3932af27edfc7a41a_MD5.jpeg" alt="|500"><br>关于实际使用和测试，参考课程中给的链接进行：<a href="https://zhuanlan.zhihu.com/p/148795858">一文学会使用全球第四大数字芯片仿真器iverilog - 知乎 (zhihu.com)</a></p><h2 id="q-a">Q &amp; A</h2><h3 id="1-为什么在大规模电路设计上-verilog-渐渐力不从心？">1. 为什么在大规模电路设计上 Verilog 渐渐力不从心？</h3>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> FPGA </tag>
            
            <tag> VerilogHDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CephFS 元数据破坏 &amp; 恢复测试</title>
      <link href="/posts/Ceph/20231207-cephfs-metadata-destroy-recovery-test.html"/>
      <url>/posts/Ceph/20231207-cephfs-metadata-destroy-recovery-test.html</url>
      
        <content type="html"><![CDATA[<p>前一阵子因为异常断电导致 FS 集群服务异常，最后也没能恢复，特此做下测试避免问题再次发生。<br>突然断电或者未保存状态关闭服务直接关机，都可能会导致一系列不一样的问题，这些问题一般都是因为当前机器在内存中缓存的数据没有及时同步或保存导致重启后数据恢复异常。对于 FS 服务而言，最明显的就是元数据和日志这两部分数据。这里先以元数据为主来进行下测试，后面有时间再总结和思考下其他的。<br>下面测试主要参考链接 1 和链接 2，有些命令实际测试是错误的，这里也做了改正，确保是可执行的。</p><h2 id="main">Main</h2><p>在执行以下测试下确保当前集群状态是正常的，data 中 pgs 处于 active+clean 状态，并且文件系统运行运行正常，挂载的文件系统内文件写入读取正常。由于是测试，里面只存放了一些无用的文件来占用空间。</p><h3 id="1-模拟故障">1. 模拟故障</h3><p>首先运行命令删除所有元数据，这里纠正参考链接 1 中的错误，正确命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in `rados -p cephfs_metadata ls`;do rados -p cephfs_metadata rm $i; done</span><br></pre></td></tr></table></figure><p>执行结束后再运行<code>rados -p cephfs_metadata ls</code> 应该没有打印信息。<br>运行命令查看 fs 当前状态如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/# ceph fs status</span><br><span class="line">cephfs - 0 clients</span><br><span class="line">======</span><br><span class="line">RANK  STATE   MDS  ACTIVITY  DNS  INOS  DIRS  CAPS</span><br><span class="line"> 0    failed</span><br><span class="line">      POOL         TYPE     USED  AVAIL</span><br><span class="line">cephfs_metadata  metadata     0   12.2T</span><br><span class="line">  cephfs_data      data    8299M  12.2T</span><br><span class="line">cephfs_recovery - 0 clients</span><br></pre></td></tr></table></figure><p>看到 metadata 部分 USED 大小为 0，说明元数据已经全部丢失了。<br>此时运行 <code>ceph -s</code> 发现集群状态并没有马上发生改变，只用当 mds service 停止一个或者 fs fail 时，状态才会发生改变。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/# ceph fs fail cephfs</span><br><span class="line">cephfs marked not joinable; MDS cannot join the cluster. All MDS ranks marked failed.</span><br><span class="line">root@storage0:/# ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     a8acabb2-9026-11ee-89dc-31e191538d59</span><br><span class="line">    health: HEALTH_ERR</span><br><span class="line">            1 filesystem is degraded</span><br><span class="line">            1 filesystem is offline</span><br><span class="line">            Degraded data redundancy: 12/2119 objects degraded (0.566%), 12 pgs degraded, 245 pgs undersized</span><br><span class="line">            12 mgr modules have recently crashed</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 2 daemons, quorum storage0,storage1 (age 4d)</span><br><span class="line">    mgr: storage0.dnytub(active, since 3d), standbys: storage1.xbibel</span><br><span class="line">    mds: 1/2 daemons up (1 failed), 1 standby</span><br><span class="line">    osd: 10 osds: 10 up (since 4d), 10 in (since 4d); 11 remapped pgs</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    volumes: 1/2 healthy, 1 failed</span><br><span class="line">    pools:   4 pools, 305 pgs</span><br><span class="line">    objects: 1.05k objects, 4.1 GiB</span><br><span class="line">    usage:   8.5 GiB used, 26 TiB / 26 TiB avail</span><br><span class="line">    pgs:     12/2119 objects degraded (0.566%)</span><br><span class="line">             1/2119 objects misplaced (0.047%)</span><br><span class="line">             233 active+undersized</span><br><span class="line">             49  active+clean</span><br><span class="line">             12  active+undersized+degraded</span><br><span class="line">             11  active+clean+remapped</span><br><span class="line"></span><br><span class="line">  progress:</span><br><span class="line">    Global Recovery Event (14m)</span><br><span class="line">      [=====.......................] (remaining: 60m)</span><br></pre></td></tr></table></figure><p>运行命令查看 mds 当前状态也发生了变化（这里和之前不一样，之前异常 mds 一直处于 replaying 状态，而这里并没有，说明这里 journal 并没有发生异常）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/home/admin# ceph mds stat</span><br><span class="line">cephfs:0/1 2 up:standby, 1 damaged</span><br></pre></td></tr></table></figure><p>下一步将尝试进行恢复，在已有数据池没有问题的情况下。</p><h3 id="2-创建备份文件系统">2. 创建备份文件系统</h3><blockquote><p>这里的目的是从 data pool 中恢复一个可用的备份文件系统，两个 FS 只有 Metadata pool 是不相同的。</p></blockquote><p>首先将现有的文件系统停止，避免过程中对数据池发生进一步改写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/home/admin# ceph fs ls</span><br><span class="line">name: cephfs, metadata pool: cephfs_metadata, data pools: [cephfs_data ]</span><br><span class="line">root@storage0:/home/admin# ceph fs fail cephfs</span><br><span class="line">cephfs marked not joinable; MDS cannot join the cluster. All MDS ranks marked failed.</span><br></pre></td></tr></table></figure><p>接下来创建一个恢复文件系统，其中元数据是新建的用来存储恢复的元数据，数据池仍然是原有的数据池。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/home/admin# ceph osd pool create cephfs_recovery_meta 256</span><br><span class="line">pool &#x27;cephfs_recovery_meta&#x27; created</span><br><span class="line">root@storage0:/home/admin# ceph fs new cephfs_recovery cephfs_recovery_meta cephfs_data --recover --allow-dangerous-metadata-overlay</span><br><span class="line">  Pool &#x27;cephfs_data&#x27; (id &#x27;1&#x27;) has pg autoscale mode &#x27;on&#x27; but is not marked as bulk.</span><br><span class="line">  Consider setting the flag by running</span><br><span class="line">    # ceph osd pool set cephfs_data bulk true</span><br><span class="line">new fs with metadata pool 3 and data pool 1</span><br></pre></td></tr></table></figure><p>此时运行命令可以看到两个 fs 的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/# ceph fs status</span><br><span class="line">cephfs - 0 clients</span><br><span class="line">======</span><br><span class="line">RANK  STATE   MDS  ACTIVITY  DNS  INOS  DIRS  CAPS</span><br><span class="line"> 0    failed</span><br><span class="line">      POOL         TYPE     USED  AVAIL</span><br><span class="line">cephfs_metadata  metadata     0   12.2T</span><br><span class="line">  cephfs_data      data    8299M  12.2T</span><br><span class="line">cephfs_recovery - 0 clients</span><br><span class="line">===============</span><br><span class="line">RANK  STATE                MDS                  ACTIVITY     DNS    INOS   DIRS   CAPS</span><br><span class="line"> 0    active  cephfs.storage0.dkvwoh  Reqs:    0 /s    11     14     12      0</span><br><span class="line">        POOL            TYPE     USED  AVAIL</span><br><span class="line">cephfs_recovery_meta  metadata  96.0k  11.8T</span><br><span class="line">    cephfs_data         data    8299M  12.2T</span><br><span class="line">         STANDBY MDS</span><br><span class="line">cephfs.storage1.qcyalm</span><br><span class="line">MDS version: ceph version 18.2.0 (5dd24139a1eada541a3bc16b6941c5dde975e26d) reef (stable)</span><br></pre></td></tr></table></figure><h3 id="3-恢复原-fs">3. 恢复原 FS</h3><p>首先确保整个过程文件系统处于关闭状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/# ceph fs fail cephfs</span><br><span class="line">cephfs marked not joinable; MDS cannot join the cluster. All MDS ranks marked failed.</span><br><span class="line">root@storage0:/# ceph fs set cephfs joinable false</span><br><span class="line">cephfs marked not joinable; MDS cannot join as newly active.</span><br></pre></td></tr></table></figure><p>接下来对 MDS 创建的初始元数据进行重置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/# cephfs-table-tool cephfs:0 reset session</span><br><span class="line">&#123;</span><br><span class="line">    &quot;0&quot;: &#123;</span><br><span class="line">        &quot;data&quot;: &#123;&#125;,</span><br><span class="line">        &quot;result&quot;: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root@storage0:/# cephfs-table-tool cephfs:0 reset snap</span><br><span class="line">&#123;</span><br><span class="line">    &quot;result&quot;: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root@storage0:/# cephfs-table-tool cephfs:0 reset inode</span><br><span class="line">&#123;</span><br><span class="line">    &quot;0&quot;: &#123;</span><br><span class="line">        &quot;data&quot;: &#123;&#125;,</span><br><span class="line">        &quot;result&quot;: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">root@storage0:/# cephfs-journal-tool --rank cephfs:0 journal reset --force</span><br><span class="line">writing EResetJournal entry</span><br></pre></td></tr></table></figure><p>利用数据池和已经创建好的 recovery fs 来恢复元数据池</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/# cephfs-data-scan init --force-init --filesystem cephfs --alternate-pool cephfs_metadata</span><br><span class="line">root@storage0:/# cephfs-data-scan scan_extents --alternate-pool cephfs_metadata --filesystem cephfs_recovery cephfs_data</span><br><span class="line">root@storage0:/# cephfs-data-scan scan_inodes --alternate-pool cephfs_metadata --filesystem cephfs_recovery --force-corrupt cephfs_data</span><br><span class="line">root@storage0:/# cephfs-data-scan scan_links --filesystem cephfs</span><br></pre></td></tr></table></figure><p>现在允许 MDS 加入 recovery_fs 集群，并运行前向清除以修复统计信息，确保有一个 MDS 正在运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/# ceph fs set cephfs joinable true</span><br><span class="line">cephfs marked joinable; MDS may join as newly active.</span><br><span class="line">root@storage0:/# ceph tell mds.0 scrub start / recursive repair</span><br><span class="line">2023-12-07T01:14:44.711+0000 7f9631ffb700  0 client.17146 ms_handle_reset on v2:10.0.1.3:6848/641236932</span><br><span class="line">2023-12-07T01:14:44.751+0000 7f9631ffb700  0 client.17150 ms_handle_reset on v2:10.0.1.3:6848/641236932</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return_code&quot;: 0,</span><br><span class="line">    &quot;scrub_tag&quot;: &quot;ae8e7687-5bb6-40a6-b999-dbf1b6d88f84&quot;,</span><br><span class="line">    &quot;mode&quot;: &quot;asynchronous&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再看集群状态发现原集群状态已经恢复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/# ceph fs status</span><br><span class="line">cephfs - 1 clients</span><br><span class="line">======</span><br><span class="line">RANK  STATE                MDS                  ACTIVITY     DNS    INOS   DIRS   CAPS</span><br><span class="line"> 0    active  cephfs.flexbj-storage1.qcyalm  Reqs:    0 /s    12     15     13      1</span><br><span class="line">      POOL         TYPE     USED  AVAIL</span><br><span class="line">cephfs_metadata  metadata   112k  12.2T</span><br><span class="line">  cephfs_data      data    8299M  12.2T</span><br><span class="line">         STANDBY MDS</span><br><span class="line">===============</span><br><span class="line">RANK  STATE                MDS                  ACTIVITY     DNS    INOS   DIRS   CAPS</span><br><span class="line"> 0    active  cephfs.storage0.dkvwoh  Reqs:    0 /s    11     14     12      0</span><br><span class="line">        POOL            TYPE     USED  AVAIL</span><br><span class="line">cephfs_recovery_meta  metadata  96.0k  11.8T</span><br><span class="line">    cephfs_data         data    8299M  12.2T</span><br><span class="line">MDS version: ceph version 18.2.0 (5dd24139a1eada541a3bc16b6941c5dde975e26d) reef (stable)</span><br></pre></td></tr></table></figure><h3 id="4-删除备份-fs">4. 删除备份 FS</h3><p>运行如下命令进行删除即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/# ceph fs fail cephfs_recovery</span><br><span class="line">cephfs_recovery marked not joinable; MDS cannot join the cluster. All MDS ranks marked failed.</span><br><span class="line">root@storage0:/# ceph fs rm cephfs_recovery --yes-i-really-mean-it</span><br><span class="line">root@storage0:/# ceph osd pool rm cephfs_recovery_meta cephfs_recovery_meta --yes-i-really-really-mean-it</span><br><span class="line">pool &#x27;cephfs_recovery_meta&#x27; removed</span><br></pre></td></tr></table></figure><p>此时查看集群状态发现仍然有 Recovery Process 在执行，这里不是很理解。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/# ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     a8acabb2-9026-11ee-89dc-31e191538d59</span><br><span class="line">    health: HEALTH_WARN</span><br><span class="line">            12 mgr modules have recently crashed</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 2 daemons, quorum storage0,storage1 (age 4d)</span><br><span class="line">    mgr: storage0.dnytub(active, since 3d), standbys: storage1.xbibel</span><br><span class="line">    mds: 1/1 daemons up, 1 standby</span><br><span class="line">    osd: 10 osds: 10 up (since 4d), 10 in (since 4d)</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    volumes: 1/1 healthy</span><br><span class="line">    pools:   3 pools, 49 pgs</span><br><span class="line">    objects: 1.05k objects, 4.1 GiB</span><br><span class="line">    usage:   8.5 GiB used, 26 TiB / 26 TiB avail</span><br><span class="line">    pgs:     49 active+clean</span><br><span class="line"></span><br><span class="line">  progress:</span><br><span class="line">    Global Recovery Event (10h)</span><br><span class="line">      [=====.......................] (remaining: 44h)</span><br></pre></td></tr></table></figure><h2 id="bugs-fix">Bugs fix</h2><h2 id="reference">Reference</h2><ol><li><a href="https://segmentfault.com/a/1190000042796824">后端 - CephFS 如何恢复损毁的Metadata Pool - 个人文章 - SegmentFault 思否</a></li><li><a href="https://docs.ceph.com/en/latest/cephfs/disaster-recovery-experts/">Advanced: Metadata repair tools — Ceph Documentation</a></li><li><a href="https://docs.ceph.com/en/quincy/mgr/progress/">Progress Module — Ceph Documentation</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ceph </tag>
            
            <tag> Bug调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac电量耗尽关机后时间错误--三种解决方法</title>
      <link href="/posts/Others/20231204-mac-power-error-fix.html"/>
      <url>/posts/Others/20231204-mac-power-error-fix.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-删除-var-db-目录下的-timed-文件">1. 删除 /var/db 目录下的 timed 文件</h3><p>右击 Finder 选择 Go to Folder，然后填入路径 /var/db，进入之后找到 timed 文件删除，之后重启。<br>如果显示没有这个文件，尝试下一步（我第一次时间错误有这个文件，第二次就没有了）</p><h3 id="2-删除-etc-目录下的-ntp-conf-文件">2. 删除 /etc 目录下的 ntp.conf 文件</h3><p>和上一步相同，进入 /etc 目录后删除 ntp.conf 文件，然后重启。<br>如果也显示没有这个文件，尝试下一步（第二次时间错误通过这个方法解决，但第三次不行了，删除之后也找不到）</p><h3 id="3-修改自动设定的城市">3. 修改自动设定的城市</h3><p>取消自动勾选的时间域城市（默认是 Shanghai），然后手动选择一个最近其他的（我这里随便选择的 jinan），之后再关闭打开下自动更新时间，应该就可以了。</p><p>第一次遇到时以为得返厂，致电苹果技术客服后，除了返厂或者重装外没有给出合理建议。以上三种方法我都亲自试过可行，希望对大家有帮助吧</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Macbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cephadm 使用相关问题 &amp; 笔记</title>
      <link href="/posts/Ceph/20231203-cephadm-problems-and-notes.html"/>
      <url>/posts/Ceph/20231203-cephadm-problems-and-notes.html</url>
      
        <content type="html"><![CDATA[<h2 id="notes">Notes</h2><h3 id="cephadm-初步理解">Cephadm 初步理解</h3><p>Cephadm 本质很简单，就是类似 k8s 一样的容器管理应用。当整个集群使用 Cephadm bootstrap 之后，每个组件的服务都通过容器方式来运行，并且各个 host 彼此之间通过 ssh 来进行通信。大致如下图所示<br><img src="../../post-images/Pasted%20image%2020231203094717.png" alt="|675"><br>其中 Bootstrap host 是整个集群的起始 host，之后在此基础之上进行 host node 的扩展。如下图所示可以看到起始 host 上运行的 docker 服务大致有如下几个<br><img src="../../post-images/Pasted%20image%2020231203094928.png" alt=""><br>并且运行命令 <code>systemctl -l | grep ceph</code> 可以看到如下运行的服务<br><img src="../../post-images/Pasted%20image%2020231203095102.png" alt=""><br>这里容器运行的服务在 systemctl 中可见的原因是容器技术的一种集成与透明性。当在主机上运行一个容器时，容器内的服务实际上也在主机的进程空间中运行，所以对主机操作系统而言也是可见的。注意尽管容器内的服务可在主机上查看，但对容器内的服务进行管理时应该使用容器编排工具（这里就是 cephadm）。<br>而在扩展的 host 上也是同样有容器服务在运行的，只是我这边不清楚为什么使用了 podman 来进行管理。运行 <code>podman ps</code> 可以看到扩展的 storage1 上正运行的服务<br><img src="../../post-images/Pasted%20image%2020231203101834.png" alt=""><br>然后运行 <code>systemctl -l | grep ceph</code> 可以看到目前正运行的 services。</p><h2 id="debug">Debug</h2><h3 id="cephadm-mgr-dashboard-mgr-modules-have-recently-crashed">Cephadm mgr dashboard – mgr modules have recently crashed</h3><p>报错信息如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/# ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     a8acabb2-9026-11ee-89dc-31e191538d59</span><br><span class="line">    health: HEALTH_WARN</span><br><span class="line">            16 mgr modules have recently crashed</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 2 daemons, quorum storage0,storage1 (age 21h)</span><br><span class="line">    mgr: storage0.dnytub(active, since 3h), standbys: storage1.xbibel</span><br><span class="line">    mds: 1/1 daemons up, 1 standby</span><br><span class="line">    osd: 10 osds: 10 up (since 21h), 10 in (since 21h)</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    volumes: 1/1 healthy</span><br><span class="line">    pools:   3 pools, 49 pgs</span><br><span class="line">    objects: 1.06k objects, 4.1 GiB</span><br><span class="line">    usage:   8.4 GiB used, 26 TiB / 26 TiB avail</span><br><span class="line">    pgs:     49 active+clean</span><br></pre></td></tr></table></figure><h3 id="cephadm-添加新的-mon-时报错">Cephadm 添加新的 Mon 时报错</h3><p>报错信息如下：<code>Error: container-init binary not found on the host: stat /usr/libexec/podman/catatonit: no such file or directory</code><br>在 Cephadm shell 中运行命令添加新的 Mon 时报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/# ceph orch daemon add mon storage1:10.0.1.3</span><br><span class="line">Error EINVAL: cephadm exited with an error code: 1, stderr: Non-zero exit code 125 from /usr/bin/podman container inspect --format &#123;&#123;.State.Status&#125;&#125; ceph-a8acabb2-9026-11ee-89dc-31e191538d59-mon-flexbj-storage1</span><br><span class="line">/usr/bin/podman: stderr Error: error inspecting object: no such container ceph-a8acabb2-9026-11ee-89dc-31e191538d59-mon-flexbj-storage1</span><br><span class="line">Non-zero exit code 125 from /usr/bin/podman container inspect --format &#123;&#123;.State.Status&#125;&#125; ceph-a8acabb2-9026-11ee-89dc-31e191538d59-mon.flexbj-storage1</span><br><span class="line">/usr/bin/podman: stderr Error: error inspecting object: no such container ceph-a8acabb2-9026-11ee-89dc-31e191538d59-mon.flexbj-storage1</span><br><span class="line">Deploy daemon mon.flexbj-storage1 ...</span><br><span class="line">Non-zero exit code 125 from /usr/bin/podman run --rm --ipc=host --stop-signal=SIGTERM --net=host --entrypoint stat --init -e CONTAINER_IMAGE=quay.io/ceph/ceph@sha256:8e1c0c287ee035aa36699c1340da870ebf6d2b1effb327c012d917628367d9df -e NODE_NAME=flexbj-storage1 -e CEPH_USE_RANDOM_NONCE=1 quay.io/ceph/ceph@sha256:8e1c0c287ee035aa36699c1340da870ebf6d2b1effb327c012d917628367d9df -c %u %g /var/lib/ceph</span><br><span class="line">stat: stderr Error: container-init binary not found on the host: stat /usr/libexec/podman/catatonit: no such file or directory</span><br><span class="line">ERROR: Failed to extract uid/gid for path /var/lib/ceph: Failed command: /usr/bin/podman run --rm --ipc=host --stop-signal=SIGTERM --net=host --entrypoint stat --init -e CONTAINER_IMAGE=quay.io/ceph/ceph@sha256:8e1c0c287ee035aa36699c1340da870ebf6d2b1effb327c012d917628367d9df -e NODE_NAME=flexbj-storage1 -e CEPH_USE_RANDOM_NONCE=1 quay.io/ceph/ceph@sha256:8e1c0c287ee035aa36699c1340da870ebf6d2b1effb327c012d917628367d9df -c %u %g /var/lib/ceph: Error: container-init binary not found on the host: stat /usr/libexec/podman/catatonit: no such file or directory</span><br></pre></td></tr></table></figure><p>此时可以看到在新的机器 storage1 上 node-exporter service 并没有启动成功，参考链接 4 在新的机器上运行如下命令之后成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@flexbj-storage1:/# sudo ln -sf /usr/bin/docker-init /usr/libexec/podman/catatonit</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><ol><li><a href="https://unix.stackexchange.com/questions/619212/podman-run-with-init-gives-me-error-container-init-binary-not-found-on-the-h">podman run with --init gives me: Error: container-init binary not found on the host: stat /usr/libexec/podman/catatonit: no such file or directory</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ceph </tag>
            
            <tag> 调试记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartus 下 常用命令 &amp; debugs 记录（更新中）</title>
      <link href="/posts/FPGA/20231203-quartus-debugs-notes.html"/>
      <url>/posts/FPGA/20231203-quartus-debugs-notes.html</url>
      
        <content type="html"><![CDATA[<h2 id="notes">Notes</h2><h3 id="终端-quartus-工程升级更新指令">终端 quartus 工程升级更新指令</h3><p>代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quartus_sh --ip_upgrade -mode required &lt;design&gt;  </span><br><span class="line">quartus_sh --ip_upgrade -mode optional &lt;design&gt;  </span><br><span class="line">quartus_ipgenerate --clean &lt;design&gt;</span><br></pre></td></tr></table></figure><h3 id="qsf-中设置-virtual-pin">qsf 中设置 virtual_PIN</h3><p>参考链接 1，quartus 下编译有时候会遇到 IO 不足的问题，此时可以通过设置 virtual IO 来解决。代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#set_instance_assignment -name VIRTUAL_PIN ON -to *</span><br><span class="line">set_instance_assignment -name VIRTUAL_PIN ON -to pin_* -entity entity_name</span><br></pre></td></tr></table></figure><p>但需要注意，IOPLL 貌似是不能设置为 virtual IO 的，会有报错提示。此时只能将其它 IO 进行设置，可以加 <code>pin_*</code>这样来进行 port name 匹配避免大量输入。</p><h2 id="bugs">Bugs</h2><h3 id="combinational-node-not-enough">combinational node not enough</h3><p>如图<br><img src="../../../post-images/Pasted%20image%2020231213143138.jpeg" alt=""></p><h3 id="an-error-occurred-during-automatic-periphery-placement">An error occurred during automatic periphery placement</h3><p>如图<br><img src="../../../post-images/Pasted%20image%2020231214153036.jpeg" alt=""></p><h3 id="can-t-resolve-multiple-constant-drivers-for-net">Can’t resolve multiple constant drivers for net</h3><p>如下图所示。出现这个错误的原因一般在于，在不同的 always 逻辑块中对同一个 wire 或者 reg 变量进行了赋值。</p><p><img src="../../../post-images/Center.png" alt="img"></p><p>我这边导致错误的原因比较特殊，是在顶层存在两个 module，其中一个 module 的 port 是 inout 类型。所以当我使用了同一个 wire signal 连接它与另一个 module 的 output port，出现了该报错。因为此时综合认为两个 module 都在往同一个 wire signal 写入，造成了冲突。</p><h2 id="references">References</h2><ol><li><a href="https://blog.csdn.net/qq_42538417/article/details/107997328">如何在Quartus II中设置Virtual pin及常见问题-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> 调试记录 </tag>
            
            <tag> FPGA </tag>
            
            <tag> Quartus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VerilogHDL &amp; VHDL 重要语法记录&amp;备忘</title>
      <link href="/posts/FPGA/20231201-HDL-Programming-Notes.html"/>
      <url>/posts/FPGA/20231201-HDL-Programming-Notes.html</url>
      
        <content type="html"><![CDATA[<h2 id="vhdl">VHDL</h2><h3 id="port-设置默认值">Port 设置默认值</h3><p>如下所示，std_logic 和 std_logic_vector 分别有不同的默认值设置形式</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">port</span>(</span><br><span class="line">aclr0    : <span class="keyword">in</span> <span class="built_in">std_logic</span> := <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">aclr1    : <span class="keyword">in</span> <span class="built_in">std_logic</span> := <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">address2_a    : <span class="keyword">in</span> <span class="built_in">std_logic_vector</span>((widthad2_a - <span class="number">1</span>) <span class="keyword">downto</span> <span class="number">0</span>) := ( <span class="keyword">others</span> =&gt; <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">address2_b    : <span class="keyword">in</span> <span class="built_in">std_logic_vector</span>((widthad2_b - <span class="number">1</span>) <span class="keyword">downto</span> <span class="number">0</span>) := ( <span class="keyword">others</span> =&gt; <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="避免被优化">避免被优化</h3><p>以下这三者都可以，但具体使用哪个需要结合他们的差异来做判断</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attribute</span> syn_keep : <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">attribute</span> mark_debug : <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">attribute</span> dont_touch : <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">attribute</span> syn_keep <span class="keyword">of</span> DATA_ARR: <span class="keyword">signal</span> <span class="keyword">is</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">attribute</span> mark_debug <span class="keyword">of</span> DATA_ARR: <span class="keyword">signal</span> <span class="keyword">is</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line"><span class="keyword">attribute</span> dont_touch <span class="keyword">of</span> DATA_ARR: <span class="keyword">signal</span> <span class="keyword">is</span> <span class="string">&quot;true&quot;</span>;</span><br></pre></td></tr></table></figure><p>差异对比：</p><ul><li>对于 <code>dont_touch</code> 属性，被常用于防止综合工具对特定的 wire 或者 module 进行任何优化，告诉综合工具”不要触碰“这个元素，保存原始的形态。</li><li>对于 <code>syn_keep</code> 指令，这个指令是特定于综合的，被用来告诉综合工具保持某些信号或逻辑，主要目的是防止优化过程中的信号消除。</li><li>对于 <code>mark_debug</code> 指令，通常与硬件调试相关，用于标记需要在后续调试中观察的信号。<br>总结：<br>如果说是为了保持信号或模块在综合过程中不变，<code>dont_touch</code> 是最好的选择。如果是为了确保在逻辑优化阶段某些信号不被移除，<code>syn_keep</code> 更合适。最后如果是涉及硬件调试的场景，那么 <code>mark_debug</code> 是首选。</li></ul><p>目前不确定 dont_touch 是不是对于两种编译器都是适用的，能肯定的是 Xilinx 官方有明确的关于 dont_touch 的说明，而 Quartus 端目前能查到的是 keep attribute 的使用，两个链接都放在下面供参考</p><ul><li><a href="https://www.intel.com/content/www/us/en/programmable/quartushelp/current/index.htm#hdl/vhdl/vhdl_file_dir_keep.htm">Intel® Quartus® Prime Pro Edition Help version 23.4 - keep VHDL Synthesis Attribute</a></li><li><a href="https://docs.xilinx.com/r/en-US/ug901-vivado-synthesis/VHDL-Component-Example">VHDL Component Example • Vivado Design Suite User Guide: Synthesis (UG901) • Reader • AMD Adaptive Computing Documentation Portal (xilinx.com)</a></li></ul><h2 id="verilog">Verilog</h2><h3 id="wire-signal-避免被优化">wire signal 避免被优化</h3><p>代码如下，具体差异上面已经介绍过不再赘述</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(* syn_keep = <span class="string">&quot;true&quot;</span>, mark_debug = <span class="string">&quot;true&quot;</span> *) <span class="keyword">wire</span> signal;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> VerilogHDL </tag>
            
            <tag> VHDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ceph OSD 清除状态 &amp; 重新加入集群</title>
      <link href="/posts/Ceph/20231128-Ceph%20OSD%20clear%20status%20&amp;%20rejoin%20cluster.html"/>
      <url>/posts/Ceph/20231128-Ceph%20OSD%20clear%20status%20&amp;%20rejoin%20cluster.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-清除状态">1. 清除状态</h2><p>根据参考链接 1 ，如果想要硬盘可以加入作为 OSD ，必须满足以下所有条件，才认为设备可用：</p><ul><li>​设备必须没有分区。</li><li>设备不得具有任何 LVM 状态。</li><li>不得安装设备。</li><li>设备不得包含文件系统。</li><li>设备不得包含 Ceph BlueStore OSD。</li><li>设备必须大于 5 GB。</li></ul><p>首先，可以分别执行如下命令查看当前块设备和 OSD 的绑定情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsblk      // 查看当前机器的块设备</span><br><span class="line">pvdisplay  // 查看物理卷</span><br><span class="line">vgdisplay  // 查看逻辑卷</span><br></pre></td></tr></table></figure><p>当查看得到具体的物理卷信息和逻辑卷信息后，依次通过如下示例命令进行删除修改（先删除 vg 再删除 pv），需要确认直接 y 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vgremove ceph-bd47920b-c785-4e00-96ff-cdc207b18b52 </span><br><span class="line">pvremove /dev/nvme0n1 /dev/nvme1n1 /dev/sda  /dev/sdb</span><br></pre></td></tr></table></figure><p>最后再运行 lsblk 命令查看下是否已经全部清除即可。</p><h2 id="2-重新加入集群">2. 重新加入集群</h2><p>由于我这边集群是源码编译的，因此可以直接运行 ceph-volume 命令将其加入，示例代码如下（–data 后跟对应的块设备名称）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-volume --cluster ceph lvm create --data /dev/sda</span><br></pre></td></tr></table></figure><p>如没有报错即可加入。</p><h2 id="reference">Reference</h2><ol><li><a href="https://www.cnblogs.com/varden/p/15270628.html">Ubuntu 20.04 LTS 使用 cephadm 部署 ceph octopus 实验记录 - Varden - 博客园 (cnblogs.com)</a></li><li><a href="https://linux.cn/article-5953-1.html">技术|什么是逻辑分区管理 LVM ，如何在Ubuntu中使用？ (linux.cn)</a></li><li><a href="https://www.linuxidc.com/Linux/2015-08/121117.htm">如何在 Ubuntu 中管理和使用逻辑卷管理 LVM_Linux教程​</a></li><li><a href="https://www.cnblogs.com/dancesir/p/14328751.html">挂载硬盘，提示 mount: unknown filesystem type 'LVM2_member’的解决方案 - 553490191 - 博客园 (cnblogs.com)</a></li><li><a href="https://github.com/containers/podman/issues/8227">[BUG] Error: default OCI runtime “runc” not found: invalid argument · Issue #8227 · containers/podman (github.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ceph </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartus 与 Vivado 资源对比</title>
      <link href="/posts/FPGA/20231128-%20Quartus-compare-with-Vivado.html"/>
      <url>/posts/FPGA/20231128-%20Quartus-compare-with-Vivado.html</url>
      
        <content type="html"><![CDATA[<h2 id="main">Main</h2><p>同样的程序运行在 Vivado 和运行在 Quartus 下，最后得到的 utilization 格式不同，该如何对比他们的性能差异呢。<br>这里使用 Equivalent Logic Elements Used 这样一个中间值格式，最后统一成这样一个公式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELE = CLB_LUT * 2.18 = ALM * 2.95</span><br></pre></td></tr></table></figure><p>接下来解释下为什么是这两个值。</p><p>查看 Intel 和 AMD 两家 FPGA 芯片手册，可以发现自家在对比不同系列芯片包含资源时，都会使用一个 Logic Element 值来归一化。对于 AMD 而言是 System Logic Cells (K)，对于 Intel 则是 Logic elements (LEs)。<br>如下截图简单看下，具体请参考下方链接</p><h3 id="a-intel">a. Intel</h3><p><img src="../../../post-images/Pasted%20image%2020231212203755.jpeg" alt=""><br>Link : <a href="https://cdrdv2-public.intel.com/730595/Intel-fpga-product-catalog-23.1.pdf">https://cdrdv2-public.intel.com/730595/Intel-fpga-product-catalog-23.1.pdf</a><br>上图中例子是 Intel Agilex7 不同 Family 的 resource 对比，可以看到 LEs/ALMs 基本都是 2.95。依次这样计算可以得到如下比例：</p><ul><li>Stratix V and Arria 10 : 1 ALM = 2.65 Logic elements</li><li>Stratix 10 and Agilex : 1 ALM = 2.95 Logic elements</li></ul><h3 id="b-amd">b. AMD</h3><p><img src="../../../post-images/Pasted%20image%2020231212203735.jpeg" alt=""><br>Link: <a href="https://docs.xilinx.com/v/u/en-US/ultrascale-fpga-product-selection-guide">ultrascale-fpga-product-selection-guide.pdf • Viewer • AMD Adaptive Computing Documentation Portal (xilinx.com)</a><br>上图中例子是 AMD Virtex UltraScale 不同 Family 的 resource 对比，可以看到 CLB_LUTs/System Logic Cells 基本都是 2.18，而且对比其他系列可以发现比例都是相同的，即</p><ul><li>UltraScale and UltraScale+ : 1 CLB_LUT  = 2.18 System Logic Cells</li></ul><h3 id="c-logic-cells-to-system-logic-cells">c. Logic Cells to System Logic Cells</h3><p>Xilinx 在 2014 年时候推出的 UltraScale 架构中引入了新的逻辑单元计数方式，从 Logic Cells 转变为了 System Logic Cells。这个变化并没有改变芯片本身的实际规模，只是改变了计数方式。事实上，这种举措看上去更像是商业营销的一种手段，参考链接 2 中评论，提到这个名称改变带来的变化</p><p><em>However, if you look back at the NEW Xilinx product tables, you’ll find that same old XCVU065 650K device now expanded into a 783K device, thanks to the magic of “System Logic Cells”.</em></p><p>根据这里的参数，改变后 System Logic Cells 大小差不多是原先 Logic Cells 的 1.2 倍。（找不到官方手册具体参数了）</p><h3 id="d-summary">d. Summary</h3><p>综上，回到最开始的结论，如果想要统一两个厂家之间芯片资源的话，使用如下公式即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELE = CLB_LUT * 2.1875 = ALM * 2.95</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><ol><li><a href="https://stackoverflow.com/questions/29746455/relation-between-luts-logic-cell-logic-elements-system-gates">fpga - Relation between LUTs, logic cell, logic elements, system gates - Stack Overflow</a></li><li><a href="https://www.eejournal.com/article/20151124-marketingmath/">Marketing Math 201 – EEJournal</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ceph </tag>
            
            <tag> FPGA </tag>
            
            <tag> Vivado </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vivado 下 常用命令 &amp; debugs 记录（更新中）</title>
      <link href="/posts/FPGA/20231127-Vivado-debugs-notes.html"/>
      <url>/posts/FPGA/20231127-Vivado-debugs-notes.html</url>
      
        <content type="html"><![CDATA[<h2 id="notes">Notes</h2><h3 id="从-timing-report-中获取-fmax">从 timing report 中获取 Fmax</h3><p>参考链接：<a href="https://support.xilinx.com/s/article/57304?language=en_US">57304 - Vivado Timing - Where can I find the Fmax in the timing report? (xilinx.com)</a></p><p>The term Fmax can be used in 2 different ways:</p><ul><li>The maximum frequency a design can run on Hardware in a given implementation = 1/(T-WNS), with WNS positive or negative.</li><li>The maximum frequency a design can run on a given architecture = 1/(T-WNS), only if WNS&lt;0. The user will have to decrease T and re-run synthesis/implementation until WNS&lt;0.  Different strategies might be needed to get the best achievable Fmax.<br>T is the target clock period. <br>WNS is the worst negative slack of the clock signal in the Intra-Clock Paths section.</li></ul><h2 id="bugs">Bugs</h2><h3 id="resource-utilization-lut-as-logic-over-utilized-in-top-level-design">Resource utilization : LUT as Logic over-utilized in Top Level Design</h3><p>错误信息如下<br><img src="../../../post-images/Pasted%20image%2020231128100459.png" alt=""><br>这种情况如果不能更换 target device 的话，只能想办法看下哪个部分资源利用过高来想办法减少了。</p><h3 id="net-type-must-be-explicitly-specified">net type must be explicitly specified</h3><p>错误信息如下<br><img src="../../../post-images/Pasted%20image%2020231211134725.jpeg" alt=""><br>需要在错误文件中进行如下声明</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">default_nettype</span> wire</span></span><br></pre></td></tr></table></figure><h3 id="io-placement-failed-due-to-overutilization">IO Placement failed due to overutilization</h3><p>如下图所示提示 IO Ports 资源不足问题<br><img src="../../../post-images/image_1694497596010_0.png" alt="image_1694497596010_0"><br>此时修改 Vivado GUI 下 <code>tools/settings/synthesis/more options</code>，添加如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-mode out_of_context</span><br></pre></td></tr></table></figure><h3 id="wrong-boolean-value">Wrong boolean value</h3><p>报这个错误没有错误提示信息，网上查找各种相关问题无果，最后经同事提醒错误应该是出在使用公开的 Generic RAM Module 实现时其中 <code>RW_ADDR_COLLISION</code> 参数没有给出默认值，如果按照默认是空的话会报这个错误，所以需要给出一个值，如下图所示<br><img src="../../../post-images/Pasted%20image%2020231211113631.jpeg" alt="|500"><br>图中代码来自 <a href="http://fpgacpu.ca/fpga/RAM_Single_Port.html">RAM Single Port (fpgacpu.ca)</a></p><h3 id="xpm-xxx-not-found">xpm_xxx not found</h3><p>错误信息如下<br><img src="../../../post-images/Pasted%20image%2020231218145431.png" alt=""><br>在我的这边，这个问题出现在 IP Integrator 中添加了 RTL 构成的模块，然后在 generate output 时报错提示。<br>可能要归属到一类错误而不是单独搜索 <code>xpm_memory_tdpram not found</code>，可行的解决方案是在 tcl console 中运行该命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_property XPM_LIBRARIES &#123;XPM_CDC XPM_MEMORY XPM_FIFO&#125; [current_project]</span><br></pre></td></tr></table></figure><p>至于为什么 xpm 会找不到目前不清楚，可能又是 Vivado 的一个 bug 吧<br>参考链接：<a href="https://support.xilinx.com/s/question/0D52E00006hpm9TSAQ/xpm-cdc-module-not-found?language=en_US">XPM cdc module not found (xilinx.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试记录 </tag>
            
            <tag> Bug调试 </tag>
            
            <tag> FPGA </tag>
            
            <tag> Vivado </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ceph 源码编译报错问题收集</title>
      <link href="/posts/Ceph/20231126-Ceph%20Errors%20in%20compiling%20source%20code.html"/>
      <url>/posts/Ceph/20231126-Ceph%20Errors%20in%20compiling%20source%20code.html</url>
      
        <content type="html"><![CDATA[<h2 id="main">Main</h2><h3 id="npm-代理错误">npm 代理错误</h3><p>错误信息如下<br><img src="../../../post-images/image-20231126213125108.png" alt="image-20231126213125108"><br>解决方法：删除设置的代理信息（不影响安装，npm 好像默认可以使用全局代理？），参考链接 2，运行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config delete proxy</span><br><span class="line">npm config delete https-proxy</span><br></pre></td></tr></table></figure><p>实际测试在 root 用户和普通用户下有区别，最后在普通用户下运行成功。</p><h3 id="npm-版本错误">npm 版本错误</h3><p>错误信息如下<br><img src="../../../post-images/image-20231126214100363.png" alt="image-20231126214100363"><br>参考链接 1，运行如下命令更新即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n latest</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><ol><li><a href="https://stackoverflow.com/questions/71956940/error-npm-is-known-not-to-run-on-node-js-v10-24-1-and-how-to-fix-it-dont-updat">Error npm is known not to run on Node.js v10.24.1 and how to fix it, don’t update to the latest version? - Stack Overflow</a></li><li><a href="https://blog.csdn.net/yanzi1225627/article/details/80247758">npm设置和取消代理的方法_npm查看代理-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ceph </tag>
            
            <tag> 调试记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ceph 集群调试&amp;问题记录</title>
      <link href="/posts/Ceph/20231125-Ceph-cluster-debug-notes.html"/>
      <url>/posts/Ceph/20231125-Ceph-cluster-debug-notes.html</url>
      
        <content type="html"><![CDATA[<h2 id="notes">Notes</h2><hr><h2 id="bugs">Bugs</h2><h3 id="degraded-data-redundancy">Degraded data redundancy</h3><p>集群状态如下<br><img src="../../../post-images/Pasted%20image%2020231129215516.png" alt="|700"><br>建立 CephFS 并挂载之后往其中简单写入了一些文件，没多大但却一直处于 degraded 状态。<br>运行 <code>ceph health detail</code> 打印信息如下<br><img src="../../../post-images/Pasted%20image%2020231130102602.png" alt="|700"><br>根据参考链接 2 中图的描述来看，问题应该是出在 PG 当前 Acting Set 小于存储池副本数，从 last acting [3,7] 这样的信息也可以看出<br><img src="../../../post-images/Pasted%20image%2020231130104401.png" alt="|500"><br>运行 ceph pool ls detail 命令查看确实设置的副本数为 3，不理解为什么会缺少一个副本备份<br><img src="../../../post-images/Pasted%20image%2020231130104600.png" alt=""><br>最后解决方法很粗暴，将三副本的设置改为了二副本。一方面两台机器就存放在一台机房一台机架， 一损俱损；二是考虑到硬盘本身故障率比较低，就 10 个 OSD 的量不会出现同时多个故障问题（相比硬件软件出问题概率更大）。因此趁此机会设置为双副本，增加响应速度也能腾出更多的空间。<br>参考链接 3，使用命令及后来状态如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@storage0:/home/admin# ceph osd pool set cephfs_data size 2</span><br><span class="line">set pool 1 size to 2</span><br><span class="line">root@storage0:/home/admin# ceph osd pool set cephfs_metadata size 2</span><br><span class="line">set pool 2 size to 2</span><br><span class="line">root@storage0:/home/admin# ceph osd pool ls detail</span><br><span class="line">pool 1 &#x27;cephfs_data&#x27; replicated size 2 min_size 1 crush_rule 0 object_hash rjenkins pg_num 256 pgp_num 256 autoscale_mode on last_change 109 flags hashpspool stripe_width 0 application cephfs read_balance_score 1.37</span><br><span class="line">pool 2 &#x27;cephfs_metadata&#x27; replicated size 2 min_size 1 crush_rule 0 object_hash rjenkins pg_num 256 pgp_num 256 autoscale_mode on last_change 111 flags hashpspool stripe_width 0 pg_autoscale_bias 4 pg_num_min 16 recovery_priority 5 application cephfs read_balance_score 1.37</span><br></pre></td></tr></table></figure><p>之后集群也恢复了正常。</p><h2 id="reference">Reference</h2><ol><li><a href="https://stackoverflow.com/questions/75546753/ceph-fix-activeundersizeddegraded-pgs-after-removing-an-osd">kubernetes - Ceph: fix active+undersized+degraded pgs after removing an osd? - Stack Overflow</a></li><li><a href="https://zhuanlan.zhihu.com/p/138778000">分布式存储Ceph之PG状态详解 - 知乎 (zhihu.com)</a></li><li><a href="https://blog.51cto.com/hotcache/2339730">ceph设置副本的数目-2019014补_51CTO博客_ceph 副本数</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ceph </tag>
            
            <tag> Bug调试 </tag>
            
            <tag> Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ceph 源码编译集群正常关闭&amp;开启</title>
      <link href="/posts/Ceph/20231125-Ceph%20cluster%20stop%20&amp;%20start.html"/>
      <url>/posts/Ceph/20231125-Ceph%20cluster%20stop%20&amp;%20start.html</url>
      
        <content type="html"><![CDATA[<p>关闭命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ceph fs set cephfs down true</span><br><span class="line">ceph osd set noout</span><br><span class="line">ceph osd set norecover</span><br><span class="line">ceph osd set norebalance</span><br><span class="line">ceph osd set nobackfill</span><br><span class="line">ceph osd set nodown</span><br><span class="line">ceph osd set pause </span><br><span class="line"></span><br><span class="line">systemctl stop ceph.target</span><br></pre></td></tr></table></figure><p>开机命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ceph-volume lvm activate --all</span><br><span class="line">ceph osd unset noout</span><br><span class="line">ceph osd unset norecover</span><br><span class="line">ceph osd unset norebalance</span><br><span class="line">ceph osd unset nobackfill</span><br><span class="line">ceph osd unset nodown </span><br><span class="line">ceph osd unset pause</span><br><span class="line"></span><br><span class="line">ceph fs set cephfs down false</span><br></pre></td></tr></table></figure><p>网络设备挂载命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount.ceph 10.0.1.2:6789:/ /mnt/storage -o name=admin,secretfile=/etc/ceph/admin.secret </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ceph </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ceph 学习随记</title>
      <link href="/posts/Ceph/20231125-Ceph-notes.html"/>
      <url>/posts/Ceph/20231125-Ceph-notes.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-notes">1. Notes</h2><h3 id="a-存储">a. 存储</h3><ul><li>对象（必须通过 PG 间接地）归属于某个存储池，因此对象必须记忆其归属的存储池标识。</li><li>作为文件系统中最经典的数据备份机制，快照和克隆对所有存储系统而言几乎都是必备功能。</li><li>在 Ceph 中我们需要能够实现对 PG 中的每个对象进行严格排序，综合考虑这种排序使用的唯一标识需要使用哈希来实现。</li><li>产生哈希冲突的概率一是取决于算法本身，而是取决于输出长度。在保证算法不变的前提下，增加输出长度可以不同程度地降低产出冲突的概率。</li><li>使用命名空间加上对象名作为哈希输入而不是使用对象的全部特征值。基于这些排序算法可以对 PG 中的所有对象执行快速排序，这是实现 Backfill、Scrub 等复杂功能的理论基础。</li><li>对象存储和我们常接触的硬盘和文件系统等存储形态不同，它有两个显著特征如下：<ul><li>对象存储采用 Key/Value(K/V) 方式的 RESTful 数据读写接口，并且常以网络服务的形式提供数据的访问；</li><li>扁平的数据组织结构。对比文件系统，对象存储采用扁平的数据组织结构，往往是两层或三层。例如 AWS S3 和华为的 UDS，每个用户可以把他的存储空间划分为”容器“，然后往容器里放对象，对象不能直接放到用户的根存储空间里，必须放到某个容器的下面，而且不能嵌套，也就是说，容器下面不能再放一层容器，只能放对象。</li></ul></li></ul><h3 id="b-crush">b. CRUSH</h3><ul><li>一致性哈希算法的出现解决了扩容带来的数据迁移问题，甚至能够接近理论上的最优解，但其模型仍过于简单，对于存储系统中的各种可能问题难以应对，其中最突出的就是数据失效问题。因为所有用户的数据都是均匀分布在系统重的，所以一个设备的失效将会影响所有用户数据的完整性。而且由于一致性哈希算法没有感知存储节点的实际物理分布的能力，如何合理地控制数据的失效域更是无从谈起。</li><li>Ceph 只需要在集群中维护并同步少量的 CRUSH 元数据（CRUSH Map, OSD Map和 CRUSH Rule)，各个节点就能独立计算出所有数据的位置，并能保证数据结果对于同样的输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是相同的。并且 CRUSH 算法的计算过程无须任何中心节点的介入，理论上可以承受任何节点的失效问题。<br>CRUSH 元数据包括如下几个：<ul><li>CRUSH Map: 保存了集群中所有设备或 OSD 存储节点的位置信息和权重设置；</li><li>OSD Map: 保存了各个 OSD 的运行时状态。能让 CRUSH 算法感知存储节点的失效、删除和加入情况，产生最小化的数据迁移，提高 Ceph 在各种情况下的可用性和稳定性；</li><li>CRUSH Rule: 用户设置的规则；</li></ul></li><li>关于数据备份策略，通常来说多个数据副本是不需要有顺序的，但是纠删码不一样，纠删码的各个分片之间是需要有顺序的，所以对于 CRUSH 算法而言需要了解各个关联的副本之间是否存在顺序性。</li><li>Ceph 集群自动生成的默认规则只能保证集群数据备份在不同的主机中，实际情况更加复杂，需要用户根据失效域自行配置规则。</li></ul><h3 id="c-rados">c. RADOS</h3><ul><li>OSD 和 Monitor 之间互相传递节点的状态信息，共同得出系统的总体运行状态，并保存在一个全局的数据结构中，即所谓的 Cluster Map 里。由 Monitor 负责与客户端交互来提供 Cluster Map，在客户端本地直接进行计算得到对象的存储位置，然后直接与对应的 OSD 进行通信。OSD 可以利用本地节点的 CPU 和内存执行那些传统集群架构中高耗CPU的任务，充分发挥节点上的计算能力；</li></ul><h3 id="d-osd">d. OSD</h3><ul><li>在 RADOS 中每个 OSD 也有自己的一个 Daemon，这个 Daemon 负责完成 OSD 的所有逻辑功能。OSD 在扁平的命名空间内把所有的数据存储为对象（也就是没有目录层次）。<strong>对象包含一个标识符、二进制数和由名/值对组成的元数据</strong>，元数据语义完全取决于 Ceph 客户端。</li><li>OSD 状态用两个维度表示：up 或 down（OSD Daemon 与 Monitor 连接是否正常）；in 或 out（OSD 是否含有 PG）。</li><li>OSD 的状态检测使用心跳包，为了避免所有 OSD 都互相发送心跳包对集群性能产生影响，Ceph 选择 Peer OSD 发送心跳包。PeerOSD 是指该 OSD 上所有 PG 的副本所在的 OSD，根据 Public Network 和 Cluster Network 之分，Peer OSD 之间的心跳包也分为前端和后端，这样可最大限度地监测 OSD 及 Public Network 和 Cluster Network 的状态，及时上报 Monitor。</li></ul><h3 id="f-others">f. Others</h3><ul><li>充分发挥存储设备自身的计算能力是 Ceph 系统设计的核心思想。</li><li>不同于传统文件系统提供的 open/read/write/close/lseek，对象存储只提供 put/get/delete，对象存储的逻辑单元就是对象而不是我们通常概念中的文件；</li></ul><h2 id="2-q-a">2. Q &amp; A</h2><h3 id="q-ceph-中分割出存储池的作用以及可以进行的操作都有哪些？">Q : Ceph 中分割出存储池的作用以及可以进行的操作都有哪些？</h3><p>Ceph 抽象出存储池这个概念之后，便可以针对存储池设计特定的 CRUSH 规则，举例如下：</p><ul><li>限制其只能使用某些规格相同的 OSD；</li><li>尽可能将所有数据副本分布在物理上隔离的、不同的故障域；<br>也可以针对不同用途的存储池指定不同的副本策略，举例如下：</li><li>若存储池承载的存储应用对时延敏感，则采用多副本备份策略；</li><li>若存储的是一些对时延不敏感的数据（例如备份数据），为提升空间利用率则采用纠删码备份策略；</li><li>其他还可以分别指定如独立的 Scrub、压缩、校验策略等</li></ul><h3 id="q-存储池的两次映射是什么？">Q : 存储池的两次映射是什么？</h3><p>存储池以 PG 为基本单位进行管理，RADOS 并没有将数据一步到位地写入 OSD 的本地存储设备，而是通过 PG 这个中间结构执行两次映射。<br>第一次映射是静态的，将任意类型的客户端数据按照固定大小进行切割、编号，作为伪随机哈希函数输入，均匀映射至每个 PG，以实现负载均衡策略；<br>第二次映射仍然伪随机哈希函数，以保证 PG 在 OSD 之间分布的均匀性，实现 PG 到 OSD 映射。但其输入除了全局唯一的 PG 身份标识之外，还引入了集群拓扑，并且使用 CRUSH 规则对映射过程进行调整，以帮助 PG 在不同 OSD 之间灵活迁移，进而实现数据可靠性、自动平衡等高级特性。</p><h2 id="reference">Reference</h2><ol><li><a href="https://ngwind.github.io/ceph%E5%AD%98%E5%82%A8/2019/07/17/Ceph%E5%AD%98%E5%82%A8-%E4%B8%83-CephFS%E8%AF%A6%E8%A7%A3/">Ceph存储（七）CephFS详解 | Andre’s Blogs (ngwind.github.io)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Ceph </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity 学习笔记 2 - 脚本数据传递与事件通知</title>
      <link href="/posts/Unity/20230812-Unity-learning-note-2-script-data-communication.html"/>
      <url>/posts/Unity/20230812-Unity-learning-note-2-script-data-communication.html</url>
      
        <content type="html"><![CDATA[<p>在 Unity 中，每个脚本都绑定在一个独立的对象上，而对象与对象之间不可避免地需要彼此之间进行沟通和调用，其中包括平级的对象之间，以及父对象与子对象之间，都会存在各种不同的数据传递或者调用，来实现事件的响应等。</p><p>参考链接：<a href="https://www.bilibili.com/video/BV1LZ4y1Y7pE/">【详解Unity】脚本数据传递与事件通知 | 方法总结_哔哩哔哩_bilibili</a></p><span id="more"></span><h2 id="1-数据传递">1. 数据传递</h2><p>先来看下对象之间的数据传递，大致有如下几种方法：</p><ul><li>定义静态字段</li><li>定义公开属性、Get 方法</li><li>PlayerPrefs</li><li>单例模式</li></ul><h3 id="a-定义静态字段">a. 定义静态字段</h3><p>一般适用于一些固定的常量，或者实例之间共享的变量。和 C++ 类似，定义的静态字段可以直接通过&quot;类名.静态变量名&quot;的方式来获取调用。定义方式如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> number = <span class="number">999</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> NUMBER = <span class="number">888</span>;</span><br></pre></td></tr></table></figure><h3 id="b-定义公开属性-get-方法">b. 定义公开属性、Get 方法</h3><p>如果是跨脚本传输数据的话，需要获得该脚本的实例对象才能去访问公开变量，至于如何获取该实例对象见下方代码</p><p>脚本 A</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ItemA</span> : <span class="title">MonoBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// a. 定义私有变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> Hp = <span class="number">1000</span>；</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// b. 定义该变量的公开属性</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> Hp&#123;<span class="keyword">get</span>&#123;<span class="keyword">return</span> Hp;&#125;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// c. 定义该变量的公开方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetHp</span>()</span> &#123; <span class="keyword">return</span> Hp; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本 B</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 必须首先通过拖拽赋值</span></span><br><span class="line"><span class="keyword">public</span> ItemA A;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">  <span class="comment">// 通过公有成员函数获取</span></span><br><span class="line">  Debug.Log(<span class="string">&quot;Hp= &quot;</span> + A.GetHp());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 通过游戏运行时查找</span></span><br><span class="line">  A = GameObject.Find(<span class="string">&quot;对象名&quot;</span>).GetComponent&lt;ItemA&gt;()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c-playerprefs">c. PlayerPrefs</h3><p>PlayerPrefs 本质上是用于<strong>数据本地持久化保存和读取</strong>的一个 Unity 内置静态类，但也可以用于脚本通讯。多用于存档使用。</p><p>原理：以 Key-Value 的形式将数据保存在本地，然后在代码中可以写入、读取、更新数据。以下以整形数据存储读取举例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储整形数据</span></span><br><span class="line">PlayerPrefs.SetInt(<span class="string">&quot;intKey&quot;</span>, <span class="number">999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出 key 为 &quot;intKey&quot; 的整形数据</span></span><br><span class="line"><span class="built_in">int</span> intVal = PlayerPrefs.GetInt(<span class="string">&quot;intKey&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找是否存在 key 为 &quot;intKey&quot; 的数据</span></span><br><span class="line"><span class="built_in">bool</span> exist = PlayerPrefs.HasKey(<span class="string">&quot;intKey&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="d-单例模式">d. 单例模式</h3><p>一旦使用单例模式，数据就可以很方便地被调用，无需先获取实例，因为类的内部已经写好了获取方法。但是首先要保证，这个类是独一份的，才适用于这种模式。这种有点类似于静态变量的定义，已经保证在整个系统中只存在这样一个变量，那么就可以共享该数据。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> number = <span class="number">889</span>;</span><br><span class="line">Test <span class="keyword">static</span> test = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">GetInstance</span>()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (test == <span class="literal">null</span>) </span><br><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-消息通知">2. 消息通知</h2><p>实现：<code>SendMessage</code>;</p><p>这个方法是由 Unity 提供的，可用于游戏对象自身的脚本之间的通知、父级对子级的通知、子级对父级的通知等。但并不支持两个游戏对象之间的消息通知。具体有这么三种方法可以使用</p><ul><li><code>SendMessage(&quot;接收函数&quot;, 需传递的参数)</code> -&gt; 发送给自身的所有脚本</li><li><code>SendMessageUpwards(&quot;接收函数&quot;, 需传递的参数)</code> -&gt; 发送给自身的所有脚本以及自身父物体、父、父物体等身上的所有脚本</li><li><code>BroadcaseMessage(&quot;接收函数&quot;, 需传递的参数)</code> -&gt; 发送给自身的所有脚本以及自身子物体、子、子物体等身上的所有脚本</li></ul><h2 id="3-定义委托-事件回调函数机制">3. 定义委托（事件回调函数机制）</h2><p>事件中心的实现代码如下，通过这个事件中心来实现回调函数的注册，注销和触发。个人觉得可以把它理解成一个<strong>函数指针</strong>的字典，并且是单例实现的。前面也说过通过单例实现可以类似静态变量一样来实现被全局调用，于是在整个工程中，通过该事件中心来实现所有需要交互调用的函数的注册使用以及触发。当某一个函数需要被其他对象调用时，可以先将其注册到事件中心。然后在需要调用处来触发实现调用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventCenter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EventCenter</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventCenter eventCenter= <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventCenter <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventCenter == <span class="literal">null</span>)</span><br><span class="line">            eventCenter = <span class="keyword">new</span> EventCenter();</span><br><span class="line">        <span class="keyword">return</span> eventCenter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">processEvent</span>(<span class="params">Object obj, <span class="built_in">int</span> param1, <span class="built_in">int</span> param2</span>)</span>; </span><br><span class="line">    <span class="comment">//把委托当成一个指针来理解</span></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, processEvent&gt; eventMap = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, processEvent&gt;(); </span><br><span class="line">    <span class="comment">//那么这里存贮的就是一个字符串，对应一个函数地址</span></span><br><span class="line">    <span class="comment">//声明一个自定义委托，使用字典键值对存贮，</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Regist</span>(<span class="params"><span class="built_in">string</span> name, processEvent func</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventMap.ContainsKey(name))</span><br><span class="line">            eventMap[name] += func;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            eventMap[name] = func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注销</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegist</span>(<span class="params"><span class="built_in">string</span> name, processEvent func</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventMap.ContainsKey(name))</span><br><span class="line">            eventMap[name] -= func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//触发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Trigger</span>(<span class="params"><span class="built_in">string</span> name, Object obj, <span class="built_in">int</span> param1, <span class="built_in">int</span> param2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventMap.ContainsKey(name))</span><br><span class="line">            eventMap[name].Invoke(obj, param1, param2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行逻辑：当触发 触发函数时，判断字典内是否有对应注册好的字符串，若有，则执行字符串对应的函数地址的函数，则完成一次触发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    //注册方面</span></span><br><span class="line"><span class="comment">    private void Start()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        EventCenter.GetInstance().Regist(&quot;LookItem&quot;, OnLookItem);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    private void OnLookItem(Object obj, int param1, int param2)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        Debug.Log(obj.name + &quot;被发现了&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //触发方面：</span></span><br><span class="line"><span class="comment">    EventCenter.GetInstance().Trigger(&quot;LookItem&quot;, hit.collider.gameObject, 0, 0);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="4-总结">4. 总结</h2><ul><li>声明一个静态字段的可用范围较小，但使用通过类名获取很方便；</li><li>声明一个公开属性或 Get 方法很方便，但需要手动给脚本添加实例才能使用；</li><li>PlayerPrpfs 技术是全局通用的，多用于存档备份；</li><li>单例模式是一种设计模式，但也可以很方便地访问数据，因为它不需要获取当前实例；</li><li>SendMessage 虽然用于消息通知，不过通知的同时也可以传递参数，但仅能传递同对象脚本，不常用；</li><li>定义委托则是全局通用，通过事件处理机制来协调各个脚本之间的数据传递和消息通知；</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> ceph </tag>
            
            <tag> 服务器运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity 学习笔记 1 - 运动方式</title>
      <link href="/posts/Unity/20230811-unity-learning-note-3-movement.html"/>
      <url>/posts/Unity/20230811-unity-learning-note-3-movement.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考视频链接：<a href="https://www.bilibili.com/video/BV1qZ4y147A3/">【详解Unity】几种移动方式实现_哔哩哔哩_bilibili</a></p></blockquote><h2 id="1-transform-类移动">1. Transform 类移动</h2><h3 id="a-transform-position">a. transform.position</h3><p>最基础的移动方式，每帧瞬移 <code>speed * Time.deltaTime</code>，注意这里是 <code>+= position</code> 而不是 <code>=</code> （即这里的输入是一帧内的相对运动距离）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.position += <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, speed * Time.deltaTime);</span><br></pre></td></tr></table></figure><h3 id="b-transform-translate">b. transform.Translate</h3><p>实现：<code>Translate(V3向量， 坐标系)</code></p><p>相较于 transform.position 的优点是 translate 可使用自身坐标移动，而 position 则永远以世界坐标为参照。举个例子，当把物体绕 z 轴旋转 45 度之后，让其沿着 x 轴进行运动。此时其自身坐标系的 x 和 z 平面与世界坐标系的平面之间有了夹角，默认情况下使用 Translte 运动时便会斜着进行运动。而不是与世界坐标系的平面平行运动。若想让其仍然沿着世界坐标系的 x 轴进行运动的话，修改下 Translate 的第三个参数为 <code>Space.World</code> 即可，默认值是 <code>Space.Self</code>。</p><p>坐标系参数：</p><ul><li><code>Space.Self</code>(默认值)（参照自身坐标移动）</li><li><code>Space.World</code>(参照世界坐标移动)</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.Translate(Vector3.forward * Time.deltaTime * speed, Space.Self);</span><br></pre></td></tr></table></figure><p>关于世界坐标系和自身坐标系的区别，可以在 Unity 左上角进行切换查看，或者按快捷键 x 进行切换。</p><h2 id="2-vector3-类移动-渐变">2. Vector3 类移动（渐变）</h2><p>这类移动相关的函数与其说是移动不如说是渐变更合适些，通过插值的形式得到一组渐变的位置点，然后进行赋值。</p><h3 id="a-vector3-lerp">a. Vector3.Lerp</h3><p>实现：<code>Lerp(当前位置(V3)，目标位置(V3)，时间(float))；</code></p><p>这种方式实现的线性移动由时间参数控制，距离越近，运动越缓慢。主要应用在摄像机跟随上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 lerp = Vector3.Lerp(transform.position, target.position, Time.deltaTime * speed);</span><br><span class="line">transform.position = lerp; <span class="comment">// 生成的插值进行赋值</span></span><br></pre></td></tr></table></figure><h3 id="b-vector3-slerp">b. Vector3.Slerp</h3><p>实现：<code>Slerp(当前位置(V3)，目标位置(V3)，时间(float))；</code></p><p>相比 Lerp，其移动跟随时是以一个弧形轨迹来进行的，主要应用在旋转时过渡，或者抛物线。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 slerp = Vector3.Slerp(transform.position, target.position, Time.deltaTime * speed);</span><br><span class="line">transform.position = slerp;</span><br></pre></td></tr></table></figure><h3 id="c-vector3-movetowards">c. Vector3.MoveTowards</h3><p>实现：<code>MoveTowards(当前位置(V3)，目标位置(V3)，时间(float)) ；</code></p><p>一个缓慢的，匀速运动的过程。速度参数：取正-&gt;靠近目标，取负-&gt;远离目标</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 movetowards = Vector3.MoveTowards(transform.position, target.position, Time.deltaTime * speed);</span><br><span class="line">transform.position = movetowards;</span><br></pre></td></tr></table></figure><h3 id="d-vector3-smoothdamp">d. Vector3.SmoothDamp</h3><p>实现：<code>SmoothDamp(当前位置(V3)，目标位置(V3)，当前速度(ref: V3), 所需时间(float), 最大速度(float))</code></p><p>官方翻译为“平滑阻尼”，也就是移动过程中，逐渐变慢地抵达终点。</p><p>注意：当前速度参数应为全局变量，因为是 ref 所以每次都会修改该值。而对于所需时间参数，该值越小，越快抵达目标。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 movetowards = Vector3.SmoothDamp(transform.position, target.position, <span class="keyword">ref</span> currentVelocity, smoothTime, maxSpeed);</span><br><span class="line">transform.position = movetowards;</span><br></pre></td></tr></table></figure><h2 id="3-刚体-rigidbody-方式移动">3. 刚体 (Rigidbody) 方式移动</h2><h3 id="a-addforce">a. AddForce</h3><p>实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rig.AddForce(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">20f</span>), ForceMode.Force); <span class="comment">// (力的方向，力的模式)</span></span><br></pre></td></tr></table></figure><p>该实现建议放置在 FixedUpdate 函数下，此时移动物体需要添加刚体，适合<strong>模拟外力作用下</strong>的刚体运动。注意此力为累加的力，不适合重复施加力来模拟物体。</p><p>力的模式（ForceMode) 有如下几种：</p><ul><li>Force -&gt; 可持续的力，受质量影响（默认）</li><li>Acceleration -&gt; 可持续的加速度，不受质量影响</li><li>Impulse -&gt; 一个瞬间冲击力，受质量的影响</li><li>VelocityChange -&gt; 一个瞬间速度变化，不受质量影响</li></ul><p>这里补充下刚体 Rigidbody Component 里面几个参数的含义</p><ul><li>Mass -&gt; 物体的质量</li><li>Drag -&gt; 空气的阻力</li><li>Angular Drag -&gt; 角阻力</li><li>Use Gravity -&gt; 是否使用重力</li><li>Is Kinematic -&gt; 是否使用动力学</li></ul><h3 id="b-moveposition">b. MovePosition</h3><p>实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rig.MovePosition(transform.position + speed * Time.deltaTime);</span><br></pre></td></tr></table></figure><p>其适合模拟常规移动，但需要收到物理引擎影响的物体</p><h3 id="c-velocity">c. Velocity</h3><p>实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rig.velocity += <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>) * Time.deltaTime;</span><br></pre></td></tr></table></figure><p>瞬间给一个物体恒定的速度，将该物体提升到这个速度并保持。主要应用在跳跃上。</p><h2 id="4-使用角色控制器组件移动">4. 使用角色控制器组件移动</h2><p>角色控制器（Character Controller）是一个 Compoent 需要自己手动添加，里面大致有以下几个参数：</p><ul><li>Slope Limit -&gt; 爬坡限制，高于这个就爬不上去了</li><li>Step Offset -&gt;</li><li>Skin Width -&gt; 外壳厚度</li><li>Min Move Distance -&gt; 最小移动距离</li></ul><p>以下两个功能使用均需要挂载角色控制器组件</p><h3 id="a-simplemove">a. SimpleMove</h3><p>实现：<code>SimpleMove(有方向的力(V3));</code></p><p>以秒为单位，无需乘以时间。无需添加刚体，自带刚体效果，具有重力。Y 轴无效，若想使用 Y 轴有效需使用 Move</p><p>应用于简单角色移动，角色控制器的物体有刚体的效果，但仅受限于碰撞体，其他物理效果对此无效。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc.SimpleMove(transform.forward * speed);</span><br></pre></td></tr></table></figure><h3 id="b-move">b. Move</h3><p>实现：<code>Move(有方向的力(V3))</code></p><p>注意其不具备重力，需要自行计算下落（需要考虑加速度之类）。主要应用在角色移动（角色控制器的物体有刚体的效果，但仅限于碰撞体，其他物理效果对此无效）。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc.Move(transform.forward * speed * Time.deltaTime);</span><br></pre></td></tr></table></figure><h2 id="5-几种移动方式的区别和应用">5. 几种移动方式的区别和应用</h2><ul><li>Transform：适用于既没有物理系统，又对移动无特殊要求的物体，但过于基础，不易处理障碍物阻挡问题；</li><li>Vector：动作之间的渐变，不常用于移动，摄像机跟随；</li><li>Rigidbody：适用于关卡障碍之类；</li><li>CharacterController：常用于主角移动；</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 运动规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 20.04 下 Ceph quincy 源码安装</title>
      <link href="/posts/Ceph/20230729-Ubuntu-20-04-ceph-quincy-installation-by-source-code.html"/>
      <url>/posts/Ceph/20230729-Ubuntu-20-04-ceph-quincy-installation-by-source-code.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>使用官方源码编译过程中主要参考链接 1~3 官网链接以及链接 8，有比较详细的步骤<br><strong>想要实现效果</strong>：</p><ul><li>两台主机承担 Ceph 所有服务功能，一主一备分别运行 Mon，Mgr 以及 Mds 等服务，每台机器上都有相应的存储作为 OSD 加载；</li><li>这两台主机均使用源码编译，启动 DPDK 和 SPDK 服务，加速其他客户端的读取访问操作；</li><li>其他机器通过局域网交换机与这两台记录建立通信，作为客户端连接到集群。在这些机器上挂载 CephFS 目录，实现共享文件系统访问；<br><strong>当前环境</strong></li><li>所有机器均通过 Cisco 交换机进行连接，连接网卡为 Intel XL710 40G；</li><li>机器环境均为 Ubuntu 20.04 LTS<br><strong>整个集群规划如下</strong></li><li>storage0 (10.0.1.2) - 主 Mon, Mgr, Mds, OSD (源码编译添加 DPDK SPDK 选项)</li><li>storage1 (10.0.1.3) - 从 Mon, Mgr, Mds, OSD (源码编译添加 DPDK SPDK 选项)</li><li>gpu0 (10.0.1.4) - Client (局域网络挂载 CephFS 服务)</li><li>gpu1 (10.0.1.5) - Client (同上)</li><li>gpu2 (10.0.1.6) - Client (同上)</li></ul><h2 id="1-源码安装">1. 源码安装</h2><p>从官网 clone 后在源码进行编译（测试下载压缩包编译会出现问题），然后 checkout 到一个 stable release 的分支如 quincy-release（当前最新版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/ceph/ceph.git</span><br><span class="line"><span class="built_in">cd</span> ceph</span><br><span class="line">git checkout quincy-release</span><br></pre></td></tr></table></figure><p>根据官网描述运行 <code>./install-deps.sh</code> 安装相关文件和依赖项<br>测试发现前面步骤安装完成后，后面运行仍然会提示缺少依赖项的问题，统一记录如下（ubuntu 20.04），再继续安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y libibverbs-dev python3-sphinx librdmacm-dev libblkid-dev libkeyutils-dev libldap2-dev libcryptsetup-dev libjson-c-dev libpopt-dev libdevmapper-dev libsqlite3-dev libsnappy-dev liblz4-dev libcurl4-openssl-dev liboath-dev liblttng-ust-dev libbabeltrace-dev liblua5.3-dev cython3 libnl-genl-3-dev libcap-ng-dev librabbitmq-dev librdkafka-dev libthrift-dev gperf libfmt-dev libicu-dev libaio-dev libre2-dev</span><br></pre></td></tr></table></figure><p>安装完成后运行如下命令，启动 DPDK 和 SPDK 编译选项进行加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARGS=&quot;-DCMAKE_BUILD_TYPE=RelWithDebInfo -DWITH_DPDK=ON -DWITH_SPDK=ON -DWITH_TESTS=OFF&quot; ./do_cmake.sh</span><br></pre></td></tr></table></figure><p>执行上面命令后会在本地创建 <code>build</code> 文件夹，之后执行安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd build</span><br><span class="line">ninja -j16               # long time ...</span><br><span class="line">sudo ninja install       # install in user space - /usr/local/bin</span><br></pre></td></tr></table></figure><p>安装完成后便可以使用 ceph 相关命令了，可以在 <code>/usr/local/bin</code> 目录下看到 ceph 相关的所有可执行命令，以及在 <code>/usr/lib/systemd/system</code> 下面看到所有生成的 service ，后面使用命令 <code>systemd start ceph-mon@</code> 等相关命令都是从这里调取 service。<br>然而这里有个奇怪的问题，所有默认的 service 启动 ceph 相关指令的地址都是在 <code>/usr/bin</code> 下面，而运行 <code>ninja install</code> 安装后的位置却是在 <code>/usr/local/bin</code> 下面。因此要么修改每个 service 里面 ceph 指令的启动位置，要么移动所有的指令到 <code>/usr/bin</code> 下面。这里我个人做了两点修改：</p><ul><li>没有根据官网或者其他参考资料那样使用 ceph 用户和用户组，而是统一使用 root ，因此需要更改 service 中的用户和用户组为 root（原来的是 ceph）；</li><li>修改所有 service 中的的 <code>/usr/bin</code> 为 <code>/usr/local/bin</code>，否则启动 service 会报错提示无法启动；</li></ul><hr><h2 id="2-集群部署">2. 集群部署</h2><h3 id="a-mon-安装">a. Mon 安装</h3><p>主要参考链接 9（官方搭建链接，只有一个 Mon 节点）和链接 8（多节点搭建），和参考链接不同，这里均使用 root 用户来实现，默认已经修改过 <code>/usr/lib/systemd/system</code> 下的 service 文件<br>首先创建相关的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/ceph</span><br><span class="line">mkdir -p /var/lib/ceph/bootstrap-osd</span><br><span class="line">mkdir -p /var/lib/ceph/mon</span><br><span class="line">mkdir -p /var/lib/ceph/osd</span><br></pre></td></tr></table></figure><p>运行 <code>uuidgen</code> 命令生成 fsid 序号，然后创建 cluster 配置文件 <code>/etc/ceph/ceph.conf</code> 并将 fsid 填充进去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">fsid=1dd43550-8165-40b0-b0da-ba34da957a95</span><br><span class="line">mon initial members = storage0, storage1</span><br><span class="line">mon host = 10.0.1.2, 10.0.1.3</span><br><span class="line">public network = 10.0.1.2/24</span><br><span class="line">auth cluster required = cephx</span><br><span class="line">auth service required = cephx</span><br><span class="line">auth client required = cephx</span><br><span class="line">mon allow pool delete = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>创建 mon 节点的 key 值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph-authtool --create-keyring /tmp/ceph.mon.keyring --gen-key -n mon. --cap mon &#x27;allow *&#x27;</span><br><span class="line">ceph-authtool --create-keyring /etc/ceph/ceph.client.admin.keyring --gen-key -n client.admin --cap mon &#x27;allow *&#x27; --cap osd &#x27;allow *&#x27; --cap mds &#x27;allow *&#x27; --cap mgr &#x27;allow *&#x27;</span><br><span class="line">ceph-authtool --create-keyring /var/lib/ceph/bootstrap-osd/ceph.keyring --gen-key -n client.bootstrap-osd --cap mon &#x27;profile bootstrap-osd&#x27; --cap mgr &#x27;allow r&#x27;</span><br></pre></td></tr></table></figure><p>添加生成的 keys 到 <code>ceph.mon.keyring</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph-authtool /tmp/ceph.mon.keyring --import-keyring /etc/ceph/ceph.client.admin.keyring</span><br><span class="line">ceph-authtool /tmp/ceph.mon.keyring --import-keyring /var/lib/ceph/bootstrap-osd/ceph.keyring</span><br></pre></td></tr></table></figure><p>生成 monitor map（这里添加两台机器共同生成 monmap）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monmaptool --create --add storage0 10.0.1.2 --add storage1 10.0.1.3 --fsid 12f276b7-6ff9-4d2b-bac4-a7ac94ac4824 /tmp/monmap</span><br></pre></td></tr></table></figure><p>此时可以运行命令查看生成的 monitor 映射文件，效果大致如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">team-admin@storage0:~$ monmaptool --print /tmp/monmap</span><br><span class="line">monmaptool: monmap file /tmp/monmap</span><br><span class="line">epoch 0</span><br><span class="line">fsid f0141972-922d-42e2-a8a5-13e1e36b1a18</span><br><span class="line">last_changed 2023-03-23T02:31:11.682950+0000</span><br><span class="line">created 2023-03-23T02:31:11.682950+0000</span><br><span class="line">min_mon_release 15 (octopus)</span><br><span class="line">election_strategy: 1</span><br><span class="line">0: v1:10.0.1.2:6789/0 mon.storage0</span><br><span class="line">1: v1:10.0.1.3:6789/0 mon.storage1</span><br></pre></td></tr></table></figure><p>使用 scp 命令将以上几个集群文件拷贝到 storage1 机器上（默认已经设置了 hosts 目录以及免密操作）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp /etc/ceph/ceph.conf storage1:/etc/ceph</span><br><span class="line">scp /etc/ceph/ceph.client.admin.keyring storage1:/etc/ceph</span><br><span class="line">scp /tmp/ceph.mon.keyring storage1:/tmp/ceph.mon.keyring</span><br><span class="line">scp /tmp/monmap storage1:/tmp/monmap</span><br></pre></td></tr></table></figure><p>从后面步骤开始 Storage 1 机器上也要如此运行，首先是激活 monitor daemon（实测不用创建 mon 下文件夹，会自动生成）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-mon --mkfs -i storage0 --monmap /tmp/monmap --keyring /tmp/ceph.mon.keyring --setuser ceph --setgroup ceph</span><br></pre></td></tr></table></figure><p>之后应该可以看到 <code>/var/lib/ceph/mon</code> 下生成了对应的文件夹，然后启动服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ceph-mon@storage0</span><br></pre></td></tr></table></figure><p>运行完成后使用 <code>systemctl status ceph-mon@storage0</code> 命令查看状态，如果状态如下说明服务启动成功<br><img src="../../post-images/image-20230802202334981.png" alt="image-20230802202334981"><br>走完上面几步之后使用 <code>ceph -s</code> 查看集群状态。需要注意的是，如果是在 conf 中已经注明了是多个节点 Mon 的话，需要所有 Mon 节点都启动 Mon 服务之后最终的 ceph 集群服务才能启动，否则运行 <code>ceph -s</code> 会一直卡住。正常如果上面步骤运作成功应该会显示当前集群状态的，如果一直不显示应该就是操作哪里有问题了，需要再调试。最后运行 ceph -s 如果正常出现集群状态则说明集群运行成功。<br>补充两点：</p><ul><li>对于警告提示 <code>1 monitors have not enabled msgr2</code>，运行 <code>ceph mon enable-msgr2</code></li><li>对于警告提示 <code>mons are allowing insecure global_id reclaim</code>，运行如下命令即可<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph config set mon auth_allow_insecure_global_id_reclaim false</span><br></pre></td></tr></table></figure></li></ul><h3 id="b-mgr-添加">b. Mgr 添加</h3><p>以下操作 storage 0 和 storage 1 节点都要执行，节点名字自行修改。首先需要创建密钥目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/lib/ceph/mgr/ceph-mgr0</span><br><span class="line">cd /var/lib/ceph/mgr/ceph-mgr0</span><br></pre></td></tr></table></figure><p>创建身份验证密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph auth get-or-create mgr.storage0 mon &#x27;allow profile mgr&#x27; osd &#x27;allow *&#x27; mds &#x27;allow *&#x27; &gt; keyring</span><br></pre></td></tr></table></figure><p>启动 mgr 守护进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ceph-mgr@mgr0</span><br></pre></td></tr></table></figure><p>使用 <code>systemctl status ceph-mgr@mgr0</code> 查看 Active 为 running 则没有问题</p><h3 id="c-osd-添加">c. OSD 添加</h3><p>首先使用 <code>lsblk</code> 命令查看可以加载的块设备都要哪些，以及设备状态是否有效。如果无效或者需要重新更新后挂载<br>命令如下，其中 ceph 为集群名，<code>/dev/sdb</code> 为机器实际的块存储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-volume --cluster ceph lvm create --data /dev/sdb</span><br></pre></td></tr></table></figure><p>如果上面这步出现报错，可能需要排除是否是之前挂载过或者磁盘有问题，仍然是参考上面提到笔记更新磁盘状态后再次尝试<br>在 storage1 机器上执行时可能会报错提示缺少密钥文件，从 storage0 拷贝密钥然后再次执行即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /var/lib/ceph/bootstrap-osd/ceph.keyring storage1:/var/lib/ceph/bootstrap-osd/ceph.keyring</span><br></pre></td></tr></table></figure><p>最后运行 <code>sudo ceph osd tree</code> 查看 osd 集群状态正常显示即可。<br><img src="../../post-images/image-20230802202559666.png" alt="image-20230802202559666"></p><h3 id="d-mds-添加">d. MDS 添加</h3><p>storage0 和 storage1 都需要操作，首先创建 mds 数据目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/lib/ceph/mds/ceph-mds0</span><br></pre></td></tr></table></figure><p>创建 keyring</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-authtool --create-keyring /var/lib/ceph/mds/ceph-mds0/keyring --gen-key -n mds.mds0</span><br></pre></td></tr></table></figure><p>导入 keyring</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph auth add mds.mds0 osd &quot;allow rwx&quot; mds &quot;allow&quot; mon &quot;allow profile mds&quot; -i /var/lib/ceph/mds/ceph-mds0/keyring</span><br></pre></td></tr></table></figure><p>修改配置文件（两台机器都需要修改，或者自行 scp 复制）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span>mds.mds0<span class="punctuation">]</span></span><br><span class="line">host = mds0</span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>mds.mds1<span class="punctuation">]</span></span><br><span class="line">host = mds1</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ceph-mds@mds0</span><br></pre></td></tr></table></figure><p>查看状态没有问题即可</p><h3 id="e-pool-添加-cephfs-搭建">e. Pool 添加 &amp; CephFS 搭建</h3><p>在创建 fs 之前首先要配置好 mds 服务和两个 pool，一个 pool 存放 object ，另一个存放元数据，可设置较高副本级别，也可调整 pool 的 crush_ruleset 使其在 ssd 上存储，加快客户端响应速度，这里使用默认。这部分具体内容参考链接 7</p><p>创建命令如下，这里两个 <code>pg_num</code> 必须一致否则无法挂载，而对于 pg 数量的计算参考如下公式，注意 <code>pg_num</code> 必须是 2 的整数幂</p><ul><li>集群pg 总数 = （OSD 总数* 100 ）/最大副本数</li><li>每个pool中pg总数=（OSD总数*100）/ 最大副本数 ）/ 池数</li></ul><p>基于以上我们选择 256 作为 <code>pg_num</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[cephfsd@ceph-admin ceph]$ ceph osd pool create cephfs_data 256</span><br><span class="line">pool &#x27;cephfs_data&#x27; created</span><br><span class="line">[cephfsd@ceph-admin ceph]$ ceph osd pool create cephfs_metadata 256</span><br><span class="line">pool &#x27;cephfs_metadata&#x27; created</span><br></pre></td></tr></table></figure><p>接下来创建 fs 并查看创建的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[cephfsd@ceph-admin ceph]$ ceph fs new cephfs cephfs_metadata cephfs_data</span><br><span class="line">new fs with metadata pool 6 and data pool 5</span><br><span class="line">[cephfsd@ceph-admin ceph]$ ceph fs ls</span><br><span class="line">name: cephfs, metadata pool: cephfs_metadata, data pools: [cephfs_data ]</span><br></pre></td></tr></table></figure><p>接下来挂载 cephfs 文件系统，可以在任意客户端上挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建挂载点</span></span><br><span class="line">[cephfsd@ceph-admin ceph]$ mkdir /opt/storage</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去admin主机查看存储秘钥</span></span><br><span class="line">[cephfsd@ceph-admin ceph]$ cat ceph.client.admin.keyring</span><br><span class="line">[client.admin]</span><br><span class="line">    key = AQBIH+ld1okAJhAAmULVJM4zCCVAK/Vdi3Tz5Q==</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将key的值复制下来，保存到客户端，我们这里保存在了/etc/ceph/admin.secret</span></span><br><span class="line">[cephfsd@ceph-admin ceph]$ cat admin.secret</span><br><span class="line">AQBIH+ld1okAJhAAmULVJM4zCCVAK/Vdi3Tz5Q==</span><br></pre></td></tr></table></figure><p>挂载，有两种方式挂载，mount挂载和ceph-fuse挂载，这里选择用内核驱动挂载Ceph文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[cephfsd@ceph-admin ceph]$ mount.ceph 10.0.1.2:6789:/ /mnt/storage -o name=admin,secretfile=/etc/ceph/admin.secret</span><br><span class="line">[cephfsd@ceph-admin ceph]$ df -Th</span><br><span class="line">Filesystem              Type      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs                devtmpfs  484M     0  484M   0% /dev</span><br><span class="line">tmpfs                   tmpfs     496M     0  496M   0% /dev/shm</span><br><span class="line">tmpfs                   tmpfs     496M   26M  470M   6% /run</span><br><span class="line">tmpfs                   tmpfs     496M     0  496M   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root xfs        46G  1.9G   44G   4% /</span><br><span class="line">/dev/sda1               xfs       497M  130M  368M  26% /boot</span><br><span class="line">tmpfs                   tmpfs     100M     0  100M   0% /run/user/0</span><br><span class="line">10.0.1.2:6789:/   ceph      8.5G     0  8.5G   0% /opt</span><br></pre></td></tr></table></figure><p>以上便是 Ceph 源码编译之后使用原生命令部署集群之后挂载文件系统的全部过程了，关于后面的使用细节后面再添加整理吧</p><hr><h2 id="3-参考链接">3. 参考链接</h2><ol><li><a href="https://docs.ceph.com/en/latest/install/build-ceph/">Build Ceph — Ceph Documentation</a><br>参考这个来进行整体的安装，注意是 clone 源码进行的</li><li><a href="https://docs.ceph.com/en/latest/install/install-storage-cluster/#installing-a-build">Install Ceph Storage Cluster — Ceph Documentation</a><br>最后安装成功后的可执行文件位置是在 <code>usr/local/bin</code>，可以将 <code>ceph.conf</code> 文件放置在这从而启动一个 cluster</li><li><a href="https://github.com/ceph/ceph#building-ceph">ceph/ceph: Ceph is a distributed object, block, and file storage platform (github.com)</a><br>执行编译安装命令时注意添加部分参数，这里有简单提到可以加哪些参数，有的参数可以指定安装位置</li><li><a href="https://docs.ceph.com/en/latest/dev/dpdk/#">Ceph messenger DPDKStack — Ceph Documentation</a></li><li><a href="https://unix.stackexchange.com/questions/328016/fuse-is-installed-but-compiler-is-saying-no-package-fuse-found">linux - fuse is installed but compiler is saying &quot;no package ‘fuse’ found - Unix &amp; Linux Stack Exchange</a></li><li><a href="https://www.jianshu.com/p/1df2b742e686">源码搭建ceph集群 - 简书 (jianshu.com)</a></li><li><a href="https://www.cnblogs.com/doublexi/p/15619060.html">cephfs文件系统场景 - doublexi - 博客园 (cnblogs.com)</a></li><li>[手动部署ceph octopus集群 - 腾讯云开发者社区-腾讯云 (<a href="http://tencent.com">tencent.com</a>)](<a href="https://cloud.tencent.com/developer/article/1782762">https://cloud.tencent.com/developer/article/1782762</a></li><li><a href="https://docs.ceph.com/en/quincy/install/manual-deployment/">Manual Deployment — Ceph Documentation</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> ceph </tag>
            
            <tag> 服务器运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity 学习笔记 0 - 动机 &amp; 环境 &amp; 坐标系 &amp; 生命周期函数</title>
      <link href="/posts/Unity/20230729-unity-learning-note-0.html"/>
      <url>/posts/Unity/20230729-unity-learning-note-0.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-动机">0. 动机</h2><p>进入 5 月份之后各种各样的新闻很多，其中特别吸人眼球的无外乎苹果刚出的 Vision Pro 眼镜。作为半个果粉自然是心向往之，这次更甚，居然萌生了参与其中开发的想法。顿时感觉仿佛发现了一片蓝海，进入了另一条赛道。（毕竟直到 7 月份底为止一直没有人拿到真机进行测试开发，更何况进行 VR 应用的开发呢。想当年 iphone 刚出时，各种各样的应用层出不穷，苹果开发者趋之若鹜，早入行者也捞了不知几桶金了。闲话说到这，那和 Unity 有什么关系呢？<br>主要原因在于苹果这次官宣和 Unity 进行合作来开发运行在 Vision Pro 上的 3D 应用，据我了解目前行业里只有 Unreal Engine 和 Untiy 两家 3D 引擎公司独大，这次合作无异于宣布了未来 Unity 可能成为未来 3D 应用开发的主流。虽然目前谷歌以及 Meta 售卖的 AR 眼镜并没有绑定某个平台进行创作，更多的是开放自己的 SDK 后由开发者后期来做集成。之前只是听过 UE4 的大名，了解业内用其制作了挺多的仿真器和游戏模拟以及影视创作，但 Unity 的应用却没有听说多少。而且 Unity 是使用 C# 开发，这也是一直劝退我的原因。<br>抱着试试看的态度，快速过完了苹果发布的 Vision Pro 的开发教程，然后迅速安装了 Unity ，在我的 Macbook Pro 2019 上。安装时确实有点犹豫，看过一些分享和评论说 Unity 很吃显卡性能。但想到只是试试看，目前顶多开发一个 2D 游戏玩玩看，应该也用不了多少性能。目前看起来也确实，只有运行时候风扇会疯狂转，其余时间还是挺安静的。当然，有条件还是建议配 Windows 开发吧，一步到位比较好。</p><hr><h2 id="1-环境">1. 环境</h2><p>关于 Unity 最新版在 MacBook 上的安装配置，实测并没有踩多少坑，所以这里也不展开记录了。我这边是先安装的 Unity Hub，然后登录用户选择 Unity 版本之后自动进行安装。整个安装完空间大约要要 20G 左右吧，仅最基本的配置。<br>安装完成后的开发，网上绝大多数以及官方建议都是使用 VS 来进行，使用了几天没有感觉什么不适，联调也挺方便。不过因为长期使用 VS Code 的关系，更倾向于使用它来进行开发。从网上查找了一些资料，按照步骤安装了一些插件之后，基本实现了协同开发。在 VS Code 下进行代码编写之后，跳转到 Unity 下会自动加载代码，然后直接运行即可。唯一不适的可能是 Unity 中关键词的高亮和提示，比如 transform 之类。虽然安装了相关插件但仍然存在无法高亮的问题，无奈先暂时放下。</p><hr><h2 id="2-基本实现">2. 基本实现</h2><p>对于入门学习，我选择了 B 站上一门 2D 坦克大战小游戏的制作来开始，见参考链接 1。老师讲得的很耐心，废话不多很直接，手把手实现了游戏基本功能的所有逻辑，使用 C# 编写脚本。课程也提供了相应的图片和声音素材，制作过程中成就感还是蛮高的，能够了解和熟悉童年游戏的每一步实现，还是挺有意思的。里面具体实现细节不再一一展开，仅借整理笔记机会简单做下复盘记录📝相关思考后面方便查看。</p><p><img src="../../post-images/image-20230729152338212.png" alt="image-20230729152338212|1300"></p><h3 id="a-基本逻辑">a. 基本逻辑</h3><p>制作游戏的第一步一般都是要先导入图片资源，同时合理地设置文件夹的目录结构。大致分为以下几个部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Animation// 存放动画对象</span><br><span class="line">├── AnimationController// 存放动画对象的控制器</span><br><span class="line">├── GameResource          // 存放游戏制作需要的静态资源</span><br><span class="line">├── Prefabs               // 存放制作好的预制体（prefab），可以理解为被操作的游戏对象，可以添加一系列相关的属性和功能</span><br><span class="line">├── Scenes// 存放游戏场景，比如游戏开始画面，游戏画面以及游戏结束画面等</span><br><span class="line">├── Scripts// 存放所有控制游戏相关脚本，如整个游戏的逻辑，游戏对象的控制等</span><br></pre></td></tr></table></figure><p>具体细节有太多文档可以查看，这里仅简单记录作为初学者我自己的理解和思考。在我跟的这个教程中，老师是从预制体（prefab）的制作开始，完成一个个预制体的功能之后，再在其上将他们组合成场景，简单说就是从微观到宏观。预制体应该是整个游戏制作中极其重要的部分，按照我的理解 Unity 游戏制作的根本就是构建和组合这些预制体从而完成目标功能。”游戏引擎“这个概念我也是学习过程中逐渐理解，直观上看 Unity 只是编排各种游戏素材和场景，但实际上每个游戏素材背后都是游戏引擎在支撑实现。举个最简单的例子🌰，坦克撞上墙，是不能直接穿过的，那其中的逻辑如何实现呢。这里可以引出 Unity 中最常见的 Box Collider 属性，它可以自动帮你执行碰撞检测（需要注意 2D 和 3D 的区别）。如下图所示<br><img src="../../post-images/image-20230729152310652.png" alt="image-20230729152310652|700"></p><p>设想如果用纯 Python 来实现两个方形物体的碰撞检测，该有多复杂。同理如重力，弹跳以及武器击打，天气等，背后都有引擎在支撑实现。因此对于一个游戏来说，引擎的性能优劣直接影响到玩家的体验。</p><h3 id="b-坐标系">b. 坐标系</h3><p>在开发过程中参考别人的代码来实现自己的功能，但对于坐标系变换终归不得其解，期间遇到一位好友一起交流意外被点醒理解了不少。在此基础之上参考链接 5 的视频进行整理汇总，才算是有了阶段性的成果吧，总结笔记如下。</p><p>首先 Unity 中只有如下四种坐标系，其他名称都是这四种坐标系的别名，这里把可能得叫法统一整理出来</p><ul><li>世界坐标系（全局坐标、左手坐标、绝对坐标)</li><li>局部坐标系（物体坐标、本地坐标、相对坐标)</li><li>屏幕坐标系（像素坐标）</li><li>视口坐标系（视窗坐标）</li><li>GUI坐标系</li></ul><p>首先世界坐标系和局部坐标系，对于在 Scene 根目录下新建的任何 GameObject，当没有父物体时其世界坐标系和局部坐标系就是相同的，即其 Transform componet 的 Position 属性都是局部坐标。所以如果给它添加一个父物体，当父物体坐标位置发生改变时，是不会影响子物体的 Transform.Position 属性的，但子物体的世界坐标位置是受到父物体的影响的<br>其次来说屏幕坐标系，是长这个样子的<br><img src="../../post-images/image-20230807202326292.png" alt="image-20230807202326292|500"></p><p>坐标系的原点位置位于屏幕的左下角，可以通过 <code>Screen.width</code> 和 <code>Screen.height</code> 来获取当前屏幕的宽高，其 x 和 y 的方向如图所示。另外，可以通过 <code>Input.mousePosition</code> 打印出当前鼠标位置，即鼠标位置是基于视口坐标系的。<br>再来说下视口坐标系(Viewport)，如下图可以看到，它其实是屏幕坐标系的归一化，这里不再细说，后面会提到其如何与屏幕坐标系之间进行变换。<br><img src="../../post-images/image-20230807202548799.png" alt="image-20230807202548799|500"></p><p>最后来说下 GUI 坐标系，其实它主要是服务于 2D 平面下 GUI 组件的显示的，如添加显示框啊，文字啊等等。如可以通过如下代码来实现文字在 GUI 界面的显示（<code>OnGUI()</code>也是官方提供的，每次刷新一次）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Camera camera_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span> </span><br><span class="line">&#123;</span><br><span class="line">  GUI.contentColor = Color.black;</span><br><span class="line">  GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">20</span>), <span class="string">&quot;世界坐标&quot;</span> + transform.position)；</span><br><span class="line">  GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">20</span>), <span class="string">&quot;局部坐标&quot;</span> + transform.localPosition);</span><br><span class="line">  GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">20</span>), <span class="string">&quot;屏幕宽高&quot;</span> + Screen.width + <span class="string">&quot;x&quot;</span> + Screen.height);      </span><br><span class="line">  GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10</span>, <span class="number">70</span>, <span class="number">200</span>, <span class="number">20</span>), <span class="string">&quot;鼠标位置&quot;</span> + Input.mousePosition);</span><br><span class="line">  GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10</span>, <span class="number">90</span>, <span class="number">200</span>, <span class="number">20</span>), <span class="string">&quot;鼠标位置(视口坐标)&quot;</span> + camera_.ScreenToViewportPoint(Input.mousePosition));         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../post-images/image-20230807204043988.png" alt="image-20230807204043988|426"></p><p>讲完了以上的几种坐标系，下面来说下如何实现他们之间彼此的转换。这里注意相关实现的 API 都要用官方提供的 Camera 类型来实现，即定义类似 <code>public Camera camera_;</code> 这样的变量来进行相关转换函数的调用。<br>世界和屏幕互转</p><ul><li>屏幕转世界 -&gt; <code>Camera.ScreenToViewportPoint(Vector3 Pos);</code></li><li>世界转屏幕 -&gt; <code>Camera.WorldToScreenPoint(Vector3 Pos);</code><br>世界和视口互转</li><li>世界转视口 -&gt; <code>Camera.WorldToViewportPoint(Vector3 Pos);</code></li><li>视口转世界 -&gt; <code>Camera.ViewportToWorldPoint(Vector3 Pos);</code><br>屏幕和视口互转</li><li>屏幕转视口 -&gt; <code>Camera.ScreenToViewportPoint(Vector3 Pos);</code></li><li>视口转屏幕 -&gt; <code>Camera.ViewportToScreenPoint(Vector3 Pos);</code><br>世界坐标与局部坐标互转</li><li>世界转局部 -&gt; <code>transform.InverseTransformPoint(Vector3 Pos);</code> 或 <code>transform.worldToLocalMatrix</code></li><li>局部转世界 -&gt; <code>transform.TransformPoint(Vector3 Pos);</code> 或 <code>transform.localToworldMatrix</code><br>对于屏幕转世界补充下，由于屏幕的三维坐标系的 z 轴是没有值的，所以如果直接进行转换的话得到的值其实是相机的位置。举例如果想准确地把一个鼠标位置得到一个世界位置的话，必须赋予 z 轴深度才行，如果没有这个深度信息的话是无法将二维坐标映射到三维空间上的。<br>另外需要注意的是，自身坐标系并不是局部坐标系，自身坐标系是一个隐藏的东西，其实是相对于自身的一个坐标系，而局部坐标系是相对于父物体的。</li></ul><h3 id="c-常用生命周期函数">c. 常用生命周期函数</h3><blockquote><p>主要参考链接 6 进行学习和记录笔记</p></blockquote><p>一个脚本必须绑定在游戏对象上才能被调用，才能开始这个 GameObject 的生命周期，直到因为触发某个逻辑被销毁时才结束它的生命周期。期间可能依次调用了 Awake, Start, OnDestroy 等生命周期函数，也可能一直循环执行 Update 或 FixedUpdate 等生命周期函数。</p><p>常用的生命周期函数如下：</p><ul><li><code>Reset()</code> -&gt; 此函数会在用户首次添加该组件时或单击 Component <strong>Reset</strong> 按钮时被调用，且<strong>只在编辑器生效</strong>。其常应用于在编辑器内通过代码大批量生成修改 GameObject，来代替手工操作。</li><li><code>Awake()</code> -&gt; 此函数在脚本实例被载入时调用，<strong>仅被调用一次</strong>。</li><li><code>Start()</code> -&gt; 在 Awake() 之后和 Update() 之前被调用，<strong>仅被调用一次</strong>；</li><li><code>FixedUpdate()</code> -&gt; 物理更新函数，循环执行，0.02s 执行一次（不受 FPS 帧率影响，时间可更改），所以和物理相关的更新都应在此函数处理（比如刚体运动）；</li><li><code>Update()</code> -&gt; 更新函数，每帧执行一次，受 FPS 帧率影响；</li><li><code>LateUpdate()</code> -&gt; 稍后更新函数，在所有 Update 执行完后调用，帧间隔时间和 Update 一样；</li><li><code>OnGUI()</code> -&gt; 在渲染和处理 GUI 事件时被调用，每帧都执行；</li><li><code>OnEnable()</code> -&gt; 当脚本被启用时调用一次，当游戏对象被禁用时，仅监听响应此函数；</li><li><code>OnDisable()</code> -&gt; 当脚本被禁用时调用一次，当脚本反复被禁用或启用，则反复调用 OnDisable 和 OnEnable;</li><li><code>OnDestroy()</code> -&gt; 当脚本被销毁时被调用，只会在被激活的物体上调用；</li></ul><p>对于这些生命周期函数之间的关系，在教程中只提到了如下三个区别</p><ul><li><strong>Awake 和 Start 的区别</strong>：在同一个游戏场景中可能存在若干个 GameObject，若每个 GameObject 都存在 Awake 和 Start 函数时，必定先执行所有 GameObject 的 Awake 函数，然后再执行 Start 函数，此时执行顺序是乱序的。推荐使用 Awake 创建游戏对象，Start 来获取对象，这样可以保证不会空指针报错。<br>还有一点需要注意的是，Awake 函数是脚本作为 Component 添加之后就会被调用（载入），无论是否选中 Active。而 Start 函数只有脚本被实例化时才会被调用，也就是说脚本 Component 必须是 Active 状态时才会被执行。</li><li><strong>Update 和 FixedUpdate 的区别</strong>：不同机器甚至同一机器不同时刻每帧执行所用的时间都是不一样的，取决于机器性能等各种因素。因此在可以看到 Update 函数执行时间间隔并不是相同的，这样物体运动的动作会显的不稳定。而 FixedUpdate() 函数则于机器性能没有关系，执行的时间间隔是相同的，这对于刚体运动执行刷新来说尤为重要。<br>FixedUpdate 固定时间修改位置：Edit -&gt; Project Setting -&gt; Time -&gt; Fixed TimeStep<br>最先执行的一定是 FixedUpdate，最后执行的一定是 LateUpdate.</li><li>禁用、启用、销毁的区别：<ul><li>物体被禁用时，Start 不会被执行，Awake 仍然会被执行。当物体反复禁用启用时，Awake 和 Start 也仅执行一次；</li><li>OnEnable 和 OnDisable 随着游戏对象的禁用启用而被调用；</li><li>当程序退出时，若对象处于启用状态，则程序会先禁用(调用 OnDisable)，再销毁(调用 OnDestroy)；</li></ul></li></ul><p><img src="../../post-images/image-20230809202106342.png" alt="image-20230809202106342|700"></p><hr><h2 id="参考链接">参考链接</h2><ol><li><a href="https://www.bilibili.com/video/BV1PW41197Su/">【siki学院】Unity3D - Unity基础案例-教你如何做一个你儿时肯定玩过的坦克大战游戏【已完结】_哔哩哔哩_bilibili</a></li><li><a href="https://www.cnblogs.com/linzheng/p/3979971.html">Unity2D]坐标体系 - linzheng - 博客园 (cnblogs.com)</a></li><li><a href="https://docs.unity3d.com/cn/2018.2/Manual/QuaternionAndEulerRotationsInUnity.html">Unity 中的旋转和方向 - Unity 手册 (unity3d.com)</a></li><li><a href="https://blog.csdn.net/qq_27719553/article/details/118571637">(152条消息) unity中的四元数，欧拉角，方向向量之间的相互转换方法。_转换欧拉角 向量_Mansutare的博客-CSDN博客</a></li><li><a href="https://www.bilibili.com/video/BV1ES4y1i7H6/">【详解Unity】各种坐标系 | 世界坐标 | 屏幕坐标 | UI坐标_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1SB4y1X7X6/">【详解Unity】生命周期函数| Awake | Start | Update_哔哩哔哩_bilibili</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 经验总结 </tag>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 中文件校验功能实现</title>
      <link href="/posts/System-development/20230309-vue-file-header-check.html"/>
      <url>/posts/System-development/20230309-vue-file-header-check.html</url>
      
        <content type="html"><![CDATA[<h2 id="main">Main</h2><p>关于 MP4 的实际检测头可以查看参考链接 3，但实际测试时 MP4 的 header 却不是链接中所说 00 00 00 18 66 74 79 70，而是 00 00 00 20 66 74 79 70，后面可能需要再排查下原因。<br>主要参考链接 1 ，过程中遇到了几个比较迷惑的问题。解决后测试上传改过后缀的 TXT 文件能够识别出来非 MP4 文件并实现过滤。<br>过程中需要反复加 log 打印输出调试，代码中可以添加如下语句进行调试。然后打开浏览器的 Developer Tools 控制台的 Console 部分，实际运行时便可以看到输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Test is&quot;</span>, test)</span><br></pre></td></tr></table></figure><h3 id="1-async-以及-await-的使用">1. async 以及 await 的使用</h3><p>根据参考链接中代码，第一次在 Vue 中使用异步，晕了半天。这里主要参考链接 5 ，简单总结如下几条使用注意：</p><ul><li><code>await</code> 语法只能在 <code>async</code> 函数中使用，其他普通函数无法使用；</li><li>async function 和普通的 Vue 函数声明方式不同，大致如下</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,  <span class="comment">// es5写法</span></span><br><span class="line">    <span class="title function_">name</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// es6写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>async function 不能像普通函数一样调用，<code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数，参考链接 5 其调用实现如下</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><h2 id="bugs">Bugs</h2><h3 id="1-file-type-fromfile-无效-passed">1. File-type  fromFile 无效（Passed）</h3><p>参考该链接 <a href="https://developer.aliyun.com/article/1012700">Node.js：file-type检测文件类型-阿里云开发者社区 (aliyun.com)</a> 测试无效，输出打印如下<br><img src="../../post-images/1678364198536.png" alt="|500"></p><h3 id="2-typeerror-failed-to-execute-readasdataurl-on-filereader-问题-solved">2. TypeError: Failed to execute ‘readAsDataURL’ on ‘FileReader’ 问题（Solved）</h3><p>实现过程中遇到如上问题，根据参考链接 4 解决，将原本代码中的 file 改为 <code>file.raw</code> 即可。</p><h3 id="3-uncaught-typeerror-e-slice-is-not-a-function-问题-solved">3. Uncaught TypeError: e.slice is not a function 问题（Solved）</h3><p>解决方法同问题 2，将原本代码中的 file 改为 <code>file.raw</code>。</p><h3 id="4-vue-el-upload-设置-auto-upload-为-false-时-before-upload-调用会失效-caution">4. Vue el-upload 设置 auto-upload 为 false 时 before-upload 调用会失效（Caution）</h3><p>具体查看参考链接 <a href="https://blog.csdn.net/qq_38633651/article/details/85167082">(113条消息) element upload before-upload 不起作用_element before-upload 无法阻止继续请求_见证小白的成长的博客-CSDN博客</a><br>务必注意此处问题，否则调试会特别麻烦。此时只能在<code>on-change</code>的实现中对文件进行限制</p><h2 id="reference">Reference</h2><ol><li><a href="https://developer.aliyun.com/article/1170341">vue 里怎么通过魔数（magic number）去限制上传文件类型？-阿里云开发者社区 (aliyun.com)</a></li><li><a href="https://github.com/jealyn/real-file-type">jealyn/real-file-type: JS 精准获取上传文件类型 (github.com)</a></li><li><a href="https://www.cnblogs.com/miaosj/p/10676677.html?spm=a2c6h.12873639.article-detail.4.166d448d6xIKRv">文件头标志大全 - 苗士军 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.cnblogs.com/ABKing/p/12445229.html">[Vue warn]: Error in v-on handler: “TypeError: Failed to execute ‘readAsDataURL’ on ‘FileReader’: parameter 1 is not of type ‘Blob’.” - ABKing - 博客园 (cnblogs.com)</a></li><li>[Vue-重温async和await的用法 - 掘金 (<a href="http://juejin.cn">juejin.cn</a>)]</li></ol>]]></content>
      
      
      <categories>
          
          <category> System-development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Veins Module 浅析4 -- BasePhyLayer 外部报文处理逻辑简析</title>
      <link href="/posts/Omnet-Veins/20221103-veins-basephylayer-initially-learn.html"/>
      <url>/posts/Omnet-Veins/20221103-veins-basephylayer-initially-learn.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在 Veins 中 node 之间使用 AirFrame 来传递 message，在仿真过程中模块并不能像现实生活那样因为信道干扰或障碍物遮挡造成报文延时或丢失。在 Omnet++ 中虽然可以控制接收间隔之类，但在 config 文件中只能比较死板地进行设置，不能根据程序参数和运行状态灵活地调整。因此在 Veins 中实际接收报文操作是先接收，走各种逻辑进行判断，之后再利用 Omnet 的机制通过其架构控制的延时操作来完成最终的接收。也因此，在报文中会包含各种信道信息、发送接收位置信息以及信号强度信息等，都是为了方便在接收逻辑中进行判断，从而模拟比较真实的通信环境。</p><p>BasePhyLayer 中接收 AirFrame 分了三步（StartReceive，Receiving，EndReceive），这几步可以理解成为了模拟实际通信环境而进行的预处理逻辑，实际处理中 Decider 承担主要部分，并且 channel，radio 以及 analogueModel 也都参与其中。中间与 Mac 层和 Decider 模块的交互都是通过父类的 Interface 被继承然后派生，最后动态绑定指针来执行的（按C++ 就是，各类 Interface 处理函数如 Decider 和 Mac 都是虚基类，由 BasePhyLayer 派生后实现，然后根据实际调用用父类指针指向子类对象从而调用其定义的接口函数）。</p><p>大致分为两个部分进行判断</p><ul><li>Channel：在 ChannelInfo 类中进行判断</li><li>Signal：计算传输距离，使用衰落模型进行 filter，</li></ul><p>最后在 handleAirFrame Receiving 操作中由 Decider 模块决定是否接收并上传到 Mac 层</p><hr><h2 id="一-handleairframe-部分工作">一、handleAirFrame 部分工作</h2><p>这部分没有在 PhyLayer80211p 中进行派生，因此也是处理 AirFrame 的主逻辑。</p><p><strong>StartReceive 部分工作</strong></p><ul><li><p>Channel add AirFrame</p></li><li><p>Filter signal：提取出 Frame 中的 signal 并配置其起始终止点以及 analogueModel，从而对 signal 进行 filter。</p><p>这里是调用了所有 analogueModel 来进行 filter，也就是说衰落是可以叠加的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go on with AnalogueModels</span></span><br><span class="line"><span class="comment">// attach analogue models suitable for thresholding to signal (for later evaluation)</span></span><br><span class="line">signal.<span class="built_in">setAnalogueModelList</span>(&amp;analogueModelsThresholding);</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply all analouge models that are *not* suitable for thresholding now</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; analogueModel : analogueModels) &#123;</span><br><span class="line">    analogueModel-&gt;<span class="built_in">filterSignal</span>(&amp;signal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>之后根据 decider 的状态以及 protocol 的类型进行判断，如果不符合条件则在一段时间之后进行丢弃。</p><p>这里之所以需要调用 handleSelfMessage 从而实现过一段时间才丢弃，原因开头也提到了，是因为虽然我们程序中接收到了 frame，但模拟的现实环境中报文其实还没有到达的。因此这里才需要加上一个 <code>frame-&gt;getDuration()</code>时间来计算其真实的到达时间，从而在那个时间再作丢弃，也就算模拟了现实环境中报文到达后再丢弃的场景。</p></li></ul><p><strong>Receiving 部分工作</strong></p><ul><li><p>调用 decider 模块进行处理，跳转到 decider interface 函数进行处理（这里传递的仍然是 frame 而非 signal）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">simtime_t</span> <span class="title">BaseDecider::processSignal</span><span class="params">(AirFrame* frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT</span>(frame);</span><br><span class="line">    EV_TRACE &lt;&lt; <span class="string">&quot;Processing AirFrame...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">getSignalState</span>(frame)) &#123;</span><br><span class="line">    <span class="keyword">case</span> NEW:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">processNewSignal</span>(frame);</span><br><span class="line">    <span class="keyword">case</span> EXPECT_HEADER:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">processSignalHeader</span>(frame);</span><br><span class="line">    <span class="keyword">case</span> EXPECT_END:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">processSignalEnd</span>(frame);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">processUnknownSignal</span>(frame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能大致是提取其中的 signal power 来判断其强度是否可以接收，以及信道是否存在冲突。当存在冲突信号实际的接收时间可能会延时，因此这里再返回一个 simtime 时间辅助后面判断是否可以接收，此时如果 nextHandleTime &lt; 0 则认为该报文已经丢失了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">simtime_t</span> nextHandleTime = decider-&gt;<span class="built_in">processSignal</span>(frame);</span><br><span class="line">··</span><br><span class="line"><span class="comment">// smaller zero means don&#x27;t give it to me again</span></span><br><span class="line"><span class="keyword">if</span> (nextHandleTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   nextHandleTime = signalEndTime;</span><br><span class="line">   frame-&gt;<span class="built_in">setState</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(AirFrameState::end_receive));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// invalid point in time</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EV_TRACE &lt;&lt; <span class="string">&quot;Handed AirFrame with ID &quot;</span> &lt;&lt; frame-&gt;<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; to Decider. Next handling in &quot;</span> &lt;&lt; nextHandleTime - <span class="built_in">simTime</span>() &lt;&lt; <span class="string">&quot;s.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sendSelfMessage</span>(frame, nextHandleTime);</span><br></pre></td></tr></table></figure><p>反之如果大于 0 则等待一段时间后重新走一遍 handleAirFrame 的流程。</p></li></ul><p><strong>EndReceive 部分工作</strong></p><ul><li><p>到这步就基本完成了接收了，剩下的就是就是恢复下信道和一些处理时状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BasePhyLayer::handleAirFrameEndReceive</span><span class="params">(AirFrame* frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EV_TRACE &lt;&lt; <span class="string">&quot;End of Airframe with ID &quot;</span> &lt;&lt; frame-&gt;<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">simtime_t</span> earliestInfoPoint = channelInfo.<span class="built_in">removeAirFrame</span>(frame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean information in the radio until earliest time-point</span></span><br><span class="line"><span class="comment">     * of information in the ChannelInfo,</span></span><br><span class="line"><span class="comment">     * since this time-point might have changed due to removal of</span></span><br><span class="line"><span class="comment">     * the AirFrame</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (channelInfo.<span class="built_in">isChannelEmpty</span>()) &#123;</span><br><span class="line">        earliestInfoPoint = <span class="built_in">simTime</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在 **StartReceive **过程中也简单地对报文进行了下过滤，如果 decider 无效或者报文非已知协议的话则延时丢掉（修改 frame 状态后利用 <code>handleSelfMessage </code>函数处理掉）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (decider &amp;&amp; <span class="built_in">isKnownProtocolId</span>(frame-&gt;<span class="built_in">getProtocolId</span>())) &#123;</span><br><span class="line">   frame-&gt;<span class="built_in">setState</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(AirFrameState::receiving));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// pass the AirFrame the first time to the Decider</span></span><br><span class="line">   <span class="built_in">handleAirFrameReceiving</span>(frame);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// if no decider is defined we will schedule the message directly to its end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   Signal&amp; signal = frame-&gt;<span class="built_in">getSignal</span>();</span><br><span class="line"></span><br><span class="line">   <span class="type">simtime_t</span> signalEndTime = signal.<span class="built_in">getReceptionStart</span>() + frame-&gt;<span class="built_in">getDuration</span>();</span><br><span class="line">   frame-&gt;<span class="built_in">setState</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(AirFrameState::end_receive));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">sendSelfMessage</span>(frame, signalEndTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-decider-模块">二、Decider 模块</h2><h3 id="1-基本功能">1. 基本功能</h3><p>其功能在 <a href="http://Decider.cc">Decider.cc</a> 文件注释写的还算比较清楚，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* The Deciders tasks are:</span><br><span class="line">* <span class="number">1.</span>    <span class="function">decide which packets should be handed up to the MAC <span class="title">Layer</span> <span class="params">(primary task)</span></span></span><br><span class="line"><span class="function">* 2.    decide whether the channel is busy/idle at a time point <span class="keyword">or</span> during a time <span class="title">interval</span> <span class="params">(channel sensing)</span></span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function">* BasePhyLayer hands every receiving AirFrame several times to the &quot;<span class="title">processSignal</span><span class="params">()</span>&quot;-function <span class="keyword">and</span> is returned a time point when to <span class="keyword">do</span> so again.</span></span><br></pre></td></tr></table></figure><p>在 Decider 模块中定义了 <code>currentSignal </code>变量，用了跟踪当前处理报文的状态，并在初始时设置为 NEW。其具体定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @brief The current state of processing for a signal*/</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SignalState</span> &#123;</span><br><span class="line">    <span class="comment">/** @brief Signal is received the first time. */</span></span><br><span class="line">    NEW,</span><br><span class="line">    <span class="comment">/** @brief Waiting for the header of the signal. */</span></span><br><span class="line">    EXPECT_HEADER,</span><br><span class="line">     <span class="comment">/** @brief Waiting for the end of the signal. */</span></span><br><span class="line">    EXPECT_END,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief Pair of a AirFrame and the state it is in. */</span></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;AirFrame*, <span class="type">int</span>&gt; ReceivedSignal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief pointer to the currently received AirFrame */</span></span><br><span class="line">ReceivedSignal currentSignal;</span><br></pre></td></tr></table></figure><h3 id="2-处理逻辑">2. 处理逻辑</h3><p>下面是 Decider 模块最主要的 State Machine，针对 signal 进行一系列判断逻辑。类似于 handleAirFrame，只是是用 <code>currentSignal</code> 来将每个部分串起来。这个部分最后返回一个 time point 告知下次处理的时间（returned a time point when to do so again）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">simtime_t</span> <span class="title">BaseDecider::processSignal</span><span class="params">(AirFrame* frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT</span>(frame);</span><br><span class="line">    EV_TRACE &lt;&lt; <span class="string">&quot;Processing AirFrame...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">getSignalState</span>(frame)) &#123;</span><br><span class="line">    <span class="keyword">case</span> NEW:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">processNewSignal</span>(frame);</span><br><span class="line">    <span class="keyword">case</span> EXPECT_HEADER:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">processSignalHeader</span>(frame);</span><br><span class="line">    <span class="keyword">case</span> EXPECT_END:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">processSignalEnd</span>(frame);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">processUnknownSignal</span>(frame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Process 部分在 Veins 中有新的子类（Decider80211p）实现（processNewSignal 和 processSignalEnd），下面以 BaseDecider 举例说明下这几个步骤</p><p>**<code>processNewSignal</code><strong>​</strong> **</p><ul><li><p>处理 new signal 时并没有绑定 frame，因此在最开始时要进行 frame 有效判断</p></li><li><p>进行 <code>minPowerLevel</code> 判断，满足要求后将其绑定到 currentSignal 上。这里的 minPowerLevel 设定大小为 0，即最低的 noise floor；</p><p>在 Decider80211p 中扩展了这一判断，使用 CCA (Clear Channel Assessment，空闲信道判断），就如注释所说 *a superposition of low power frames might turn channel status to busy *</p><p>关于 CCA 算法如何应用的，整理到 ((20221026215403-womm01e ‘CCA 实现细节’))</p></li><li><p>信道状态置位，这里调用 <code>setChannelIdelStatus</code> 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Decider80211p::setChannelIdleStatus</span><span class="params">(<span class="type">bool</span> isIdle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isChannelIdle = isIdle;</span><br><span class="line">    <span class="keyword">if</span> (isIdle)</span><br><span class="line">        phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;ChannelStatus&quot;</span>, Mac80211pToPhy11pInterface::CHANNEL_IDLE));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;ChannelStatus&quot;</span>, Mac80211pToPhy11pInterface::CHANNEL_BUSY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 Decider80211p 中还额外对 Radio 的 Status 进行了判断，当 Radio 处于 TX 状态时暂时不能发送</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (phy11p-&gt;<span class="built_in">getRadioState</span>() == Radio::TX) &#123;</span><br><span class="line">    frame-&gt;<span class="built_in">setBitError</span>(<span class="literal">true</span>);</span><br><span class="line">    frame-&gt;<span class="built_in">setWasTransmitting</span>(<span class="literal">true</span>);</span><br><span class="line">    EV_TRACE &lt;&lt; <span class="string">&quot;AirFrame: &quot;</span> &lt;&lt; frame-&gt;<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; recvPower &lt;&lt; <span class="string">&quot;) received, while already sending. Setting BitErrors to true&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及进行了 <code>currentSignal</code>有效性的判断，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!currentSignal.first) &#123;</span><br><span class="line">   <span class="comment">// NIC is not yet synced to any frame, so lock and try to decode this frame</span></span><br><span class="line">   currentSignal.first = frame;</span><br><span class="line">   EV_TRACE &lt;&lt; <span class="string">&quot;AirFrame: &quot;</span> &lt;&lt; frame-&gt;<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; with (&quot;</span> &lt;&lt; recvPower &lt;&lt; <span class="string">&quot; &gt; &quot;</span> &lt;&lt; minPowerLevel &lt;&lt; <span class="string">&quot;) -&gt; Trying to receive AirFrame.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   <span class="keyword">if</span> (notifyRxStart) &#123;</span><br><span class="line">       phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;RxStartStatus&quot;</span>, MacToPhyInterface::PHY_RX_START));</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// NIC is currently trying to decode another frame. this frame will be simply treated as interference</span></span><br><span class="line">    EV_TRACE &lt;&lt; <span class="string">&quot;AirFrame: &quot;</span> &lt;&lt; frame-&gt;<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; with (&quot;</span> &lt;&lt; recvPower &lt;&lt; <span class="string">&quot; &gt; &quot;</span> &lt;&lt; minPowerLevel &lt;&lt; <span class="string">&quot;) -&gt; Already synced to another AirFrame. Treating AirFrame as interference.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 else 的判断不是很理解，留个坑后面再填吧。</p></li></ul><p>**<code>processSignalHeader</code><strong>​</strong> **</p><ul><li><p>目前官方没有实现，在 processNewSignal 处理成功后直接置位 signal 为 <code>EXPECT_END</code> 从而跳转到 <code>processSignalEnd</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Processes the end of the header of a received Signal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the time it wants to handle the signal again.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Default implementation does not handle signal headers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">simtime_t</span> <span class="title">processSignalHeader</span><span class="params">(AirFrame* frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">cRuntimeError</span>(<span class="string">&quot;BaseDecider does not handle Signal headers!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> notAgain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>**<code>processSignalEnd</code><strong>​</strong> **</p><ul><li><p>到这步就算接收成功，直接向上发送 frame，同时重新置位 <code>currentSignal</code> 和 <code>ChannelIdleStatus</code>。下面的例子是 BaseDecider 中的，其子类的实现稍微复杂些，具体再看源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">simtime_t</span> <span class="title">BaseDecider::processSignalEnd</span><span class="params">(AirFrame* frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EV_INFO &lt;&lt; <span class="string">&quot;packet was received correctly, it is now handed to upper layer...\n&quot;</span>;</span><br><span class="line">    phy-&gt;<span class="built_in">sendUp</span>(frame, <span class="keyword">new</span> <span class="built_in">DeciderResult</span>(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we have processed this AirFrame and we prepare to receive the next one</span></span><br><span class="line">    currentSignal.first = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel is idle now</span></span><br><span class="line">    <span class="built_in">setChannelIdleStatus</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> notAgain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 phy 变量的类型是 <code>DeciderToPhyInterface</code>，也是 BasePhyLayer 的父类，而 decider 则是 BasePhyLayer 的成员变量。也就是说，在 <code>DeciderToPhyInterface</code> 以及 <code>MacToPhyInterface</code> 这两个 Interface 中定义可能在 Decider 中用到的接口，使用纯虚函数的形式，举个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Called to send an AirFrame with DeciderResult to the MACLayer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When a packet is completely received and not noise, the Decider</span></span><br><span class="line"><span class="comment"> * call this function to send the packet together with</span></span><br><span class="line"><span class="comment"> * the corresponding DeciderResult up to MACLayer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendUp</span><span class="params">(AirFrame* packet, DeciderResult* result)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这个纯虚函数声明在 DeciderToPhyInterface 中，其实现在 BasePhyLayer 中，而其调用则又在 decider 成员变量中。</p></li></ul><p>稍微总结下，可以看到在 <code>processNewSignal</code> 和 <code>processSignalEnd</code> 中会有一些看起来重复的地方，仔细看了几遍才稍微明白些。在 processNewSignal 中有这么一句注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotate the frame, so that we won&#x27;t try decoding it at its end</span></span><br><span class="line">frame-&gt;<span class="built_in">setUnderMinPowerLevel</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>我觉得可以基本概括在 processNewSignal 中为什么要对 frame 进行参数设置，以及这些处理在 processSignalEnd 中作用了。这里也就是说，frame 本身是包含在 AirFrame 的 msg 中的，第一步的处理更多地是针对 Signal，然后在其中 Update 了 frame 的一些参数，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frame-&gt;<span class="built_in">setUnderMinPowerLevel</span>(<span class="literal">true</span>);</span><br><span class="line">frame-&gt;<span class="built_in">setBitError</span>(<span class="literal">true</span>);</span><br><span class="line">frame-&gt;<span class="built_in">setWasTransmitting</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>其中 1 和 3 是 AirFrame11p 扩展出来的，作用在 processSignalEnd 中也看到了，辅助生成 DeciderResult 结果，而不再经过 singal 来判断。只是这里 frame 具体代指什么暂时说不清楚。</p><h3 id="3-与-mac-层交互">3. 与 Mac 层交互</h3><p>最后上传给 Mac 的 ControlMsg 有如下几种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packet was received correctly, it is now handed to upper layer...</span></span><br><span class="line">phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;RxStartStatus&quot;</span>, MacToPhyInterface::PHY_RX_END_WITH_SUCCESS));</span><br><span class="line"><span class="comment">// packet was received while sending, sending it as control message to upper layer</span></span><br><span class="line">phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;Error&quot;</span>, RECWHILESEND));</span><br><span class="line"><span class="comment">// packet was not received correctly, sending it as control message to upper layer</span></span><br><span class="line">phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;RxStartStatus&quot;</span>, MacToPhyInterface::PHY_RX_END_WITH_FAILURE));</span><br><span class="line">phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;Error&quot;</span>, Decider80211p::COLLISION));</span><br><span class="line">phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;Error&quot;</span>, BITERROR));</span><br><span class="line"><span class="comment">// set channel idle</span></span><br><span class="line">phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;ChannelStatus&quot;</span>, Mac80211pToPhy11pInterface::CHANNEL_IDLE));</span><br><span class="line"><span class="comment">// set channel busy</span></span><br><span class="line">phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;ChannelStatus&quot;</span>, Mac80211pToPhy11pInterface::CHANNEL_BUSY));</span><br><span class="line"><span class="comment">// trying to receive AirFrame</span></span><br><span class="line">phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;RxStartStatus&quot;</span>, MacToPhyInterface::PHY_RX_START));</span><br></pre></td></tr></table></figure><p>稍微有点复杂，Msg 种类并没有完全定义在一个 Interface 中，其中没有标明 namespace 调用的几个统一定义在这</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Decider80211ControlKinds</span> &#123;</span><br><span class="line">   NOTHING = <span class="number">22100</span>,</span><br><span class="line">   BITERROR, <span class="comment">// the phy has recognized a bit error in the packet</span></span><br><span class="line">   LAST_DECIDER_80211_CONTROL_KIND,</span><br><span class="line">   RECWHILESEND</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据 Message 类型可以简单分成 Error，RxStartStauts 以及 ChannelStatus 三种，具体功能留到 Mac 层解析时候再来看吧。</p><h2 id="三-channel-处理">三、Channel 处理</h2><p>这部分主要出现在 channelInfo 类中，其注释写的比较清楚，这里直接抄过来</p><p><em>ChannelInfo is able to return every AirFrame which intersects with a specified interval. This is mainly used to get the noise for a received signal.</em></p><p><em>ChannelInfo is a passive class meaning the user has to tell it when a new AirFrame starts and an existing ends. <em>​</em></em><em>Once an AirFrame has been added to the ChannelInfo the ChannelInfo holds the ownership of this AirFrame even if the AirFrame is removed again from the ChannelInfo</em>***. This is necessary because the ChannelInfo has to be able to store also the AirFrames which are over but still intersect with an currently running AirFrame.*</p><p><em>Note: ChannelInfo assumes that the AirFrames are added and removed chronologically. This means every time you add an AirFrame with a specific start time ChannelInfo assumes that start time as the current time and assumes that every following action happens after that moment. The same goes for &quot;removeAirFrame&quot;. When removing an AirFrames, ChannelInfo assumes the start time plus the duration of the AirFrame as the current time.</em></p><p><em>This also affects &quot;getAirFrames&quot; in the way that you may only ask for intervals which lie before the &quot;current time&quot; of ChannelInfo.</em></p><p>留坑待填，仔细看了下细节挺多，后面有精力再一点点深挖吧。</p><h2 id="四-radio-状态">四、radio 状态</h2><p>radio 在 BasePhyLayer 中使用 std::unique_ptr 定义，也就意味着在一个 NIC 中只允许有一个 Radio 存在。其代表着当前 NIC 的通信状态，基本的有 TX，RX 和 SLEEP 三种。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Radio&gt; radio; <span class="comment">///&lt; The state machine storing the current radio state (TX, RX, SLEEP).</span></span><br></pre></td></tr></table></figure><p>为了更真实地模拟实际通信过程，NIC 的 radio 必须选定一个 channel 来 listen，同时记录其他可用的 channel ，以备后续可以 switch 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @brief Currently selected channel (varies between 0 and nbChannels-1).*/</span></span><br><span class="line"><span class="type">int</span> currentChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief Number of available channels. */</span></span><br><span class="line"><span class="type">int</span> nbChannels;</span><br></pre></td></tr></table></figure><p>那么在 BasePhyLayer 中它主要承担什么功能呢？实际上，在 Decider 中 processNewSignal 时很重要的一部分就是判断当前 Signal 是否已经到达，这是通过 BasePhyLayer 中的 radio 成员对象中的 state 成员变量来存储表达的。getRadioState 以及 setRadioState 的实现都位于 BasePhyLayer 中，但其调用位置大相径庭。</p><p><code>getRadioState</code> 主要在 Decider 模块中进行判断看当前是否可以接收，如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (phy11p-&gt;<span class="built_in">getRadioState</span>() == Radio::TX) &#123;</span><br><span class="line">    frame-&gt;<span class="built_in">setBitError</span>(<span class="literal">true</span>);</span><br><span class="line">    frame-&gt;<span class="built_in">setWasTransmitting</span>(<span class="literal">true</span>);</span><br><span class="line">    EV_TRACE &lt;&lt; <span class="string">&quot;AirFrame: &quot;</span> &lt;&lt; frame-&gt;<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; recvPower &lt;&lt; <span class="string">&quot;) received, while already sending. Setting BitErrors to true&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 setRadioState 则是在 <code>Mac1609_4::handleLowerControl</code> 中进行调用，如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;<span class="built_in">getKind</span>() == MacToPhyInterface::TX_OVER) &#123;</span><br><span class="line"></span><br><span class="line">    EV_TRACE &lt;&lt; <span class="string">&quot;Successfully transmitted a packet on &quot;</span> &lt;&lt; lastAC &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    phy-&gt;<span class="built_in">setRadioState</span>(Radio::RX);</span><br></pre></td></tr></table></figure><p>至于其中的 <code>MacToPhyInterface::TX_OVER</code>，简单在下面列一下暂且不再提</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Message kinds used by every phy layer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Physical layers should begin their additional kinds</span></span><br><span class="line"><span class="comment"> * at the value of LAST_BASE_PHY_KIND.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">BasePhyMessageKinds</span> &#123;</span><br><span class="line">    <span class="comment">/** @brief Indicates the end of a send transmission. */</span></span><br><span class="line">    TX_OVER = <span class="number">22000</span>,</span><br><span class="line">    <span class="comment">/** @brief Indicates the end of a radio switch. */</span></span><br><span class="line">    RADIO_SWITCHING_OVER,</span><br><span class="line">    <span class="comment">/** @brief AirFrame kind */</span></span><br><span class="line">    AIR_FRAME,</span><br><span class="line">    <span class="comment">/** @brief PHY-RXSTART.indication. Used in ack procedure for unicast</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PHY_RX_START,</span><br><span class="line">    <span class="comment">/** @brief PHY-RXEND.indication and Rx was successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PHY_RX_END_WITH_SUCCESS,</span><br><span class="line">    <span class="comment">/** @brief PHY-RXEND.indication and Rx failed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PHY_RX_END_WITH_FAILURE,</span><br><span class="line">    <span class="comment">/** @brief Stores the id on which classes extending BasePhy should</span></span><br><span class="line"><span class="comment">     * continue their own kinds.*/</span></span><br><span class="line">    LAST_BASE_PHY_KIND,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Omnet-Veins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Veins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 实现 RESTful 服务器端学习 -- 实践参考</title>
      <link href="/posts/System-development/20221103-python-restful-api-learn-practice.html"/>
      <url>/posts/System-development/20221103-python-restful-api-learn-practice.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-基础知识整理">1. 基础知识整理</h2><p>REST 基本成为 web services 和 APIs 的标准架构，已经是大多数 APP 的架构。</p><p>REST 的六个特性：</p><ul><li><p><strong>Client-Server</strong>：服务器端与客户端分离。</p></li><li><p><strong>Stateless（无状态）</strong>：每次客户端请求必需包含完整的信息，换句话说，每一次请求都是独立的。</p></li><li><p><strong>Cacheable（可缓存）</strong>：服务器端<u>必须指定哪些请求是可以缓存的</u></p></li><li><p><strong>Layered System（分层结构）</strong>：服务器端与客户端通讯必需标准化，服务器的变更并不会影响客户端。</p></li><li><p><strong>Uniform Interface（统一接口）</strong>：客户端与服务器端的通讯方法必需是统一的。</p></li><li><p><strong>Code on demand（<strong>​~~<strong>按需执行代码？</strong>~~​</strong>）</strong>：<s>服务器端可以在上下文中执行代码或者脚本？</s></p><p>具体解释可以看 <a href="https://en.wikipedia.org/wiki/Code_on_demand">Code on demand - Wikipedia</a></p><p><em>In <em>​</em><a href="https://en.wikipedia.org/wiki/Distributed_computing" title="Distributed computing">distributed computing</a><em>​</em>, <em>​</em></em><em>code on demand</em><em><em>​</em> is any technology that sends executable software code from a server computer to a client computer upon request from the client’s software. Some well-known examples of the code on demand paradigm on the web are <em>​</em><a href="https://en.wikipedia.org/wiki/Java_applet" title="Java applet">Java applets</a><em>​</em>, Adobe’s <em>​</em><a href="https://en.wikipedia.org/wiki/ActionScript" title="ActionScript">ActionScript</a><em>​</em> language for the <em>​</em><a href="https://en.wikipedia.org/wiki/Adobe_Flash_Player" title="Adobe Flash Player">Flash Player</a><em>​</em>, and <em>​</em><a href="https://en.wikipedia.org/wiki/JavaScript" title="JavaScript">JavaScript</a><em>​</em>.<em>​</em><a href="https://en.wikipedia.org/wiki/Code_on_demand#cite_note-Is_Code_Still_Moving_Around-1">[1]</a>^^</em></p></li></ul><p>另外可以还需要补充一个特性是<u>部分操作的</u>​<strong>幂等性</strong>，即<u>执行若干次和执行一次的效果一样</u>。</p><p><a href="https://sofish.github.io/restcookbook/http%20methods/idempotency/">哪些是幂等或/且安全的方法？ - RESTful 手册 (sofish.github.io)</a></p><p><a href="https://learnku.com/articles/50902">答面试官问：怎么实现接口幂等性 | Laravel China 社区 (learnku.com)</a></p><p>RESTful web services的核心概念是管理资源，资源是由URIs来表示，客户端使用HTTP当中的’POST, OPTIONS, GET,PUT,DELETE’等方法发送请求到服务器，改变相应的资源状态。</p><h2 id="2-代码示例学习">2. 代码示例学习</h2><p>按照博客中说明建立好虚拟环境后就可以开始了，注意博客中使用的应该是 Python2 版本所以有些是不能执行的，下面的实现已经都改成了 Python3 版本了。</p><p>另外博客中使用 curl 来模拟发起 http 请求，而我在公司使用会莫名被禁用请求，哪怕本地也不行，于是只好使用 postman 客户端来模拟，效果也不错。</p><h3 id="实现1：hello-world">实现1：Hello World</h3><p>服务端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!flask/bin/python</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="实现2：实现-get">实现2：实现 GET</h3><p>服务端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!flask/bin/python</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Buy groceries&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Milk, Cheese, Pizza, Fruit, Tylenol&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Learn Python&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Need to find a good Python tutorial on the web&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_tasks</span>():</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;tasks&#x27;</span>: tasks&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="实现-3：特定参数-get">实现 3：特定参数 GET</h3><p>注意第 23 行参考博客中使用的是 Python2 实现，因此在这里 filter 的返回值是不同的，需要都修改成 list 才能使用。具体见下面参考链接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!flask/bin/python</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, abort</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Buy groceries&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Milk, Cheese, Pizza, Fruit, Tylenol&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Learn Python&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Need to find a good Python tutorial on the web&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks/&lt;int:task_id&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_task</span>(<span class="params">task_id</span>):</span><br><span class="line">    task = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> t: t[<span class="string">&#x27;id&#x27;</span>] == task_id, tasks))</span><br><span class="line">    <span class="built_in">print</span>(task)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;task&#x27;</span>: task[<span class="number">0</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="reference">Reference:</h4><p><a href="https://stackoverflow.com/questions/15876259/typeerror-filter-object-is-not-subscriptable">python - TypeError: 'filter' object is not subscriptable - Stack Overflow</a></p><h3 id="实现-4：完善-exception-处理">实现 4：完善 Exception 处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!flask/bin/python</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, abort, make_response</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Buy groceries&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Milk, Cheese, Pizza, Fruit, Tylenol&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Learn Python&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Need to find a good Python tutorial on the web&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(<span class="params"><span class="number">404</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">not_found</span>(<span class="params">error</span>):</span><br><span class="line">    <span class="keyword">return</span> make_response(jsonify(&#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;Not found&#x27;</span>&#125;), <span class="number">404</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks/&lt;int:task_id&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_task</span>(<span class="params">task_id</span>):</span><br><span class="line">    task = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> t: t[<span class="string">&#x27;id&#x27;</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(task) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> not_found(Exception)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;task&#x27;</span>: task[<span class="number">0</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="reference">Reference</h4><ol><li><a href="https://www.runoob.com/python/python-exceptions.html">Python 异常处理 | 菜鸟教程 (runoob.com)</a></li></ol><hr><h3 id="实现-5：设计-post">实现 5：设计 Post</h3><p>这里 Postman 部分设置如下，手动在 Header 里面添加 Content-Type 作为 header，然后在 Body 中选择 raw 然后输入 json 格式的 content，最后发送即可。</p><p><img src="../../post-images/6a2b0d8915390facb31ef50e876bd711_MD5.png" alt=""><br><img src="../../post-images/c300312e0b026c8380659758a4f80ab3_MD5.png" alt=""></p><p>服务端代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!flask/bin/python</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, abort, make_response, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Buy groceries&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Milk, Cheese, Pizza, Fruit, Tylenol&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Learn Python&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Need to find a good Python tutorial on the web&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_tasks</span>():</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;tasks&#x27;</span>: tasks&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_task</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json <span class="keyword">or</span> <span class="keyword">not</span> <span class="string">&#x27;title&#x27;</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    task = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: tasks[-<span class="number">1</span>][<span class="string">&#x27;id&#x27;</span>] + <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: request.json[<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: request.json.get(<span class="string">&#x27;description&#x27;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">    tasks.append(task)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;task&#x27;</span>: task&#125;), <span class="number">201</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>然后再发送 GET 请求可以获取到已经添加后的 Task 的列表</p><h4 id="reference">Reference</h4><ol><li><a href="https://blog.csdn.net/maowendi/article/details/80535316">(110条消息) Postman发送post请求_maowendi的博客-CSDN博客_postman中post请求</a></li></ol><h3 id="实现-6：实现-put-和-delete">实现 6：实现 PUT 和 DELETE</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!flask/bin/python</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, abort, make_response, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Buy groceries&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Milk, Cheese, Pizza, Fruit, Tylenol&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Learn Python&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Need to find a good Python tutorial on the web&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_tasks</span>():</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;tasks&#x27;</span>: tasks&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_task</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json <span class="keyword">or</span> <span class="keyword">not</span> <span class="string">&#x27;title&#x27;</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    task = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: tasks[-<span class="number">1</span>][<span class="string">&#x27;id&#x27;</span>] + <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: request.json[<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: request.json.get(<span class="string">&#x27;description&#x27;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">    tasks.append(task)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;task&#x27;</span>: task&#125;), <span class="number">201</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks/&lt;int:task_id&gt;&#x27;</span>, methods=[<span class="string">&#x27;PUT&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_task</span>(<span class="params">task_id</span>):</span><br><span class="line">    task = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> t: t[<span class="string">&#x27;id&#x27;</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;title&#x27;</span> <span class="keyword">in</span> request.json <span class="keyword">and</span> <span class="built_in">type</span>(request.json[<span class="string">&#x27;title&#x27;</span>]) != unicode:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;description&#x27;</span> <span class="keyword">in</span> request.json <span class="keyword">and</span> <span class="built_in">type</span>(request.json[<span class="string">&#x27;descriptioin&#x27;</span>]) <span class="keyword">is</span> <span class="keyword">not</span> unicode:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;done&#x27;</span> <span class="keyword">in</span> request.json <span class="keyword">and</span> <span class="built_in">type</span>(request.json[<span class="string">&#x27;done&#x27;</span>]) <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">bool</span>:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">    task[<span class="number">0</span>][<span class="string">&#x27;title&#x27;</span>] = request.json.get(<span class="string">&#x27;title&#x27;</span>, task[<span class="number">0</span>][<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">&#x27;description&#x27;</span>] = request.json.get(<span class="string">&#x27;description&#x27;</span>, task[<span class="number">0</span>][<span class="string">&#x27;description&#x27;</span>])</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">&#x27;done&#x27;</span>] = request.json.get(<span class="string">&#x27;done&#x27;</span>, task[<span class="number">0</span>][<span class="string">&#x27;done&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;task&#x27;</span>: task[<span class="number">0</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks/&lt;int:task_id&gt;&#x27;</span>, methods=[<span class="string">&#x27;DELETE&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_task</span>(<span class="params">task_id</span>):</span><br><span class="line">    task = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> t: t[<span class="string">&#x27;id&#x27;</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    tasks.remove(task[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;result&#x27;</span>: <span class="literal">True</span>&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="实现-7：改进-web-service-接口">实现 7：改进 Web Service 接口</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!flask/bin/python</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, abort, make_response, request, url_for</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Buy groceries&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Milk, Cheese, Pizza, Fruit, Tylenol&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Learn Python&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Need to find a good Python tutorial on the web&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_public_task</span>(<span class="params">task</span>):</span><br><span class="line">    new_task = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> field <span class="keyword">in</span> task:</span><br><span class="line">        <span class="keyword">if</span> field == <span class="string">&#x27;id&#x27;</span>:</span><br><span class="line">            new_task[<span class="string">&#x27;url&#x27;</span>] = url_for(<span class="string">&#x27;get_task&#x27;</span>, task_id=task[<span class="string">&#x27;id&#x27;</span>], _external=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_task[field] = task[field]</span><br><span class="line">    <span class="keyword">return</span> new_task</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_task</span>():</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;tasks&#x27;</span>: <span class="built_in">list</span>(<span class="built_in">map</span>(make_public_task, tasks))&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_task</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json <span class="keyword">or</span> <span class="keyword">not</span> <span class="string">&#x27;title&#x27;</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    task = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: tasks[-<span class="number">1</span>][<span class="string">&#x27;id&#x27;</span>] + <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: request.json[<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: request.json.get(<span class="string">&#x27;description&#x27;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">    tasks.append(task)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;task&#x27;</span>: task&#125;), <span class="number">201</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks/&lt;int:task_id&gt;&#x27;</span>, methods=[<span class="string">&#x27;PUT&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_task</span>(<span class="params">task_id</span>):</span><br><span class="line">    task = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> t: t[<span class="string">&#x27;id&#x27;</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;title&#x27;</span> <span class="keyword">in</span> request.json <span class="keyword">and</span> <span class="built_in">type</span>(request.json[<span class="string">&#x27;title&#x27;</span>]) != unicode:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;description&#x27;</span> <span class="keyword">in</span> request.json <span class="keyword">and</span> <span class="built_in">type</span>(request.json[<span class="string">&#x27;descriptioin&#x27;</span>]) <span class="keyword">is</span> <span class="keyword">not</span> unicode:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;done&#x27;</span> <span class="keyword">in</span> request.json <span class="keyword">and</span> <span class="built_in">type</span>(request.json[<span class="string">&#x27;done&#x27;</span>]) <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">bool</span>:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">    task[<span class="number">0</span>][<span class="string">&#x27;title&#x27;</span>] = request.json.get(<span class="string">&#x27;title&#x27;</span>, task[<span class="number">0</span>][<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">&#x27;description&#x27;</span>] = request.json.get(<span class="string">&#x27;description&#x27;</span>, task[<span class="number">0</span>][<span class="string">&#x27;description&#x27;</span>])</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">&#x27;done&#x27;</span>] = request.json.get(<span class="string">&#x27;done&#x27;</span>, task[<span class="number">0</span>][<span class="string">&#x27;done&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;task&#x27;</span>: task[<span class="number">0</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks/&lt;int:task_id&gt;&#x27;</span>, methods=[<span class="string">&#x27;DELETE&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_task</span>(<span class="params">task_id</span>):</span><br><span class="line">    task = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> t: t[<span class="string">&#x27;id&#x27;</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    tasks.remove(task[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;result&#x27;</span>: <span class="literal">True</span>&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="实现-8：添加安全认证">实现 8：添加安全认证</h3><p>Postman 设置如下，如果不添加这个设置直接 GET 的话会报我们代码中定义的安全认证的错误</p><p><img src="../../post-images/cdac363ccc8a2bfe99afcee5ffdd2115_MD5.png" alt=""></p><p>代码如下，注意第 5 行修改为如下，博客中的引用方式已经过时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加安全认证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!flask/bin/python</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, abort, make_response, request, url_for</span><br><span class="line"><span class="keyword">from</span> flask_httpauth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"></span><br><span class="line">auth = HTTPBasicAuth()</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth.get_password</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_password</span>(<span class="params">username</span>):</span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">&#x27;ok&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;python&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@auth.error_handler</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unauthorized</span>():</span><br><span class="line">    <span class="keyword">return</span> make_response(jsonify(&#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;Unauthorized access&#x27;</span>&#125;), <span class="number">401</span>)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Buy groceries&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Milk, Cheese, Pizza, Fruit, Tylenol&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">u&#x27;Learn Python&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: <span class="string">u&#x27;Need to find a good Python tutorial on the web&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@auth.login_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_task</span>():</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;tasks&#x27;</span>: tasks&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_task</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json <span class="keyword">or</span> <span class="keyword">not</span> <span class="string">&#x27;title&#x27;</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    task = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>: tasks[-<span class="number">1</span>][<span class="string">&#x27;id&#x27;</span>] + <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: request.json[<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;description&#x27;</span>: request.json.get(<span class="string">&#x27;description&#x27;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">        <span class="string">&#x27;done&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">    tasks.append(task)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;task&#x27;</span>: task&#125;), <span class="number">201</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks/&lt;int:task_id&gt;&#x27;</span>, methods=[<span class="string">&#x27;PUT&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_task</span>(<span class="params">task_id</span>):</span><br><span class="line">    task = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> t: t[<span class="string">&#x27;id&#x27;</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;title&#x27;</span> <span class="keyword">in</span> request.json <span class="keyword">and</span> <span class="built_in">type</span>(request.json[<span class="string">&#x27;title&#x27;</span>]) != unicode:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;description&#x27;</span> <span class="keyword">in</span> request.json <span class="keyword">and</span> <span class="built_in">type</span>(request.json[<span class="string">&#x27;descriptioin&#x27;</span>]) <span class="keyword">is</span> <span class="keyword">not</span> unicode:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;done&#x27;</span> <span class="keyword">in</span> request.json <span class="keyword">and</span> <span class="built_in">type</span>(request.json[<span class="string">&#x27;done&#x27;</span>]) <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">bool</span>:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">    task[<span class="number">0</span>][<span class="string">&#x27;title&#x27;</span>] = request.json.get(<span class="string">&#x27;title&#x27;</span>, task[<span class="number">0</span>][<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">&#x27;description&#x27;</span>] = request.json.get(<span class="string">&#x27;description&#x27;</span>, task[<span class="number">0</span>][<span class="string">&#x27;description&#x27;</span>])</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">&#x27;done&#x27;</span>] = request.json.get(<span class="string">&#x27;done&#x27;</span>, task[<span class="number">0</span>][<span class="string">&#x27;done&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;task&#x27;</span>: task[<span class="number">0</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/todo/api/v1.0/tasks/&lt;int:task_id&gt;&#x27;</span>, methods=[<span class="string">&#x27;DELETE&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_task</span>(<span class="params">task_id</span>):</span><br><span class="line">    task = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> t: t[<span class="string">&#x27;id&#x27;</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    tasks.remove(task[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;result&#x27;</span>: <span class="literal">True</span>&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><ol><li><a href="https://www.cnblogs.com/sea520/p/9993254.html">使用python的Flask实现一个RESTful API服务器端 - sea的博客 - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.miguelgrinberg.com/post/designing-a-restful-api-with-python-and-flask">Designing a RESTful API with Python and Flask - miguelgrinberg.com</a></li><li><a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world">The Flask Mega-Tutorial Part I: Hello, World! - miguelgrinberg.com</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> System-development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Veins Module 浅析3 -- BasePhyLayer 中 CCA 实现细节</title>
      <link href="/posts/Omnet-Veins/20221030-veins-module-basephylayer-cca.html"/>
      <url>/posts/Omnet-Veins/20221030-veins-module-basephylayer-cca.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言">1. 前言</h2><blockquote><p>引用参考链接 1</p></blockquote><p>对于射频通信而言，非常重要的一个问题即是<strong>通信频道是否可用</strong>。这里所谓的可用是指信道是否拥挤，<u>在规定的频谱带上是否有其他的信号正在传输，且能否和本设备要发送和接收的信号区分开来</u>。由于射频通信的介质是空气，这点不同于现有的互联网通信，通过的是电缆等物理设备。但是要做一个稳定、可靠的通信，就必须做一个传输介质（信道）的判忙处理。</p><p>CC1101提供的<strong>信道检测机制之一就是信道空闲评估，CCA。用于检测编程指定的信道是否处于可用的状态</strong>。</p><p>CCA主要用于CC1101在信号发射之前进行的信道空闲评估，评估的内容包括：</p><p>1、信道的信号强度是否高于某一个阀值（<u>如果信号强度低于这个阈值则认为信道是空闲的</u>）；</p><p>2、是否有和本设备设置的同样频率特征的数据正在被接收；</p><p>这两部分内容既可以都作为信号空闲评估的判断内容，也可分开各自使用，取决于我们对CCA工作模式的设置</p><h2 id="2-code">2. Code</h2><h3 id="a-cca">a. CCA</h3><p>在 Veins 中 CCA Threshold 设置大小为 -65 dBm。这部分实现并没有想的那么简单，下面一点点来看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Decider80211p::cca</span><span class="params">(simtime_t_cref time, AirFrame* exclude)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    AirFrameVector airFrames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// collect all AirFrames that intersect with [start, end]</span></span><br><span class="line">    <span class="built_in">getChannelInfo</span>(time, time, airFrames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In the reference implementation only centerFrequenvy - 5e6 (half bandwidth) is checked!</span></span><br><span class="line">    <span class="comment">// Although this is wrong, the same is done here to reproduce original results</span></span><br><span class="line">    <span class="type">double</span> minPower = phy-&gt;<span class="built_in">getNoiseFloorValue</span>();</span><br><span class="line">    <span class="type">bool</span> isChannelIdle = minPower &lt; ccaThreshold;</span><br><span class="line">    <span class="keyword">if</span> (airFrames.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">size_t</span> usedFreqIndex = airFrames.<span class="built_in">front</span>()-&gt;<span class="built_in">getSignal</span>().<span class="built_in">getSpectrum</span>().<span class="built_in">indexOf</span>(centerFrequency - <span class="number">5e6</span>);</span><br><span class="line">        isChannelIdle = SignalUtils::<span class="built_in">isChannelPowerBelowThreshold</span>(time, airFrames, usedFreqIndex, ccaThreshold - minPower, exclude);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isChannelIdle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，这个函数承接了一个判断，即 CCA 返回一个 bool 值告诉我们当前信道是否 idle，这个判断会触发后面 phy 向 Mac 发送 control msg 以便 mac layer 来获取信道状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Decider80211p::setChannelIdleStatus</span><span class="params">(<span class="type">bool</span> isIdle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isChannelIdle = isIdle;</span><br><span class="line">    <span class="keyword">if</span> (isIdle)</span><br><span class="line">        phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;ChannelStatus&quot;</span>, Mac80211pToPhy11pInterface::CHANNEL_IDLE));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;ChannelStatus&quot;</span>, Mac80211pToPhy11pInterface::CHANNEL_BUSY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着说 CCA 的实现，Line 7 读取了目前所有信道中所有 Start-End 之间经过此时刻的 frames，Veins 中还定义了一个专门的类用来处理 Channel 中的 Interaction。</p><p>之后在 11 和 12 行简单判断了下 noise 的强度是否会使得信道空闲误判，config 文件中指定为 0 。noise floor 中文解释是噪声基底，也称为 Display Average Noise Level(DANL)，代表接收信噪比为 0dB 时，接收机能够感知的最小信号强度。它是频谱灵敏度的表现，Nose Floor 越低表示频谱越能够辨识微弱的讯号。在这里 noiseFloorValue 为 0 表示基本所有的信号我们默认都可以辨识到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> noiseFloorValue = <span class="number">0</span>; <span class="comment">///&lt; Catch-all for all factors negatively impacting SINR (e.g., thermal noise, noise figure, ...)</span></span><br></pre></td></tr></table></figure><p>然后在 13~15 行开始正式判断当前信道实际信号强度是否低于阈值，注意这里 airFrames 变量是 list 类型，而 C++ 中 list 的 <code>front()</code> 函数的作用是返回其第一个元素的引用。于是第 14 行的作用只是获取第一个 frame 中 signal 的 <strong>half bandwidth</strong> 频率的 index。至于这里为什么是这样？看注释也没有理解，先默认这样的实现是合理的吧😂。</p><h3 id="b-ischannelpowerbelowthreshold">b. isChannelPowerBelowThreshold</h3><p>当进入 isChannelPowerBelowThreshold 之后便需要统计信道中的 signal 来判断是否低于给定阈值。分成几个部分吧</p><ol><li>统计所有有交互的报文</li><li>判断报文之和是否小于阈值；</li><li>提取出所有的信道模型后分别过滤下所有的 signal 然后重新看 powerLevelSum 是否小于阈值</li></ol><p>显然如果第 2 步小于阈值的话那么第 3 步经过信道 filter 之后也肯定小于阈值。这里不理解的是为什么在每个 analogueModel 中如果满足条件就直接返回呢？而不是进行完所以的之后再返回呢。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> VEINS_API <span class="title">isChannelPowerBelowThreshold</span><span class="params">(<span class="type">simtime_t</span> now, AirFrameVector&amp; interfererFrames, <span class="type">size_t</span> freqIndex, <span class="type">double</span> threshold, AirFrame* exclude)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interfererFrames.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// No interferers, so the channel interference is below any threshold</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// extract valid signals on the channel at the time of interest</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> possibly move this filtering outside of this function</span></span><br><span class="line">    std::vector&lt;Signal*&gt; interferers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; interfererFrame : interfererFrames) &#123;</span><br><span class="line">        Signal* interferer = &amp;interfererFrame-&gt;<span class="built_in">getSignal</span>();</span><br><span class="line">        <span class="keyword">if</span> (interferer-&gt;<span class="built_in">getReceptionStart</span>() &lt;= now &amp;&amp; interferer-&gt;<span class="built_in">getReceptionEnd</span>() &gt; now &amp;&amp; interfererFrame != exclude) &#123;</span><br><span class="line">            interferers.<span class="built_in">push_back</span>(interferer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check once before applying analogModels</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">powerLevelSumAtFrequencyIndex</span>(interferers, freqIndex) &lt; threshold) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start applying analogue models</span></span><br><span class="line">    <span class="keyword">auto</span> analogueModelCount = interfererFrames.<span class="built_in">front</span>()-&gt;<span class="built_in">getSignal</span>().<span class="built_in">getAnalogueModelList</span>()-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> signalPtr : interferers) &#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(analogueModelCount == signalPtr-&gt;<span class="built_in">getAnalogueModelList</span>()-&gt;<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> analogueModelIndex = <span class="number">0</span>; analogueModelIndex &lt; analogueModelCount; ++analogueModelIndex) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> signalPtr : interferers) &#123;</span><br><span class="line">            signalPtr-&gt;<span class="built_in">applyAnalogueModel</span>(analogueModelIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">powerLevelSumAtFrequencyIndex</span>(interferers, freqIndex) &lt; threshold) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// After all attenuation is performed, there interference is still higher than the threshold</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">powerLevelSumAtFrequencyIndex</span>(interferers, freqIndex) &gt;= threshold);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><ol><li><a href="https://blog.csdn.net/FireStarway/article/details/40753461">(109条消息) CC1101之信道空闲评估(CCA:Clear Channel Assessment)_YaHa201286的博客-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Omnet-Veins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Veins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Veins Module 浅析2 -- connectionManager 作用与实现</title>
      <link href="/posts/Omnet-Veins/20221001-veins-module-read2-connectionmanager.html"/>
      <url>/posts/Omnet-Veins/20221001-veins-module-read2-connectionmanager.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-gates-and-connections">1. Gates and Connections</h1><blockquote><p>在官方文档 4.6 节 Accessing Gates and Connections 有对 gates 的具体介绍，在这里简单摘录下比较关键的。</p></blockquote><p>Omnet 中使用 cGate 来表示模块的 gates，如下是一些常用的调用函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cGate *outGate = <span class="built_in">gate</span>(<span class="string">&quot;out&quot;</span>);    <span class="comment">// 提取名为 “out” 对应的 gate 的 interface</span></span><br><span class="line"></span><br><span class="line">cGate *gIn = <span class="built_in">gate</span>(<span class="string">&quot;g$i&quot;</span>);           <span class="comment">// 当接口定义为 inout 类型时，分别提取 in 和 out</span></span><br><span class="line">cGate *gOut = <span class="built_in">gate</span>(<span class="string">&quot;g$o&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面也可以替换为如下代码，效果相同</span></span><br><span class="line">cGate *gIn = <span class="built_in">gateHalf</span>(<span class="string">&quot;g&quot;</span>, cGate::INPUT);</span><br><span class="line">cGate *gOut = <span class="built_in">gateHalf</span>(<span class="string">&quot;g&quot;</span>, cGate::OUTPUT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想知道是否有该 gate 时</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">hasGate</span>(<span class="string">&quot;optOut&quot;</span>))</span><br><span class="line">   <span class="built_in">send</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(), <span class="string">&quot;optOut&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当接口为 vector gates 时找到其中某一个 gate，需要用 id 来辨识</span></span><br><span class="line"><span class="type">int</span> gateId = <span class="built_in">gate</span>(<span class="string">&quot;in&quot;</span>)-&gt;<span class="built_in">getId</span>();  <span class="comment">// or:</span></span><br><span class="line"><span class="type">int</span> gateId = <span class="built_in">findGate</span>(<span class="string">&quot;in&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="2-connectionmanager-基础结构">2.  connectionManager 基础结构</h1><p>目录位于<code> veins/base/connectionManager</code> 文件夹下</p><h3 id="2-1-nicgrid-保存所有连接">2.1 <code>nicGrid</code> : 保存所有连接</h3><p>我们从最核心的部分开始看，BaseConnectionManager.h 文件夹中 <code>nicGrid</code> 变量，它承载了所有的连接，其定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @brief Type for 1-dimensional array of NicEntries.*/</span></span><br><span class="line"><span class="keyword">using</span> RowVector = std::vector&lt;NicEntries&gt;;</span><br><span class="line"><span class="comment">/** @brief Type for 2-dimensional array of NicEntries.*/</span></span><br><span class="line"><span class="keyword">using</span> NicMatrix = std::vector&lt;RowVector&gt;;</span><br><span class="line"><span class="comment">/** @brief Type for 3-dimensional array of NicEntries.*/</span></span><br><span class="line"><span class="keyword">using</span> NicCube = std::vector&lt;NicMatrix&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief Register of all nics</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * This matrix keeps all nics according to their position.  It</span></span><br><span class="line"><span class="comment">    * allows to restrict the position update to a subset of all nics.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">NicCube nicGrid;</span><br></pre></td></tr></table></figure><p><code>nicGrid</code> 由 NicEntries 变量作为基类型组成的三维的 Vector，可以定义三维空间中任意的物体连接，在 BaseConnectionManager 中大多数的成员函数都是基于它来展开的，如 <code>getCellEntries</code>。<br>而连接的对象统一用 NicEntry 作为接口，也就是说如果想要使用 connectionManager 来进行管理，就必须包含 NicEntry 这个接口模块。在展开说 NicEntry 的组成之前，先来看下 Veins 是如何把要连接的 NicEntry 对象接入到 nicGrid 中来的，这要从车辆的位置移动状态变化开始说起。</p><p>Veins 中 BaseMobility 模块联系着 Sumo 与 Omnet，通过 TraCI 来获取车辆位置更新数据。其内部包含信号 mobilityStateChangedSignal，用来广播车辆位置的变动。如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @brief Store the category of HostMove */</span></span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">simsignal_t</span> mobilityStateChangedSignal;</span><br></pre></td></tr></table></figure><p>而其他需要获取位置变动的模块则 subscribe 这个信号，通过回调函数得知其变动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChannelAccess</span></span><br><span class="line"><span class="built_in">findHost</span>()-&gt;<span class="built_in">subscribe</span>(BaseMobility::mobilityStateChangedSignal, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>跟踪这个订阅可以发现其位于 ChannelAccess 模块的 receiveSignal 函数中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChannelAccess::receiveSignal</span><span class="params">(cComponent* source, <span class="type">simsignal_t</span> signalID, cObject* obj, cObject* details)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signalID == BaseMobility::mobilityStateChangedSignal) &#123;</span><br><span class="line">        ChannelMobilityPtrType <span class="type">const</span> mobility = <span class="built_in">check_and_cast</span>&lt;ChannelMobilityPtrType&gt;(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> heading = Heading::<span class="built_in">fromCoord</span>(mobility-&gt;<span class="built_in">getCurrentOrientation</span>());</span><br><span class="line">        antennaPosition = <span class="built_in">AntennaPosition</span>(<span class="built_in">getId</span>(), mobility-&gt;<span class="built_in">getPositionAt</span>(<span class="built_in">simTime</span>()) + antennaOffset.<span class="built_in">rotatedYaw</span>(-heading.<span class="built_in">getRad</span>()), mobility-&gt;<span class="built_in">getCurrentSpeed</span>(), <span class="built_in">simTime</span>());</span><br><span class="line">        antennaHeading = <span class="built_in">Heading</span>(heading.<span class="built_in">getRad</span>() + antennaOffsetYaw);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRegistered) &#123;</span><br><span class="line">            cc-&gt;<span class="built_in">updateNicPos</span>(<span class="built_in">getParentModule</span>()-&gt;<span class="built_in">getId</span>(), antennaPosition.<span class="built_in">getPositionAt</span>(), antennaHeading);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// register the nic with ConnectionManager</span></span><br><span class="line">            <span class="comment">// returns true, if sendDirect is used</span></span><br><span class="line">            useSendDirect = cc-&gt;<span class="built_in">registerNic</span>(<span class="built_in">getParentModule</span>(), <span class="keyword">this</span>, antennaPosition.<span class="built_in">getPositionAt</span>(), antennaHeading);</span><br><span class="line">            isRegistered = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ChannelAccess</code> 则是 BasePhyLayer 的父类，每个调用该栈的模块都会包含它，变量 <code>cc</code> 则是 BaseConnectionManager 功能指针，即所以需要建立连接的模块都会包含此，在 <code>ChannelAccess</code> 的初始化中可以看到其声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void ChannelAccess::initialize(int stage)</span></span><br><span class="line">cc = <span class="built_in">getConnectionManager</span>(nic);</span><br><span class="line"><span class="keyword">if</span> (cc == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="built_in">cRuntimeError</span>(<span class="string">&quot;Could not find connectionmanager module&quot;</span>);</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="function">BaseConnectionManager* <span class="title">ChannelAccess::getConnectionManager</span><span class="params">(cModule* nic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string cmName = nic-&gt;<span class="built_in">hasPar</span>(<span class="string">&quot;connectionManagerName&quot;</span>) ? nic-&gt;<span class="built_in">par</span>(<span class="string">&quot;connectionManagerName&quot;</span>).<span class="built_in">stringValue</span>() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmName != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        cModule* ccModule = veins::<span class="built_in">findModuleByPath</span>(cmName.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;BaseConnectionManager*&gt;(ccModule);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">cRuntimeError</span>(<span class="string">&quot;Variable connectionManagerName must be specified&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 BaseConnectionManager 指针便可以实现将当前模块注册到 nicGrid 中进行管理（<code>BaseConnectionManager::updateNicPos</code>）或者更新位置数据（<code>BaseConnectionManager::registerNic</code>）。</p><p>最后可以看到在<code>registerNicExt</code> 函数中将其加入了 <code>nicGrid </code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BaseConnectionManager::registerNicExt</span><span class="params">(<span class="type">int</span> nicID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NicEntries::mapped_type nicEntry = nics[nicID];</span><br><span class="line"></span><br><span class="line">    GridCoord cell = <span class="built_in">getCellForCoordinate</span>(nicEntry-&gt;pos);</span><br><span class="line"></span><br><span class="line">    EV_TRACE &lt;&lt; <span class="string">&quot; registering (ext) nic at loc &quot;</span> &lt;&lt; cell.<span class="built_in">info</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add to matrix</span></span><br><span class="line">    NicEntries&amp; cellEntries = <span class="built_in">getCellEntries</span>(cell);</span><br><span class="line">    cellEntries[nicID] = nicEntry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-gridcoord-如何判断两个物体是否在一个位置上">2.2 <code>GridCoord</code>: 如何判断两个物体是否在一个位置上</h3><p>GridCoord 的作用是将原本浮点数的坐标转为整形，乍一看损失了很多精度，但这个过程是很有必要的，简言之就是避免因为过高精度导致物体重叠情况发生。举个例子，假如使用浮点数来表示位置，第一次物体出现在（0.000001, 0.00) 位置，第二次则出现在（0.000501,0.01）位置。这里不是很严谨（一般小数点6位是不会因为浮点数表达发生变化的）但能够简单说明问题，那就是这里其实是同一个位置，只是因为浮点数在传递或者存储或者转换等一系列过程中可能会出现变化，导致位置的判断出现问题。</p><p>在 Veins ConnectionManager 中所有位置的表示都是通过 GridCoord 来查询和表示的，这样规范了数据的表达也避免了可能出现的数值转换问题。</p><p>（PS：即使浮点数转换不会存在问题，针对浮点数的统计和判断相比整形很耗时，而且在 Veins 中整形已经可以满足需求了）</p><hr><h1 id="3-建立连接">3. 建立连接</h1><p>将其加入 <code>nicGrid</code> 后，并不是说就完成了连接建立过程，对于 Omnet 而言这仅仅只是上层，还没有从 <code>cGate</code> 层面来建立连接，下面就要从 <code>NicEntry</code> 入手，看下加入 nicGrid 是如何建立连接的，以及后面解除连接是什么样的。先来看如何将其 register（建立 Omnetpp 层面的连接），然后说下如何 <code>updatePos</code>，这里就需要提到 <code>NicEntryDebug</code> 和 <code>NicEntryDirect</code> 类了，其共同的基类为 <code>NicEntry</code>。</p><h3 id="3-1-如何只与一定范围内的节点建立连接">3.1 如何只与一定范围内的节点建立连接</h3><p>现实世界的通信一定要有范围，在 Veins 中定义 <code>maxInterfDist</code> 来限制通信的范围，下面来看下这个变量是如何用的。</p><p>最主要的函数是 BaseConnectionManager 中的 <code>isInRange</code>，其在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Check if the two nic&#x27;s are in range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will be used to decide if two nic&#x27;s shall be connected or not. It</span></span><br><span class="line"><span class="comment"> * is simple to overload this function to enhance the decision for connection or not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pFromNic Nic source point which should be checked.</span></span><br><span class="line"><span class="comment"> * @param pToNic   Nic target point which should be checked.</span></span><br><span class="line"><span class="comment"> * @return true if the nic&#x27;s are in range and can be connected, false if not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isInRange</span><span class="params">(NicEntries::mapped_type pFromNic, NicEntries::mapped_type pToNic)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-senddirct-含义">3.2 <code>sendDirct</code> 含义</h3><h3 id="3-3-如何在-omnet-层面动态建立连接">3.3 如何在 Omnet 层面动态建立连接</h3><p>NicEntry 提供了几个接口函数供后续子类根据需要派生</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @brief Connect two nics */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">connectTo</span><span class="params">(NicEntry*)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief Disconnect two nics */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">disconnectFrom</span><span class="params">(NicEntry*)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Omnet-Veins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Veins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Omnet++ Samples 学习 2 - FIFO</title>
      <link href="/posts/Omnet-Veins/20220924-omnet++-samples-2-FIFO.html"/>
      <url>/posts/Omnet-Veins/20220924-omnet++-samples-2-FIFO.html</url>
      
        <content type="html"><![CDATA[<h1 id="目录">目录</h1><p>[TOC]<br><img src="../../post-images/1664507446434.png" alt="image-20220926224435487|575"></p><h2 id="基类">基类</h2><p>首先来看 FIFO 基类定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> fifo &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Abstract base class for single-server queues. Subclasses should</span></span><br><span class="line"><span class="comment"> * define startService() and endService(), and may override other</span></span><br><span class="line"><span class="comment"> * virtual functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFifo</span> : <span class="keyword">public</span> cSimpleModule</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    cMessage *msgServiced = <span class="literal">nullptr</span>;</span><br><span class="line">    cMessage *endServiceMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    cQueue queue;</span><br><span class="line">    <span class="type">simsignal_t</span> qlenSignal;<span class="comment">// queue length</span></span><br><span class="line">    <span class="type">simsignal_t</span> busySignal;<span class="comment">// signal status</span></span><br><span class="line">    <span class="type">simsignal_t</span> queueingTimeSignal;<span class="comment">// queue top begin processing time</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractFifo</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleMessage</span><span class="params">(cMessage *msg)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hook functions to (re)define behavior</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">arrival</span><span class="params">(cMessage *msg)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">simtime_t</span> <span class="title">startService</span><span class="params">(cMessage *msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">endService</span><span class="params">(cMessage *msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;; <span class="comment">//namespace</span></span><br></pre></td></tr></table></figure><p>在成员变量中可以看到 <code>cQueue queue;</code> 定义，是整个 FIFO 的核心，围绕着这个数据结构展开 signle-server queues 的框架实现。</p><p>基本上所有的处理都在 AbstractFifo 实现了，只有 startService 和 endService  需要在派生类中进行重载。</p><h2 id="initialize-函数"><code>initialize()</code> 函数</h2><p>初始化几个统计信号，分别负责 queue 不同状态下的记录统计；初始化 <code>endServiceMsg</code> 消息；发送当前 queue 的长度以及设置 busySignal 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AbstractFifo::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    endServiceMsg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;end-service&quot;</span>);</span><br><span class="line">    queue.<span class="built_in">setName</span>(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line"></span><br><span class="line">    qlenSignal = <span class="built_in">registerSignal</span>(<span class="string">&quot;qlen&quot;</span>);</span><br><span class="line">    busySignal = <span class="built_in">registerSignal</span>(<span class="string">&quot;busy&quot;</span>);</span><br><span class="line">    queueingTimeSignal = <span class="built_in">registerSignal</span>(<span class="string">&quot;queueingTime&quot;</span>);</span><br><span class="line">    <span class="built_in">emit</span>(qlenSignal, queue.<span class="built_in">getLength</span>());</span><br><span class="line">    <span class="built_in">emit</span>(busySignal, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="handlemessage-函数"><code>handleMessage()</code> 函数</h2><p>这里只看 <code>AbstractFifo</code> ，其余 module 都很简单不再细看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AbstractFifo::handleMessage</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg == endServiceMsg) &#123;        <span class="comment">// 执行1</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;endServiceMsg&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">endService</span>(msgServiced);</span><br><span class="line">        <span class="keyword">if</span> (queue.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            msgServiced = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">emit</span>(busySignal, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            msgServiced = (cMessage *)queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">emit</span>(qlenSignal, queue.<span class="built_in">getLength</span>());</span><br><span class="line">            <span class="built_in">emit</span>(queueingTimeSignal, <span class="built_in">simTime</span>() - msgServiced-&gt;<span class="built_in">getTimestamp</span>());</span><br><span class="line">            <span class="type">simtime_t</span> serviceTime = <span class="built_in">startService</span>(msgServiced);</span><br><span class="line">            <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+serviceTime, endServiceMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!msgServiced) &#123;<span class="comment">// 执行2</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;!msgServiced&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">arrival</span>(msg);</span><br><span class="line">        msgServiced = msg;</span><br><span class="line">        <span class="built_in">emit</span>(queueingTimeSignal, SIMTIME_ZERO);</span><br><span class="line">        <span class="type">simtime_t</span> serviceTime = <span class="built_in">startService</span>(msgServiced);</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+serviceTime, endServiceMsg);</span><br><span class="line">        <span class="built_in">emit</span>(busySignal, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 执行3</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;arrival&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">arrival</span>(msg);</span><br><span class="line">        queue.<span class="built_in">insert</span>(msg);</span><br><span class="line">        msg-&gt;<span class="built_in">setTimestamp</span>();</span><br><span class="line">        <span class="built_in">emit</span>(qlenSignal, queue.<span class="built_in">getLength</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的三个判断初看不太好理解，额外加了些打印，结合 queue 的操作一起来看。实际的执行顺序如下<br><img src="../../post-images/image-20220928213618022.png" alt="image-20220928213618022|575"><br><img src="file:///Users/xqiao/Documents/Gridea/" alt="" style="zoom:50%;" /></p><p>当 source 模块在低速发包的时候，可以看到基本不会调用到 queue 的 <code>insert</code> 和 <code>pop</code> 操作，<code>msgServiced</code> 的 reset 值总为 <code>nullptr</code>，之后执行 2 <code>startService</code>  操作开始加入耗时。如下可以看到系统设置的 source 发包和 fifo 处理的时长，大约每 0.2s 发包一次并且每 0.1s 执行一次 startService，因此可以看到系统运行时基本不会出现入队和出队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Fifo1]</span><br><span class="line">description = <span class="string">&quot;low job arrival rate&quot;</span></span><br><span class="line">network = SingleQueue</span><br><span class="line">**.source.interarrivalTime = <span class="built_in">exponential</span>(<span class="number">0.2</span>s)</span><br><span class="line">**.fifo.serviceTime = <span class="number">0.1</span>s</span><br></pre></td></tr></table></figure><p>但当把 <code>interarrivalTime</code> 调整为 0.1s 后，就可以发现有 fifo 的 service 处理不完的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Fifo2]</span><br><span class="line">description = <span class="string">&quot;high job arrival rate&quot;</span></span><br><span class="line">network = SingleQueue</span><br><span class="line">**.source.interarrivalTime = <span class="built_in">exponential</span>(<span class="number">0.1</span>s)</span><br><span class="line">**.fifo.serviceTime = <span class="number">0.1</span>s</span><br></pre></td></tr></table></figure><h2 id="tandem-queue">Tandem Queue</h2><p>Tandem Queue 的组成结构如下</p><img src="file:///Users/xqiao/Documents/Gridea/post-images/image-20220929223855832.png" alt="image-20220929223855832" style="zoom:50%;" /><p>除此之外几乎没有啥明细不同了，fifo 也是依次串联。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[TandemQueues]</span><br><span class="line">network = TandemQueues</span><br><span class="line">**.interarrivalTime = <span class="built_in">exponential</span>(<span class="number">2</span>s)</span><br><span class="line">**.serviceTime = <span class="built_in">exponential</span>(<span class="number">2</span>s)</span><br><span class="line"></span><br><span class="line">[TandemQueueExperiment] <span class="meta"># this config is used by test/scave/, do not modify!</span></span><br><span class="line">network = TandemQueues</span><br><span class="line">**.interarrivalTime = <span class="built_in">exponential</span>(<span class="number">2</span>s)</span><br><span class="line">**.serviceTime = <span class="built_in">truncnormal</span>($&#123;serviceTimeMean=<span class="number">1.5</span>s, <span class="number">2.5</span>s&#125;,<span class="number">1</span>s)</span><br><span class="line">repeat = <span class="number">2</span></span><br><span class="line">sim-time-limit = <span class="number">200</span>s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Omnet-Veins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Omnet++ Samples 学习 1 - TicToc 练习汇总</title>
      <link href="/posts/Omnet-Veins/20220921-omnet++-samples-tictoc-practice.html"/>
      <url>/posts/Omnet-Veins/20220921-omnet++-samples-tictoc-practice.html</url>
      
        <content type="html"><![CDATA[<p>官方 Tictoc Tutorials 链接：<a href="https://docs.omnetpp.org/tutorials/tictoc/">Introduction - OMNeT++ Technical Articles</a></p><p>国内比较好的翻译链接：<a href="https://www.cnblogs.com/ShineLeBlog/category/1972607.html">omnet++ - 随笔分类 - ShineLe - 博客园</a></p><span id="more"></span><h3 id="tictoc-1">Tictoc 1</h3><blockquote><p>Derive the Txc1 class from cSimpleModule. In the Tictoc1 network, both the <code>tic</code> and <code>toc</code> modules are Txc1 objects, created by OMNeT++ at the beginning of the simulation.</p></blockquote><p>一切都从新手村开始，在最开始的例子里，我们首先要了解 Tictoc 仿真的大致框架。</p><ul><li><p><code>Tictoc.ned</code></p><p>包含 tictoc module 以及 network 的定义</p></li><li><p><code>tictoc.cc</code> &amp; <code>tictoc.h</code></p><p>每个 module 的功能实现</p></li><li><p><code>ompetpp.ini</code></p><p>仿真的启动文件，也会声明和初始化一些 module 或 network 中的参数</p></li></ul><p>太过细节的不再过多赘述了，可以自己查阅官方链接。目前只需要知道每个 module 实现都要继承 cSimpleModule 模块并 override 两个基本函数 <code>initlaize()</code> 和 <code>handleMessage()</code> ，如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Txc1</span> : <span class="keyword">public</span> cSimpleModule</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// The following redefined virtual function holds the algorithm.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleMessage</span><span class="params">(cMessage *msg)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>handleMessage</code> 函数的功能是对收到的 Message 作出反应，在这里是直接再向外发送一个 Message，最后效果便像是 ping-pang 一样互发。</p><p>在 initialize() 中可以看到调用 Omnet++ 的 API 来获取当前 module 的name</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc1::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize is called at the beginning of the simulation.</span></span><br><span class="line">    <span class="comment">// To bootstrap the tic-toc-tic-toc process, one of the modules needs</span></span><br><span class="line">    <span class="comment">// to send the first message. Let this be `tic&#x27;.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Am I Tic or Toc?</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;tic&quot;</span>, <span class="built_in">getName</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// create and send first message on gate &quot;out&quot;. &quot;tictocMsg&quot; is an</span></span><br><span class="line">        <span class="comment">// arbitrary string which will be the name of the message object.</span></span><br><span class="line">        cMessage *msg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">send</span>(msg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也即确保第一发包是从 tic module 开始的。</p><hr><h3 id="tictoc-2">Tictoc 2</h3><blockquote><p>In this step we add some debug messages to Txc1. When you run the simulation in the OMNeT++ Qtenv GUI, the log will appear in the bottom panel of the Qtenv window. To see only the log from <code>tic</code> or <code>toc</code> alone, go into them by double-clicking their icons, and the bottom panel will be filtered accordingly. (You can go back with the up arrow button on the toolbar.)</p></blockquote><p>相比 Tictoc1 增加了 debug 信息</p><hr><h3 id="tictoc-3">Tictoc 3</h3><blockquote><p>In this class we add a counter, and delete the message after ten exchanges.</p></blockquote><ul><li><p><code>Initialize()</code> 函数中添加了 WATCH 函数，可以实时在 Qtenv 显示 counter 的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc3::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize counter to ten. We&#x27;ll decrement it every time and delete</span></span><br><span class="line">    <span class="comment">// the message when it reaches zero.</span></span><br><span class="line">    counter = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The WATCH() statement below will let you examine the variable under</span></span><br><span class="line">    <span class="comment">// Qtenv. After doing a few steps in the simulation, click either</span></span><br><span class="line">    <span class="comment">// `tic&#x27; or `toc&#x27;, and you&#x27;ll find its `counter&#x27; variable and its</span></span><br><span class="line">    <span class="comment">// current value displayed in the inspector panel (bottom left).</span></span><br><span class="line">    <span class="built_in">WATCH</span>(counter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;tic&quot;</span>, <span class="built_in">getName</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Sending initial message\n&quot;</span>;</span><br><span class="line">        cMessage *msg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">send</span>(msg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="tictoc-4">Tictoc 4</h3><blockquote><p>In this step you’ll learn how to add input parameters to the simulation: we’ll turn the “magic number” 10 into a parameter.</p></blockquote><ul><li><p>将仿真参数添加在 ned 文件中进行设置，避免在 cc 文件中进行设置绑定。首先在 ned 文件中对变量进行定义，可以通过 default 变量设置默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">simple Txc4</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        <span class="type">bool</span> sendMsgOnInit = <span class="built_in">default</span>(<span class="literal">false</span>); <span class="comment">// whether the module should send out a message on initialization</span></span><br><span class="line">        <span class="type">int</span> limit = <span class="built_in">default</span>(<span class="number">2</span>);   <span class="comment">// another parameter with a default value</span></span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=block/routing&quot;</span>);</span><br><span class="line">    gates:</span><br><span class="line">        input in;</span><br><span class="line">        output out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 cc 文件中通过 <code>par()</code> 函数进行变量读取，如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc4::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize the counter with the &quot;limit&quot; module parameter, declared</span></span><br><span class="line">    <span class="comment">// in the NED file (tictoc4.ned).</span></span><br><span class="line">    counter = <span class="built_in">par</span>(<span class="string">&quot;limit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we no longer depend on the name of the module to decide</span></span><br><span class="line">    <span class="comment">// whether to send an initial message</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">par</span>(<span class="string">&quot;sendMsgOnInit&quot;</span>).<span class="built_in">boolValue</span>() == <span class="literal">true</span>) &#123;</span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Sending initial message\n&quot;</span>;</span><br><span class="line">        cMessage *msg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">send</span>(msg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="tictoc-5">Tictoc 5</h3><blockquote><p>Same as Txc4. This module will be the base of the Tic and Toc types.</p></blockquote><p>相比 Tictoc 4，仅在 ned 文件中进行了修改，让其继承一个特定的 module，可以更定制化地进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">simple Txc5</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        <span class="type">bool</span> sendMsgOnInit = <span class="built_in">default</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">int</span> limit = <span class="built_in">default</span>(<span class="number">2</span>);</span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=block/routing&quot;</span>);</span><br><span class="line">    gates:</span><br><span class="line">        input in;</span><br><span class="line">        output out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Specialize the module by defining parameters. We could have left the whole body</span></span><br><span class="line"><span class="comment">// empty, because the default value of the sendMsgOnInit parameter is false anyway.</span></span><br><span class="line"><span class="comment">// Note that the limit parameter is still unbound here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">simple Tic5 extends Txc5</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=,cyan&quot;</span>);</span><br><span class="line">        sendMsgOnInit = <span class="literal">true</span>;   <span class="comment">// Tic modules should send a message on init</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Specialize the module by defining parameters. We could have left the whole body</span></span><br><span class="line"><span class="comment">// empty, because the default value of the sendMsgOnInit parameter is false anyway.</span></span><br><span class="line"><span class="comment">// Note that the limit parameter is still unbound here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">simple Toc5 extends Txc5</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=,gold&quot;</span>);</span><br><span class="line">        sendMsgOnInit = <span class="literal">false</span>;  <span class="comment">// Toc modules should NOT send a message on init</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="tictoc-6">Tictoc 6</h3><blockquote><p>In the previous models, <code>tic</code> and <code>toc</code> immediately sent back the received message. Here we’ll add some timing: tic and toc will hold the message for 1 simulated second before sending it back. In OMNeT++ such timing is achieved by the module sending a message to itself.</p><p>Such messages are called <code>self-messages</code> (but only because of the way they are used, otherwise they are completely ordinary messages) or events. Self-messages can be “sent” with the <code>scheduleAt() </code>function, and you can specify when they should arrive back at the module. We leave out the counter, to keep the source code small.</p></blockquote><ul><li><p>引入 self-messages 的概念，不同于接收到的其他类型 Message，它是 module 自己产生的，可以自己设定产生的逻辑，用来定时发送，又或者对其他 Message 的接收作出反应等。</p><p>其通过 <code>scheduleAt()</code> 函数来设置发送，如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc6::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create the event object we&#x27;ll use for timing -- just any ordinary message.</span></span><br><span class="line">    event = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;event&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No tictoc message yet.</span></span><br><span class="line">    tictocMsg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;tic&quot;</span>, <span class="built_in">getName</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t start right away, but instead send an message to ourselves</span></span><br><span class="line">        <span class="comment">// (a &quot;self-message&quot;) -- we&#x27;ll do the first sending when it arrives</span></span><br><span class="line">        <span class="comment">// back to us, at t=5.0s simulated time.</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Scheduling first send to t=5.0s\n&quot;</span>;</span><br><span class="line">        tictocMsg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="number">5.0</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里设置发送包消息仍为 cMessage 类型</p></li><li><p>handleMessage() 针对 self-messages 进行修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc6::handleMessage</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// There are several ways of distinguishing messages, for example by message</span></span><br><span class="line">    <span class="comment">// kind (an int attribute of cMessage) or by class using dynamic_cast</span></span><br><span class="line">    <span class="comment">// (provided you subclass from cMessage). In this code we just check if we</span></span><br><span class="line">    <span class="comment">// recognize the pointer, which (if feasible) is the easiest and fastest</span></span><br><span class="line">    <span class="comment">// method.</span></span><br><span class="line">    <span class="keyword">if</span> (msg == event) &#123;</span><br><span class="line">        <span class="comment">// The self-message arrived, so we can send out tictocMsg and nullptr out</span></span><br><span class="line">        <span class="comment">// its pointer so that it doesn&#x27;t confuse us later.</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Wait period is over, sending back message\n&quot;</span>;</span><br><span class="line">        <span class="built_in">send</span>(tictocMsg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">        tictocMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If the message we received is not our self-message, then it must</span></span><br><span class="line">        <span class="comment">// be the tic-toc message arriving from our partner. We remember its</span></span><br><span class="line">        <span class="comment">// pointer in the tictocMsg variable, then schedule our self-message</span></span><br><span class="line">        <span class="comment">// to come back to us in 1s simulated time.</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Message arrived, starting to wait 1 sec...\n&quot;</span>;</span><br><span class="line">        tictocMsg = msg;</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+<span class="number">1.0</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了单独的 msg 类型判断，当收到 self-message 时发送 message 给其他模块；如果是其他模块发来的消息则制定 message 任务，延时 1s 后再发送 self-message 消息。</p></li></ul><hr><h3 id="tictoc-7">Tictoc 7</h3><blockquote><p>In this step we’ll introduce random numbers. We change the delay from 1s to a random value which can be set from the NED file or from omnetpp.ini. In addition, we’ll “lose” (delete) the packet with a small probability.</p></blockquote><ul><li><p>引入随机数，使用 Omnet++ 下 uniform 函数生成随机数，设置判断条件随机地删除收到的报文。这里可以算是最简单模拟了下实际环境的信道，可能随时出现丢包的情况。<br>uniform 函数如下图所示</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a random variate with uniform distribution in the range [a,b).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param a, b the interval, a&lt;b</span></span><br><span class="line"><span class="comment"> * @param rng index of the component RNG to use, see getRNG(int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">uniform</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">int</span> rng=<span class="number">0</span>)</span> <span class="type">const</span>  </span>&#123;<span class="keyword">return</span> omnetpp::<span class="built_in">uniform</span>(<span class="built_in">getRNG</span>(rng), a, b);&#125;</span><br></pre></td></tr></table></figure></li><li><p>增加 <code>delay</code> 变量，在 ned 文件中进行设置，用于调整循环发送包的间隔。通过 <code>delay</code> 可以简单模拟报文处理的时延；<br>ned 文件设置为</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">double</span> delayTime @<span class="built_in">unit</span>(s);   <span class="comment">// delay before sending back message</span></span><br></pre></td></tr></table></figure><p>cc 文件设置为</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The &quot;delayTime&quot; module parameter can be set to values like</span></span><br><span class="line"><span class="comment">// &quot;exponential(5)&quot; (tictoc7.ned, omnetpp.ini), and then here</span></span><br><span class="line"><span class="comment">// we&#x27;ll get a different delay every time.</span></span><br><span class="line"> <span class="type">simtime_t</span> delay = <span class="built_in">par</span>(<span class="string">&quot;delayTime&quot;</span>);</span><br><span class="line"></span><br><span class="line"> EV &lt;&lt; <span class="string">&quot;Message arrived, starting to wait &quot;</span> &lt;&lt; delay &lt;&lt; <span class="string">&quot; secs...\n&quot;</span>;</span><br><span class="line"> tictocMsg = msg;</span><br><span class="line"> <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+delay, event);</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="tictoc-8">Tictoc 8</h3><blockquote><p>Let us take a step back, and remove random delaying from the code. We’ll leave in, however, losing the packet with a small probability. And, we’ll we do something very common in telecommunication networks: if the packet doesn’t arrive within a certain period, we’ll assume it was lost and create another one. The timeout will be handled using  (what else?) a self-message.</p></blockquote><p>基于<strong>通信中一个很常见的逻辑</strong>重新设计了本节 – 如果未在规定时间到达则默认该 packet 丢失，然后重新创建一个。下面是几个部分的变化</p><p><img src="../../post-images/e0ff0ed439a3d6db48e67495f7f4ad84_MD5.png" alt=""></p><ul><li><p>将 tic 和 toc 分开两部分，分别承担发送方和接收方的功能。tic 发送的报文，当 toc 收到后需要发回一个确认包（acknowledgement），并且有一定概率丢失接收的包（不再设置定时主动发送包，只被动发送）。</p></li><li><p>将前面一直使用的 self message（也可以理解为发包间隔 interval）修改为 timeout，仍然是在收包位置修改了判断逻辑 -&gt; 如果收到 timeout 包，则说明没有在规定时间内收到对面发来的回复包（acknowledgement），于是重新发送 packet 并更新  timer 计时；如果收到了对面的回复包，则确定包发送成功。之后需要取消掉前面规划的 timeoutEvent，重新发送报文并更新 timeout 计时。</p><p>简单理解就是，收到 timeout 包运行丢包处理逻辑，收到 acknowledgement 包则正常运行下一次发包逻辑。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tic8::handleMessage</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg == timeoutEvent) &#123;</span><br><span class="line">        <span class="comment">// If we receive the timeout event, that means the packet hasn&#x27;t</span></span><br><span class="line">        <span class="comment">// arrived in time and we have to re-send it.</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Timeout expired, resending message and restarting timer\n&quot;</span>;</span><br><span class="line">        cMessage *newMsg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">send</span>(newMsg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+timeout, timeoutEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// message arrived</span></span><br><span class="line">            <span class="comment">// Acknowledgement received -- delete the received message and cancel</span></span><br><span class="line">            <span class="comment">// the timeout event.</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Timer cancelled.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">cancelEvent</span>(timeoutEvent);</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ready to send another one.</span></span><br><span class="line">        cMessage *newMsg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">send</span>(newMsg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+timeout, timeoutEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加一种新的显示方法（在 toc handleMessage 下），可以运行的图标上直接显示提示字符串，如上图所示。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bubble</span>(<span class="string">&quot;message lost&quot;</span>);  <span class="comment">// making animation more informative...</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="tictoc-9">Tictoc 9</h3><blockquote><p>In the previous model we just created another packet if we needed to retransmit. This is OK because the packet didn’t contain much, but in real life it’s usually more practical to keep a copy of the original packet so that we can re-send it without the need to build it again.</p></blockquote><ul><li><p>相比 Tictoc 8 增加了 <code>sendCopyOf(message)</code> 功能，对比直接发送的过程如下</p><p>Current</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cMessage *<span class="title">Tic9::generateNewMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Generate a message with a different name every time.</span></span><br><span class="line">    <span class="type">char</span> msgname[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(msgname, <span class="string">&quot;tic-%d&quot;</span>, ++seq);</span><br><span class="line">    cMessage *msg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(msgname);</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tic9::sendCopyOf</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Duplicate message and send the copy.</span></span><br><span class="line">    cMessage *copy = (cMessage *)msg-&gt;<span class="built_in">dup</span>();</span><br><span class="line">    <span class="built_in">send</span>(copy, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Before</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cMessage *newMsg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line"><span class="built_in">send</span>(newMsg, <span class="string">&quot;out&quot;</span>);</span><br></pre></td></tr></table></figure><p>个人觉得这里可能体现的不是很明显，new cMessage(msgname) 和 (cMessage *)msg-&gt;dup() 对比感觉差别并不是很大。不过原作者也说过 ”but in real life it’s usually more practical to keep a copy of the original packet“ ，在实际项目中确实可能构建包的开销很大，这里通过 <code>sendCopyOf</code> 函数为后续的功能提供了封装接口。</p><p>补充下里面提到的这个接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns an exact copy of this object, except for the</span></span><br><span class="line"><span class="comment"> * message ID (the clone is assigned a new ID). Note that the message</span></span><br><span class="line"><span class="comment"> * creation time is also copied, so clones of the same message object</span></span><br><span class="line"><span class="comment"> * have the same creation time. See cObject for more details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> cMessage *<span class="title">dup</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span>  </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">cMessage</span>(*<span class="keyword">this</span>);&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="tictoc-10">Tictoc 10</h3><blockquote><p>Let’s make it more interesting by using several (n) `tic’ modules, and connecting every module to every other. For now, let’s keep it simple what they do: module 0 generates a message, and the others keep tossing it around in random directions until it arrives at module 2.</p></blockquote><p>和之前的例程差别很大，这个例子第一次引入了多模块 vector 以及 forward message 的概念，下面来看下</p><ul><li><p>多模块 vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">simple Txc10</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=block/routing&quot;</span>);</span><br><span class="line">    gates:</span><br><span class="line">        input in[];  <span class="comment">// declare in[] and out[] to be vector gates</span></span><br><span class="line">        output out[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network Tictoc10</span><br><span class="line">&#123;</span><br><span class="line">    @<span class="built_in">display</span>(<span class="string">&quot;bgb=364,261&quot;</span>);</span><br><span class="line">    submodules:</span><br><span class="line">        tic[<span class="number">6</span>]: Txc10 &#123;</span><br><span class="line">            @<span class="built_in">display</span>(<span class="string">&quot;p=165,119&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    connections:</span><br><span class="line">        tic[<span class="number">0</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">1</span>].in++;</span><br><span class="line">        tic[<span class="number">0</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">1</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">1</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">2</span>].in++;</span><br><span class="line">        tic[<span class="number">1</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">2</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">1</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">4</span>].in++;</span><br><span class="line">        tic[<span class="number">1</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">4</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">3</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">4</span>].in++;</span><br><span class="line">        tic[<span class="number">3</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">4</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">4</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">5</span>].in++;</span><br><span class="line">        tic[<span class="number">4</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">5</span>].out++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看这里的 gates 描述，<code>input in[]</code> 和 <code>output out[]</code> 代表多个接口，然后 submodules 中也相应修改，需要明确指定模块的个数，然后 <code>connections</code> 里按照数字大小依次连接各个模块。</p><p>当这里使用 vector 后，在代码中可以通过 <code>getIndex()</code> 函数来获取到模块的 ID 从而针对性地进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the module in a module vector. If the module is not</span></span><br><span class="line"><span class="comment"> * member of a module vector, an exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>forward message</p><p>这次初始化从 0 模块开始发送，然后再从 3 模块等待接收</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc10::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getIndex</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Boot the process scheduling the initial message as a self-message.</span></span><br><span class="line">        <span class="type">char</span> msgname[<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(msgname, <span class="string">&quot;tic-%d&quot;</span>, <span class="built_in">getIndex</span>());</span><br><span class="line">        cMessage *msg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(msgname);</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="number">0.0</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc10::handleMessage</span><span class="params">(cMessage *msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getIndex</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Message arrived.</span></span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Message &quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot; arrived.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We need to forward the message.</span></span><br><span class="line">        forwardMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc10::forwardMessage</span><span class="params">(cMessage *msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// In this example, we just pick a random gate to send it on.</span></span><br><span class="line">    <span class="comment">// We draw a random number between 0 and the size of gate `out[]&#x27;.</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">gateSize</span>(<span class="string">&quot;out&quot;</span>);</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">intuniform</span>(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Forwarding message &quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot; on port out[&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">    <span class="built_in">send</span>(msg, <span class="string">&quot;out&quot;</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面介绍下 forwardMessage 里的两个函数</p><ul><li><p><code>gateSize(&quot;out&quot;)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the size of the gate vector with the given name. Gate names with</span></span><br><span class="line"><span class="comment"> * the &quot;$i&quot; or &quot;$o&quot; suffix are also accepted.  Throws an error if there is</span></span><br><span class="line"><span class="comment"> * no such gate, or it is not a gate vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see cGate::getVectorSize()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">gateSize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *gatename)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>Intuniform(0, n-1)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a random integer with uniform distribution in the range [a,b],</span></span><br><span class="line"><span class="comment"> * inclusive. (Note that the function can also return b.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param a, b  the interval, a&lt;=b</span></span><br><span class="line"><span class="comment"> * @param rng index of the component RNG to use, see getRNG(int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">intuniform</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> rng=<span class="number">0</span>)</span> <span class="type">const</span>  </span>&#123;<span class="keyword">return</span> omnetpp::<span class="built_in">intuniform</span>(<span class="built_in">getRNG</span>(rng), a, b);&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>​这里也第一次出现三个参数的 <code>send(msg, &quot;out&quot;, k)</code>，<code>k</code> 代表着发送到连接的第几个 module，也只有连接多个 module 时才能使用。</p><hr><h3 id="tictoc-11-12">Tictoc 11-12</h3><blockquote><p>Let’s make it more interesting by using several (n) `tic’ modules, and connecting every module to every other. For now, let’s keep it simple what they do: module 0 generates a message, and the others keep tossing it around in random directions until it arrives at  module 2.</p></blockquote><p>对比 Tictoc 10，11 和 12 在代码实现上没有差别，仅在 ned 文件上更改了实现，变化如下<br><img src="../../post-images/82319851718f5022f413a85315e9addb_MD5.png" alt=""><br>这里的 channel 暂时没有搜索相关资料，后续补充。</p><hr><h3 id="tictoc-13">Tictoc 13</h3><blockquote><p>In this step the destination address is no longer node 2 – we draw a random destination, and we’ll add the destination address to the message. The best way is to subclass cMessage and add destination as a data member. Hand-coding the message class is usually tiresome because it contains a lot of boilerplate code, so we let OMNeT++ generate the class for us.<br>The message class specification is in <code>tictoc13.msg</code> – <code>tictoc13_m.h</code> and <code>.cc</code> will be generated from this file automatically. To make the model execute longer, after a message arrives to its destination the destination node will generate another message with a random destination address, and so forth.</p></blockquote><ul><li><p>Tictoc 13 第一次引入了自定义 message 的概念，文件后缀为 .msg，在其中定义 message 的字段，然后其它的便不需要写了，直接交给 Omnet ++ 自行生成处理即可，当系统运行后会自动生成了类似“ 文件名_m.h 和文件名_m.cc” 的两个文件，其中包括了所有获取 message 内字段的接口（读取写入）。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message TicTocMsg13</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> source;</span><br><span class="line">    <span class="type">int</span> destination;</span><br><span class="line">    <span class="type">int</span> hopCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>既然 Message 变为自定义的，那么 Handle Message 的方式也要相应发生改变。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc13::handleMessage</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     TicTocMsg13 *ttmsg = <span class="built_in">check_and_cast</span>&lt;TicTocMsg13 *&gt;(msg);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (ttmsg-&gt;<span class="built_in">getDestination</span>() == <span class="built_in">getIndex</span>()) &#123;</span><br><span class="line">         <span class="comment">// Message arrived.</span></span><br><span class="line">         EV &lt;&lt; <span class="string">&quot;Message &quot;</span> &lt;&lt; ttmsg &lt;&lt; <span class="string">&quot; arrived after &quot;</span> &lt;&lt; ttmsg-&gt;<span class="built_in">getHopCount</span>() &lt;&lt; <span class="string">&quot; hops.\n&quot;</span>;</span><br><span class="line">         <span class="built_in">bubble</span>(<span class="string">&quot;ARRIVED, starting new one!&quot;</span>);</span><br><span class="line">         <span class="keyword">delete</span> ttmsg;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Generate another one.</span></span><br><span class="line">         EV &lt;&lt; <span class="string">&quot;Generating another message: &quot;</span>;</span><br><span class="line">         TicTocMsg13 *newmsg = <span class="built_in">generateMessage</span>();</span><br><span class="line">         EV &lt;&lt; newmsg &lt;&lt; endl;</span><br><span class="line">         forwardMessage(newmsg);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// We need to forward the message.</span></span><br><span class="line">         forwardMessage(ttmsg);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到处理报文的第一步首先要把收到的 msg 转换为自定义的 Message 的格式，这里个人有点不理解，如果 msg 本身不是自定义格式，那么转换会有什么结果呢？（可能需要再深入理解下 C++ 语法）<br>之后在判断语句位置可以看到 ttmsg 调用自定义 Message 的接口，格式大致就是 <code>getDestination()</code> 或者 <code>setDestination()</code>。通过将 destination 包含在 Message 中，可以更加灵活地指定，避免代码和参数的过度耦合。从 generateMessage 函数改变也可以看到自定义 Message 是如何写入的。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> msgname[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(msgname, <span class="string">&quot;tic-%d-to-%d&quot;</span>, src, dest);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// Create message object and set source and destination field.</span></span><br><span class="line">TicTocMsg13 *msg = <span class="keyword">new</span> <span class="built_in">TicTocMsg13</span>(msgname);</span><br><span class="line">msg-&gt;<span class="built_in">setSource</span>(src);</span><br><span class="line">msg-&gt;<span class="built_in">setDestination</span>(dest);</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="tictoc-14">Tictoc 14</h3><blockquote><p>In this step we keep track of how many messages we send and received. and display it above the icon.</p></blockquote><ul><li><p>ned 和 msg 文件和之前没有多少变化，最主要地是增加了 WATCH 函数的使用，方便我们更清楚地感知系统的状态。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc14::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize variables</span></span><br><span class="line">    numSent = <span class="number">0</span>;</span><br><span class="line">    numReceived = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WATCH</span>(numSent);</span><br><span class="line">    <span class="built_in">WATCH</span>(numReceived);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Module 0 sends the first message</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getIndex</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Boot the process scheduling the initial message as a self-message.</span></span><br><span class="line">        TicTocMsg14 *msg = <span class="built_in">generateMessage</span>();</span><br><span class="line">        numSent++;</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="number">0.0</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下<br><img src="../../post-images/34f2d8af3d2ac5eb558504b69966cec9_MD5.png" alt=""></p></li><li><p>Override 系统的 refreshDisplay 函数，打印出上图的效果，关于这部分没有具体查阅资料，后续补上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc14::refreshDisplay</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;rcvd: %ld sent: %ld&quot;</span>, numReceived, numSent);</span><br><span class="line">    <span class="built_in">getDisplayString</span>().<span class="built_in">setTagArg</span>(<span class="string">&quot;t&quot;</span>, <span class="number">0</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="tictoc-15">Tictoc 15</h3><blockquote><p>This model is exciting enough so that we can collect some statistics. We’ll record in output vectors the hop count of every message upon arrival. Output vectors are written into the omnetpp.vec file and can be visualized with the Plove program. We also collect basic statistics (min, max, mean, std.dev.) and histogram about the hop count which we’ll print out at the end of the simulation.</p></blockquote><p>增加了数据统计的功能，对于后续的数据分析很重要。</p><ul><li><p>首先要在 omnetpp.ini 中开启 record-evertlog，只有开启这个之后才能在代码中调用 <code>recordScalar</code> 函数，用了录制收集特定的数据，在该模块中是在 <code>finish()</code> 函数中开启的调用。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Tictoc15]</span><br><span class="line"> network = Tictoc15</span><br><span class="line"> record-eventlog = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>在私有成员中<strong>加入统计属性的变量</strong>，关于这两个类型的具体介绍见 Omnet++ manual 第 7.9 节。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cHistogram hopCountStats;</span><br><span class="line">cOutVector hopCountVector;</span><br></pre></td></tr></table></figure><p>其使用之前首先要在 <code>initlaize()</code> 中进行初始化</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hopCountStats.<span class="built_in">setName</span>(<span class="string">&quot;hopCountStats&quot;</span>);</span><br><span class="line">hopCountVector.<span class="built_in">setName</span>(<span class="string">&quot;HopCount&quot;</span>);</span><br></pre></td></tr></table></figure><p>调用方式</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hopcount = ttmsg-&gt;<span class="built_in">getHopCount</span>();</span><br><span class="line">EV &lt;&lt; <span class="string">&quot;Message &quot;</span> &lt;&lt; ttmsg &lt;&lt; <span class="string">&quot; arrived after &quot;</span> &lt;&lt; hopcount &lt;&lt; <span class="string">&quot; hops.\n&quot;</span>;</span><br><span class="line"><span class="built_in">bubble</span>(<span class="string">&quot;ARRIVED, starting new one!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update statistics.</span></span><br><span class="line">numReceived++;</span><br><span class="line">hopCountVector.<span class="built_in">record</span>(hopcount);</span><br><span class="line">hopCountStats.<span class="built_in">collect</span>(hopcount);</span><br></pre></td></tr></table></figure><p>以及最后调用 finish 收尾</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Txc15::finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This function is called by OMNeT++ at the end of the simulation.</span></span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Sent:     &quot;</span> &lt;&lt; numSent &lt;&lt; endl;</span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; numReceived &lt;&lt; endl;</span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Hop count, min:    &quot;</span> &lt;&lt; hopCountStats.<span class="built_in">getMin</span>() &lt;&lt; endl;</span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Hop count, max:    &quot;</span> &lt;&lt; hopCountStats.<span class="built_in">getMax</span>() &lt;&lt; endl;</span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Hop count, mean:   &quot;</span> &lt;&lt; hopCountStats.<span class="built_in">getMean</span>() &lt;&lt; endl;</span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Hop count, stddev: &quot;</span> &lt;&lt; hopCountStats.<span class="built_in">getStddev</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">recordScalar</span>(<span class="string">&quot;#sent&quot;</span>, numSent);</span><br><span class="line">    <span class="built_in">recordScalar</span>(<span class="string">&quot;#received&quot;</span>, numReceived);</span><br><span class="line"></span><br><span class="line">    hopCountStats.<span class="built_in">recordAs</span>(<span class="string">&quot;hop count&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结束可以看到一个 results 文件夹，里面内容如下<br><img src="../../post-images/9f59cc2a59b2106bf843a3bac9742108_MD5.png" alt="image-20220922223953758"></p></li></ul><p>具体每个文件如何使用，可以查看如下 <a href="https://www.cnblogs.com/ShineLeBlog/p/14767734.html">omnet++：官方文档翻译总结（五） - ShineLe - 博客园</a></p><hr><h3 id="tictoc-16">Tictoc 16</h3><blockquote><p>The main problem with the previous step is that we must modify the model’s code if we want to change what statistics are gathered. Statistic calculation is woven deeply into the model code which is hard to modify and understand.<br>OMNeT++ 4.1 provides a different mechanism called ‘signals’ that we can use to gather statistics. First we have to identify the events where the state of the model changes. We can emit signals at these points that carry the value of chosen state variables. This way the C++ code only emits signals, but how those signals are processed are determined only by the listeners that are attached to them.<br>The signals the model emits and the listeners that process them can be defined in the NED file using the ‘signal’ and ‘statistic’ property. We will gather the same statistics as in the previous step, but notice that we will not need any private member variables to calculate these values. We will use only a single signal that is emitted when a message arrives and carries the hopcount in the message.</p></blockquote><p>在 Tictoc 15 中</p><p>详见 <a href="https://www.cnblogs.com/ShineLeBlog/p/14765282.html">omnet++：官方文档翻译总结（四） - ShineLe - 博客园</a></p><ul><li><p>使用同一的接口 arrivalSignal 来替代之前的两个变量<br>Before</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cHistogram hopCountStats;</span><br><span class="line">cOutVector hopCountVector;</span><br></pre></td></tr></table></figure><p>Now</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">simsignal_t</span> arrivalSignal;</span><br></pre></td></tr></table></figure><p>通过这个接口避免了与特定的统计变量进行绑定，使其更加灵活。取而代之，原先的统计也相应地进行了修改。<br>Before</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hopCountVector.<span class="built_in">record</span>(hopcount);</span><br><span class="line">hopCountStats.<span class="built_in">collect</span>(hopcount);</span><br></pre></td></tr></table></figure><p>Now</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// send a signal</span><br><span class="line">emit(arrivalSignal, hopcount);</span><br></pre></td></tr></table></figure><p>同时需要注意在使用 arrivalSignal 之前必须先注册所有的 signals，注册代码通常放在 <code>initlaize()</code> 函数中。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrivalSignal = <span class="built_in">registerSignal</span>(<span class="string">&quot;arrival&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>由于我们不用保存任何数据，所以 <code>finish()</code>方法可以删去了。</p></li><li><p>最后是 ned 文件中定义 signal 的相关信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">simple Txc16</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @signal[arrival](type=<span class="string">&quot;long&quot;</span>);</span><br><span class="line">        @statistic[hopCount](title=<span class="string">&quot;hop count&quot;</span>; source=<span class="string">&quot;arrival&quot;</span>; record=vector,stats; interpolationmode=none);</span><br><span class="line"></span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=block/routing&quot;</span>);</span><br><span class="line">    gates:</span><br><span class="line">        inout gate[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该节中我们仍然是统计 hop count的信息（最大值、最小值、均值、总和等），所以让我们在本例中收集相同的数据。<code>source</code> 关键字指明了附加我们的统计数据的 signal；<code>record</code> 关键字告诉我们需要如何处理收到的数据。本例中我们需要将每个值都保存到 vector file（<code>vector</code> 关键字）中，此外还要统计上段中说到的那些统计信息（<code>stats</code> 关键字）。NED文件写完之后，我们就完成了我们的 model。</p><p>现在我们需要查看 tic[1] module 中关于hopCount的直方图，此外我们不需要记录tic 0,1,2的vector data。我们可以不用修改 C++ 和 NED 文件来实现添加直方图并且移除不需要的 vector 的目的，只需要打开 ini 文件并且修改统计数据的记录语句即可。如下所示</p></li><li><p><code>Omnetpp.ini</code> 修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Tictoc16]</span><br><span class="line">network = Tictoc16</span><br><span class="line">**.tic[<span class="number">1</span>].hopCount.result-recording-modes = +histogram</span><br><span class="line">**.tic[<span class="number">0.</span><span class="number">.2</span>].hopCount.result-recording-modes = -vector</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="tictoc-17">Tictoc 17</h3><blockquote><p>官方没有注释</p></blockquote><p>OMNET++可以在 canvas 上展示一系列的 figures，例如文本、几何图形、图像。这些figures可以是静态的，也可以根据仿真过程中发生的事件动态变化。本例中，我们展示了静态描述文本、动态显示hop count的文本。</p><ul><li><p>在ned文件中创建figures，需要在parameters用@figure说明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">network Tictoc17</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @figure[description](type=text;pos=<span class="number">5</span>,<span class="number">20</span>;font=,,bold;</span><br><span class="line">                    text=<span class="string">&quot;Random routing example - displaying last hop count&quot;</span>);</span><br><span class="line">        @figure[lasthopcount](type=text;pos=<span class="number">5</span>,<span class="number">35</span>;text=<span class="string">&quot;last hopCount: N/A&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里创建了两个文本 figure，它们的名字是 <code>description</code> 和 <code>lasthopcount</code>，并且设置了它们的位置坐标。font 参数说明了文本字体，有三个分量——typeface, size, style。这三个分量中的每一个都可以略去，这样实际中会代之以默认值。本例中我们只是设置了字体的 style 为 bold。</p></li><li><p>默认情况下 lasthopcount 中的文本是静态的，但是当消息到达时需要修改它。要做到这一点，需要修改<code>handleMessage()</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">hasGUI</span>())&#123;</span><br><span class="line">    <span class="type">char</span> label[<span class="number">50</span>];</span><br><span class="line">    <span class="comment">//把last hop count写为string形式</span></span><br><span class="line">    <span class="built_in">sprintf</span>(label,<span class="string">&quot;last hopCount = %d&quot;</span>,hopcount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个指向figure的指针</span></span><br><span class="line">    cCanvas * canvas = <span class="built_in">getParentModule</span>()-&gt;<span class="built_in">getCanvas</span>();</span><br><span class="line">    cTextFigure *textFigure = <span class="built_in">check_and_cast</span>&lt;cTextFigure*&gt;(canvas-&gt;<span class="built_in">getFigure</span>(<span class="string">&quot;lasthopcount&quot;</span>));</span><br><span class="line">    <span class="comment">//更新文本</span></span><br><span class="line">    textFigure-&gt;<span class="built_in">setText</span>(label);&#125;</span><br></pre></td></tr></table></figure><p>文件中用 <code>cTextFigure</code> 这个 class 代表 figure。figure types有很多种，所有都是继承自<code>cFigure</code>的子类。我们在得到<code>hopCount</code>变量之后，即可写入代码并更新文本。</p><p>对上文代码的解释，我们要在 network 的 canvas 上画 figures，<code>getParentModule()</code>函数返回这个节点的父 module，比如 network。<code>getCanvas()</code>函数返回 network 的 canvas，<code>getFigure()</code>可以通过 Figure 名得到figure。之后我们用<code>setText()</code>函数更新 figure 文本。</p><p>当我们运行仿真时，在第一个消息到达前，figure 会显示 “last hopCount：N/A”。之后，每当一个消息到达它的目的地时，这个文本都会更新。</p><p><img src="../../post-images/5eda3d270cb76b1c46fb969db66fcf18_MD5.png" alt="img"></p></li><li><p>如果对布局不满意，比如figure文本和节点重叠在一块了，可以点击“re-layout”</p><p><img src="../../post-images/52ca65052a17614d3c7f74b1a7dba977_MD5.png" alt="img"></p></li></ul><hr><h3 id="tictoc-18">Tictoc 18</h3><ul><li><p>哑铃型的网络拓扑结构，两端各两个节点连接，中间 <code>numCentralNodes</code> 个节点连接。中心节点数目为 4 时形状大致如下</p><p><img src="../../post-images/ab798846cb30ebef1bae08bbff92d8e9_MD5.png" alt="img"></p><p>对比下面代码可能更容易理解些，for 循环前是左端两个节点的连接，for 循环则是中间多个节点依次连接，for 循环后则是右端两个节点的连接。因为 tictoc 中节点是从 0 开始的，因此右端节点连接时注意 + 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">simple Txc18 extends Txc16</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network TicToc18</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        <span class="type">int</span> numCentralNodes = <span class="built_in">default</span>(<span class="number">2</span>);</span><br><span class="line">    types:</span><br><span class="line">        channel Channel extends ned.DelayChannel &#123;</span><br><span class="line">            delay = <span class="number">100</span>ms;</span><br><span class="line">        &#125;</span><br><span class="line">    submodules:</span><br><span class="line">        tic[numCentralNodes+<span class="number">4</span>]: Txc18;</span><br><span class="line">    connections:</span><br><span class="line">        <span class="comment">// connect the 2 nodes in one side to the central nodes</span></span><br><span class="line">        tic[<span class="number">0</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[<span class="number">2</span>].gate++;</span><br><span class="line">        tic[<span class="number">1</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[<span class="number">2</span>].gate++;</span><br><span class="line">        <span class="comment">// connect the central nodes together</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">2.</span>.numCentralNodes+<span class="number">1</span> &#123;</span><br><span class="line">            tic[i].gate++ &lt;--&gt; Channel &lt;--&gt; tic[i+<span class="number">1</span>].gate++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// connect the 2 nodes on the other side to the central nodes</span></span><br><span class="line">        tic[numCentralNodes+<span class="number">2</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[numCentralNodes+<span class="number">1</span>].gate++;</span><br><span class="line">        tic[numCentralNodes+<span class="number">3</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[numCentralNodes+<span class="number">1</span>].gate++;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>指定中心节点的数量 N 从 2 到 100，步长为 2，产生 50 次仿真；</p><p>为了提高仿真准确度，我们需要用不同的随机数运行多次运行相同的仿真。这样的运行称为 Repetitions 并且在 ini 文件中加以指定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*.numCentralNodes = $&#123;N=<span class="number">2.</span><span class="number">.100</span> step <span class="number">2</span>&#125;</span><br><span class="line">repeat = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>每个仿真都要被运行4次，每次都有不同的 seed。这可以提供更多的样本，使结果更加平均。重复的越多，结果将会越来越变成期望的结果。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Omnet-Veins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Veins Module 浅析1 -- AnalogueModels 的调用逻辑</title>
      <link href="/posts/Omnet-Veins/20220918-veins-analoguemodels.html"/>
      <url>/posts/Omnet-Veins/20220918-veins-analoguemodels.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-主要逻辑">1. 主要逻辑</h2><p>该部分代码的主要实现逻辑如下所示，函数位置在 BasePhyLayer 模块 <code>initializeAnalogueModels</code> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BasePhyLayer -&gt; <span class="function"><span class="type">void</span> <span class="title">initializeAnalogueModels</span><span class="params">(cXMLElement* xmlConfig)</span></span>;</span><br><span class="line"></span><br><span class="line">BasePhyLayer -&gt; <span class="function">std::unique_ptr&lt;AnalogueModel&gt; <span class="title">getAnalogueModelFromName</span><span class="params">(std::string name, ParameterMap&amp; params)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">PhyLayer80211p -&gt; unique_ptr&lt;AnalogueModel&gt; <span class="title">PhyLayer80211p::getAnalogueModelFromName</span><span class="params">(std::string name, ParameterMap&amp; params)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">PhyLayer80211p -&gt; unique_ptr&lt;AnalogueModel&gt; <span class="title">PhyLayer80211p::initializeSimpleObstacleShadowing</span><span class="params">(ParameterMap&amp; params)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">···</span></span><br></pre></td></tr></table></figure><p>通过这几步后将所有 Analogue Model 汇总到 BasePhyLayer 中 analogueModels 成员变量里，供后续 Signal 来处理仿真真实环境。</p><p>不同种类的衰落模型都派生自 AnalogueModel 类，其包括一个重要的纯虚函数 <code>virtual void filterSignal(Signal* signal)</code> ，由其他不同类型的模型来 override 实现不同程度的衰落。</p><h2 id="2-调用关系">2. 调用关系</h2><p>前面说完了 Analogue Model 内部生成的逻辑，下面记录下项目中实际调用的逻辑。其主要在 BaseDecider 模块中用来处理不同的 Signal，函数调用如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">simtime_t</span> <span class="title">BaseDecider::processSignal</span><span class="params">(AirFrame* frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(frame);</span><br><span class="line">    EV_INFO &lt;&lt; <span class="string">&quot;Processing AirFrame...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">getSignalState</span>(frame)) &#123;</span><br><span class="line">    <span class="keyword">case</span> NEW:</span><br><span class="line">        EV_INFO &lt;&lt; <span class="string">&quot;process new signal&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">processNewSignal</span>(frame);</span><br><span class="line">    <span class="keyword">case</span> EXPECT_HEADER:</span><br><span class="line">        EV_INFO &lt;&lt; <span class="string">&quot;process signal header&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">processSignalHeader</span>(frame);</span><br><span class="line">    <span class="keyword">case</span> EXPECT_END:</span><br><span class="line">        EV_INFO &lt;&lt; <span class="string">&quot;process signal end&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">processSignalEnd</span>(frame);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        EV_INFO &lt;&lt; <span class="string">&quot;process unknown signal&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">processUnknownSignal</span>(frame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>processNewSignal(frame)</code> 函数承担主要功能，在 BaseDecider 中作为虚函数有一个基本实现，后其在 Decider80211p 中重新 override 该函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">simtime_t</span> <span class="title">Decider80211p::processNewSignal</span><span class="params">(AirFrame* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EV_INFO &lt;&lt; <span class="string">&quot;Decider80211p::processNewSignal&quot;</span> &lt;&lt; endl;</span><br><span class="line">    AirFrame11p* frame = <span class="built_in">check_and_cast</span>&lt;AirFrame11p*&gt;(msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the receiving power of the Signal at start-time and center frequency</span></span><br><span class="line">    Signal&amp; signal = frame-&gt;<span class="built_in">getSignal</span>();</span><br><span class="line"></span><br><span class="line">    signalStates[frame] = EXPECT_END;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal.<span class="built_in">smallerAtCenterFrequency</span>(minPowerLevel)) &#123;</span><br><span class="line">        EV_INFO &lt;&lt; <span class="string">&quot;current signal smaller at center frequency&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// annotate the frame, so that we won&#x27;t try decoding it at its end</span></span><br><span class="line">        frame-&gt;<span class="built_in">setUnderMinPowerLevel</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// check channel busy status. a superposition of low power frames might turn channel status to busy</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cca</span>(<span class="built_in">simTime</span>(), <span class="literal">nullptr</span>) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="built_in">setChannelIdleStatus</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> signal.<span class="built_in">getReceptionEnd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        EV_INFO &lt;&lt; <span class="string">&quot;current signal bigger at center frequency&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// This value might be just an intermediate result (due to short circuiting)</span></span><br><span class="line">        <span class="type">double</span> recvPower = signal.<span class="built_in">getAtCenterFrequency</span>();</span><br><span class="line">        <span class="built_in">setChannelIdleStatus</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (phy11p-&gt;<span class="built_in">getRadioState</span>() == Radio::TX) &#123;</span><br><span class="line">            frame-&gt;<span class="built_in">setBitError</span>(<span class="literal">true</span>);</span><br><span class="line">            frame-&gt;<span class="built_in">setWasTransmitting</span>(<span class="literal">true</span>);</span><br><span class="line">            EV_INFO &lt;&lt; <span class="string">&quot;AirFrame: &quot;</span> &lt;&lt; frame-&gt;<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; recvPower &lt;&lt; <span class="string">&quot;) received, while already sending. Setting BitErrors to true&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            EV_INFO &lt;&lt; <span class="string">&quot;phy11p-&gt;getRadioState() != Radio::TX&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (!currentSignal.first) &#123;</span><br><span class="line">                <span class="comment">// NIC is not yet synced to any frame, so lock and try to decode this frame</span></span><br><span class="line">                currentSignal.first = frame;</span><br><span class="line">                EV_INFO &lt;&lt; <span class="string">&quot;AirFrame: &quot;</span> &lt;&lt; frame-&gt;<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; with (&quot;</span> &lt;&lt; recvPower &lt;&lt; <span class="string">&quot; &gt; &quot;</span> &lt;&lt; minPowerLevel &lt;&lt; <span class="string">&quot;) -&gt; Trying to receive AirFrame.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">if</span> (notifyRxStart) &#123;</span><br><span class="line">                    phy-&gt;<span class="built_in">sendControlMsgToMac</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;RxStartStatus&quot;</span>, MacToPhyInterface::PHY_RX_START));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// NIC is currently trying to decode another frame. this frame will be simply treated as interference</span></span><br><span class="line">                EV_INFO &lt;&lt; <span class="string">&quot;AirFrame: &quot;</span> &lt;&lt; frame-&gt;<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; with (&quot;</span> &lt;&lt; recvPower &lt;&lt; <span class="string">&quot; &gt; &quot;</span> &lt;&lt; minPowerLevel &lt;&lt; <span class="string">&quot;) -&gt; Already synced to another AirFrame. Treating AirFrame as interference.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// channel turned busy</span></span><br><span class="line">            <span class="comment">// measure communication density</span></span><br><span class="line">            myBusyTime += signal.<span class="built_in">getDuration</span>().<span class="built_in">dbl</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> signal.<span class="built_in">getReceptionEnd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其中有一个很重要的判断 <code>signal.smallerAtCenterFrequency(minPowerLevel)</code> 调用了 Analogue Model 来模拟实际环境。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Signal::smallerAtCenterFrequency</span><span class="params">(<span class="type">double</span> threshold)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EV_INFO &lt;&lt; <span class="string">&quot;signal power is &quot;</span> &lt;&lt; values[centerFrequencyIndex] &lt;&lt; <span class="string">&quot; threshold is &quot;</span> &lt;&lt; threshold &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (values[centerFrequencyIndex] &lt; threshold) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> maxAnalogueModels = analogueModelList-&gt;<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (numAnalogueModelsApplied &lt; maxAnalogueModels) &#123;</span><br><span class="line">        <span class="comment">// Apply filter here</span></span><br><span class="line">        (*analogueModelList)[numAnalogueModelsApplied]-&gt;<span class="built_in">filterSignal</span>(<span class="keyword">this</span>);</span><br><span class="line">        numAnalogueModelsApplied++;</span><br><span class="line">        <span class="keyword">if</span> (values[centerFrequencyIndex] &lt; threshold) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在其中分别调用不同的衰落模型来 filter signal，当所有模型调用结束后如果得到的功率大小满足要求，则后面便可以把 frame 进一步发送到更上一层来进行处理。</p>]]></content>
      
      
      <categories>
          
          <category> Omnet-Veins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> Veins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结合 Veins 来看 Omnet 的 Signal 机制</title>
      <link href="/posts/Omnet-Veins/20220918-veins-omnet-simsignal-management.html"/>
      <url>/posts/Omnet-Veins/20220918-veins-omnet-simsignal-management.html</url>
      
        <content type="html"><![CDATA[<p>首先应该从<code>receiveSignal</code>函数开始说起，既然说起 <code>receiveSignal</code> 那也一定要谈下其所属类 baseModule，关于其官方是这么介绍的</p><p><em><strong>Base class for all simple modules of a host</strong>. This method raises an error if the host state changes to something else than ACTIVE. Therefore that a sub-classing module can be used in a simulation where the host state can change it has to override that method which forces the author to make sure the module reacts well to host state changes.</em></p><p><em>Alternatively one can also set a “<code>notAffectedByHostState</code>” parameter of the module to true.  The base module additionally provides a function <code>findHost</code> which returns a pointer to the host module and a function hostIndex to return the index of the host module. The latter one correspondes to the index shown in tkenv and comes in very handy for testing and debugging using tkenv. It is used e.g. in all the ‘print’ macros used for debugging. There will never be a stand-alone BaseModule module.</em></p><p><em>Note: most modules wont derive from BaseModule directly but from its sub class “BatteryAccess” which extends BaseModule by several methods for accessing the battery module.</em></p><p>在其下实现了很多接口函数，其派生类里也调用其来注册订阅 signal，如应用层的 DemoBaseApplLayer，在 <code>initialize()</code> 函数的初始化中订阅了 mobility 消息和 parking 消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">findHost</span>()-&gt;<span class="built_in">subscribe</span>(BaseMobility::mobilityStateChangedSignal, <span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">findHost</span>()-&gt;<span class="built_in">subscribe</span>(TraCIMobility::parkingStateChangedSignal, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>之后继承了 BaseModule 中的 <code>receiveSignal</code> 函数并 override</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DemoBaseApplLayer::receiveSignal</span><span class="params">(cComponent* source, <span class="type">simsignal_t</span> signalID, cObject* obj, cObject* details)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Enter_Method_Silent</span>();</span><br><span class="line">    EV_INFO &lt;&lt; <span class="string">&quot;Run DemoBaseApplLayer::receiveSignal&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (signalID == BaseMobility::mobilityStateChangedSignal) &#123;</span><br><span class="line">        <span class="built_in">handlePositionUpdate</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (signalID == TraCIMobility::parkingStateChangedSignal) &#123;</span><br><span class="line">        <span class="built_in">handleParkingUpdate</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即只有收到 Basemobility::mobilityStateChangedSignal 信号后才进行位置的变动处理。</p><p>OMNet++ 在仿真中使用 Simulation Signals（或者 Signals）来实现 <strong>“发布-订阅”</strong> 机制。假设信号发送模块如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module emitting some signal whenever it receives a message (contrived example)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SignalEmitter</span>: <span class="keyword">public</span> cModule &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">simsignal_t</span> counterSignal;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">simsignal_t</span> nameSignal;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">long</span> messageCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleMessage</span><span class="params">(cMessage *msg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">emit</span>(counterSignal, messageCounter);</span><br><span class="line">        messageCounter++;</span><br><span class="line">        <span class="built_in">emit</span>(nameSignal, msg-&gt;<span class="built_in">str</span>());</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">simsignal_t</span> SignalEmitter::counterSignal = <span class="built_in">registerSignal</span>(<span class="string">&quot;messageCounter&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">simsignal_t</span> SignalEmitter::nameSignal = <span class="built_in">registerSignal</span>(<span class="string">&quot;messageName&quot;</span>);</span><br></pre></td></tr></table></figure><p>虽然很容易配置和发出信号，但信号反应的实现特别复杂包括一系列模板类代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module reacting to signals in plain OMNeT++ fashion, has to inherit from cListener or implement cIListener</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithoutSignalCallbacks</span>: <span class="keyword">public</span> cModule, <span class="keyword">public</span> cListener &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// subscribe to the signal with itself as handler</span></span><br><span class="line">        <span class="built_in">subscribe</span>(SignalEmitter::counterSignal, <span class="keyword">this</span>);</span><br><span class="line">        <span class="built_in">subscribe</span>(SignalEmitter::nameSignal, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// signal handler for all signals with a long parameter</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receiveSignal</span><span class="params">(cComponent* source, <span class="type">simsignal_t</span> signalID, <span class="type">long</span> l, cObject* details)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// identify signal to handle</span></span><br><span class="line">        <span class="keyword">if</span> (signalID == SignalEmitter::counterSignal) &#123;</span><br><span class="line">            <span class="comment">// react to signal</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Module &quot;</span> &lt;&lt; source-&gt;<span class="built_in">getFullName</span>() &lt;&lt; <span class="string">&quot; received message nr &quot;</span> &lt;&lt; l &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// signal handler for all signals with a string parameter</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receiveSignal</span><span class="params">(cComponent* source, <span class="type">simsignal_t</span> signalID, <span class="type">const</span> <span class="type">char</span>* s, cObject* details)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// identify signal to handle</span></span><br><span class="line">        <span class="keyword">if</span> (signalID == SignalEmitter::nameSignal) &#123;</span><br><span class="line">            <span class="comment">// react to signal</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Module &quot;</span> &lt;&lt; source-&gt;<span class="built_in">getFullName</span>() &lt;&lt; <span class="string">&quot; received message with content &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="signalmanager">SignalManager</h2><p>使用 [SignalManager]，可以封装所有信号处理，并将配置保留在一个地方:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module reacting to signals using the SignalManager</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithSignalManager</span>: <span class="keyword">public</span> cModule &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    veins::SignalManager signalManager;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reaction to the signal</span></span><br><span class="line">        <span class="keyword">auto</span> nameSignalCallback = [<span class="keyword">this</span>](veins::SignalPayload&lt;<span class="type">const</span> <span class="type">char</span>*&gt; payload) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Module &quot;</span> &lt;&lt; payload.source-&gt;<span class="built_in">getFullName</span>() &lt;&lt; <span class="string">&quot; received message with content &quot;</span> &lt;&lt; payload.p &lt;&lt; std::endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> counterSignalCallback = [<span class="keyword">this</span>](veins::SignalPayload&lt;<span class="type">long</span>&gt; payload) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Module &quot;</span> &lt;&lt; payload.source-&gt;<span class="built_in">getFullName</span>() &lt;&lt; <span class="string">&quot; received message nr &quot;</span> &lt;&lt; payload.p &lt;&lt; <span class="string">&quot; via signal &quot;</span> &lt;&lt; payload.signalID &lt;&lt; std::endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// register callbacks with the signal manager, which takes care to perform the actual subscription</span></span><br><span class="line">        signalManager.<span class="built_in">subscribeCallback</span>(<span class="built_in">getSystemModule</span>(), SignalEmitter::nameSignal, nameSignalCallback);</span><br><span class="line">        signalManager.<span class="built_in">subscribeCallback</span>(<span class="built_in">getSystemModule</span>(), SignalEmitter::counterSignal, counterSignalCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="signalcallbacklistener">SignalCallbackListener</h2><p>或者，我们可以省略 Manager 部分并为每个注册的回调创建单独的 [SignalCallbackListener] 对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module reacting to signals using the SignalCallback instances</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithSignalCallbacks</span>: <span class="keyword">public</span> cModule &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    veins::SignalCallbackListener counterCallback;</span><br><span class="line">    veins::SignalCallbackListener nameCallback;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reaction to the signal</span></span><br><span class="line">        <span class="keyword">auto</span> nameSignalCallback = [<span class="keyword">this</span>](veins::SignalPayload&lt;<span class="type">const</span> <span class="type">char</span>*&gt; payload) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Module &quot;</span> &lt;&lt; payload.source-&gt;<span class="built_in">getFullName</span>() &lt;&lt; <span class="string">&quot; received message with content &quot;</span> &lt;&lt; payload.p &lt;&lt; std::endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> counterSignalCallback = [<span class="keyword">this</span>](veins::SignalPayload&lt;<span class="type">long</span>&gt; payload) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Module &quot;</span> &lt;&lt; payload.source-&gt;<span class="built_in">getFullName</span>() &lt;&lt; <span class="string">&quot; received message nr &quot;</span> &lt;&lt; payload.p &lt;&lt; <span class="string">&quot; via signal &quot;</span> &lt;&lt; payload.signalID &lt;&lt; std::endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// register callback objects, which takes care to perform the actual subscription</span></span><br><span class="line">        counterCallback = veins::<span class="built_in">SignalCallbackListener</span>(<span class="built_in">getSystemModule</span>(), SignalEmitter::counterSignal, counterSignalCallback);</span><br><span class="line">        nameCallback = veins::<span class="built_in">SignalCallbackListener</span>(<span class="built_in">getSystemModule</span>(), SignalEmitter::nameSignal, nameCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样可以更清楚地控制每个 SignalCallbackListener 实例的生命周期。</p><h2 id="common-features">Common Features</h2><p>使用 [SignalManager] 和 [SignalCallbackListener] 的话便无需自己实现 cIListener，生命周期是自动管理的，并且代码都保存在一个地方，除了 Lambda 还可以使用其他形式的回调例如仿函数。</p>]]></content>
      
      
      <categories>
          
          <category> Omnet-Veins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows CMake 引用自编译 glog 库和 gflag 库报错问题</title>
      <link href="/posts/System-development/20220622-windows-cmake-glog-error.html"/>
      <url>/posts/System-development/20220622-windows-cmake-glog-error.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find_package(Gflags REQUIRED PATHS &quot;D:/3DAT_Environment/buildDir/gflags/lib/cmake/gflags&quot;)</span><br><span class="line">find_package(Glog   REQUIRED PATHS &quot;D:/3DAT_Environment/buildDir/glog/lib/cmake/glog&quot;)</span><br></pre></td></tr></table></figure><p>如上所示，gflags 库单独所以是可以找到的，但再查找 glog 时则提示无法找到 gflags。<br>查找一番后大体定位问题在于 glog 会重新调用系统 cmake find 来查找 gflags 而不是调用自己设定的路径，大致问题描述如下。</p><ul><li><a href="https://www.cnblogs.com/cyssmile/p/14372044.html">glog编译依赖gfags导致问题 - cyssmile - 博客园</a><br>最后解决方案是，在 glog 的  glog-config.cmake 中加入 gflags 的路径，然后再次调用就可以了。<br><img src="../../post-images/91e8a619de57c2e4e7bb91c009baa93b_MD5.png" alt="|575"></li></ul>]]></content>
      
      
      <categories>
          
          <category> System-development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> Bug调试 </tag>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下编译 Ceres</title>
      <link href="/posts/System-development/20220622-windows11-build-ceres.html"/>
      <url>/posts/System-development/20220622-windows11-build-ceres.html</url>
      
        <content type="html"><![CDATA[<h2 id="main">Main</h2><h3 id="1-编译依赖及相关版本">1. 编译依赖及相关版本</h3><ul><li>Windows 11</li><li>VS 2019 Community</li><li>CMake GUI 3.23</li><li>Ceres-solver 1.14.0<br><a href="https://github.com/ceres-solver/ceres-solver/releases/tag/1.14.0">Release 1.14.0 · ceres-solver/ceres-solver (github.com)</a></li><li>Eigen 3.3.7（3.3.8 存在 bug，编译 Ceres 时会报错）<br><a href="https://gitlab.com/libeigen/eigen/-/releases/3.3.7">Eigen 3.3.7 · libeigen / eigen · GitLab</a></li><li>gflags 2.2.2<br><a href="https://github.com/gflags/gflags/releases">Releases · gflags/gflags (github.com)</a></li><li>gflog 0.6.0<br><a href="https://github.com/google/glog/releases/tag/v0.6.0">Release google-glog 0.6.0 · google/glog (github.com)</a></li><li>suitesparse-metis-for-windows 1.5.0<br><a href="https://github.com/jlblancoc/suitesparse-metis-for-windows/releases">Releases · jlblancoc/suitesparse-metis-for-windows (github.com)</a></li><li>Intel MKL<br><a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl-download.html?operatingsystem=window&amp;distributions=webdownload&amp;options=offline">Get Intel® oneAPI Math Kernel Library</a></li></ul><h3 id="2-编译步骤">2. 编译步骤</h3><p>由于要编译和安装的库比较多，于是参考链接[1] 建立了一个文件夹来统一存放<br><img src="../../post-images/Pasted%20image%2020231205222400.png" alt="|450"></p><p>buildDir 用来存放安装后的 include 和 lib 文件，buildSrc 用来存放需要编译的源码文件，originFiles 则用来存放下载的原始代码包，后续 CMake 里面都注意修改安装的最后路径（一般是 <code>CMAKE_INSTALL_PREFIX</code>）。</p><h4 id="2-1-安装-mkl-库">2.1. 安装 MKL 库</h4><p><a href="https://www.intel.com/content/www/us/en/develop/documentation/get-started-with-mkl-for-dpcpp/top.html">Get Started with Intel® oneAPI Math Kernel Library</a><br>从链接下载 oneAPI exe 安装，安装完成后可以在目录下看到 mkl 的相关库<br><img src="../../post-images/image-20220514083959-vy6puw1.png" alt="|500"><br>后续主要使用 <code>mkl_intel_Ip64.lib</code> 和 <code>mkl_intel_Ip64_dll.lib</code></p><h4 id="2-2-编译-glog-和-glag">2.2. 编译 glog 和 glag</h4><p>两个在编译过程中，都注意去掉 <code>BUILD_TESTING</code> 选项，同时选中 <code>BUILD_SHARED_LIBS</code> 以便生成<code>.dll</code>文件。如果该项不存在通过“Add Entry”手动加入，后续程序运行时可能会提示需要 glog 或 gflag.dll 文件。</p><h4 id="2-3-编译-eigen">2.3. 编译 Eigen</h4><p>Eigen 库本身是不需要安装的，这里为了将其与其他库统一位置方便来安装。这里编译选项中也取消掉 <code>BUILD_TESTING</code> 选项即可。</p><h4 id="2-4-编译-suitesparse">2.4. 编译 SuitesParse</h4><blockquote><p>根据参考链接[1] 这步也可以只生成静态库</p></blockquote><p>这步比较麻烦，通过使用 suitesparse-metis-for-windows 编译框架，里面已经自带了相应版本的 SuitesParse 代码，如 1.3.1 版本中版本为 <u>Bundled versions: SuiteSparse 4.5.1, Metis 5.1.0</u>。下面分两步来执行<br>首先生成静态库，编译选项中不选择 <code>SHARED</code> 和 <code>HAVE_COMPLEX</code>，按照步骤编译生成。然后再生成动态库，这次编译选项中选择 <code>SHARED</code> 其余不变，然后再次编译工程安装。</p><h4 id="2-5-编译-ceres">2.5. 编译 Ceres</h4><p>终于到了最后一步，开始添加和新建各种相关的环境路径了。分三小步来进行方便配置</p><ul><li><strong>依赖配置</strong><br>根据情况如果自动找到了就不需要配置，主要是如下几个<ul><li><code>gflags_DIR</code> ： D:/3DAT_Environment/buildDir/gflags/lib/cmake/gflags</li><li><code>glog_DIR</code> ：D:/3DAT_Environment/buildDir/glog/lib/cmake/glog</li><li><code>Eigen3_DIR</code> ： D:/3DAT_Environment/buildDir/eigen/share/eigen3/cmake</li><li><code>SuritesParse</code> 有点多，如下图所示几个<img src="../../post-images/Pasted%20image%2020231205222513.png" alt=""></li><li><code>BLAS_LIBRARIES</code>：D:/3DAT_Environment/buildDir/suitesparse/lib64/lapack_blas_windows/libblas.lib</li><li><code>LAPACK_LIBRARIES</code>：D:/3DAT_Environment/buildDir/suitesparse/lib64/lapack_blas_windows/liblapack.lib</li><li><code>CMAKE_INSTALL_PREFIX</code>：D:/3DAT_Environment/buildDir/ceres</li></ul></li><li><strong>依赖勾选</strong><ul><li>LAPACK 选中：ceres直接使用LAPACK</li><li>CUSTOM_BLAS: 选中，使用手动编码的blas代替eigen(通常更快)</li><li>SUITESPARSE：选中，为了加速稀疏矩阵的运算</li><li>gflags: 选中</li></ul></li><li>其他编译选项<ul><li>BUILD_EXAMPLES 取消勾选。为了节省后续编译时间。</li><li>BUILD_TESTING 取消勾选，为了节省后续编译时间。</li><li>BUILD_SHARED_LIBS 勾选，以便生成动态链接库文件。</li><li>CMAKE_BUILD_TYPE 设为 Release<br>通过以上填写后 Configure 和 Generate 后，应该可以看到成功的输出结果</li></ul></li></ul><h3 id="3-配置工程环境变量">3. 配置工程环境变量</h3><p>在系统环境变量 PATH 中加入以下 4 个地址<br><img src="../../post-images/Pasted%20image%2020231205222535.png" alt="|475"><br>然后在 VS 工程中加入 Ceres 及相关库的 include 和 lib 路径，下面编译运行官方 Example 示例进行测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simple example of using the Ceres minimizer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Minimize 0.5 (10 - x)^2 using jacobian matrix computed using</span></span><br><span class="line"><span class="comment">// automatic differentiation.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ceres/ceres.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glog/logging.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ceres::AutoDiffCostFunction;</span><br><span class="line"><span class="keyword">using</span> ceres::CostFunction;</span><br><span class="line"><span class="keyword">using</span> ceres::Problem;</span><br><span class="line"><span class="keyword">using</span> ceres::Solve;</span><br><span class="line"><span class="keyword">using</span> ceres::Solver;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A templated cost functor that implements the residual r = 10 -</span></span><br><span class="line"><span class="comment">// x. The method operator() is templated so that we can then use an</span></span><br><span class="line"><span class="comment">// automatic differentiation wrapper around it to generate its</span></span><br><span class="line"><span class="comment">// derivatives.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CostFunctor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T *<span class="type">const</span> x, T *residual)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        residual[<span class="number">0</span>] = <span class="number">10.0</span> - x[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The variable to solve for with its initial value. It will be</span></span><br><span class="line">    <span class="comment">// mutated in place by the solver.</span></span><br><span class="line">    <span class="type">double</span> x = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> initial_x = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the problem.</span></span><br><span class="line">    Problem problem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the only cost function (also known as residual). This uses</span></span><br><span class="line">    <span class="comment">// auto-differentiation to obtain the derivative (jacobian).</span></span><br><span class="line">    CostFunction *cost_function = <span class="keyword">new</span> <span class="built_in">AutoDiffCostFunction</span>&lt;CostFunctor, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> CostFunctor);</span><br><span class="line">    problem.<span class="built_in">AddResidualBlock</span>(cost_function, <span class="literal">nullptr</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the solver!</span></span><br><span class="line">    Solver::Options options;</span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line">    Solver::Summary summary;</span><br><span class="line">    <span class="built_in">Solve</span>(options, &amp;problem, &amp;summary);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x : &quot;</span> &lt;&lt; initial_x &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="725"><img src="../../post-images/image-20220514092035-xerxtin.png" alt="|725"></h2><h2 id="参考链接">参考链接</h2><p>[1]. <a href="https://blog.csdn.net/blanklog/article/details/105011085">(72条消息) Windows Ceres 编译安装_blanklog的博客-CSDN博客_windows编译ceres</a><br>[2].<a href="https://www.pianshen.com/article/3369143023/">Ceres Solver 在Windows下安装配置笔记 - 程序员大本营 (pianshen.com)</a><br>[3]. <a href="https://blog.csdn.net/qq_43008718/article/details/120463399">(72条消息) error C2589: “(”: “::”右边的非法标记 error C2059: 语法错误 : “::”_hgj 每天快乐学习的博客-CSDN博客</a><br>[4].<a href="https://jinyu.li/2017/03/21/compile-ceres/">Ceres Solver 的编译 - Jinyu Li</a></p>]]></content>
      
      
      <categories>
          
          <category> System-development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> Windows </tag>
            
            <tag> Ceres </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactive Planner的原理及实现</title>
      <link href="/posts/Automotive/20191127-reactive-planner.html"/>
      <url>/posts/Automotive/20191127-reactive-planner.html</url>
      
        <content type="html"><![CDATA[<p>Reactive Planner 作为一种常见的规划控制方法，国内外已经有很多人进行了理论研究和工程应用。其大体实现流程可以分为这么几个部分：1. 生成轨迹簇；2. 碰撞检测；3. 选择最优路径。下面逐个介绍各个部分。</p><h2 id="1-车辆的动力学模型">1. 车辆的动力学模型</h2><p>需要理解的是，Reactive Planner 作为 Local Planner 的一种思路，必须考虑车辆的运动学模型，理由是轨迹的可执行与否就在于是否满足车体的运动学约束。在这简单区分车辆的运动学模型和车辆的力学模型区别（课程中介绍）<br><img src="../../post-images/b73c7bfd04d555504b380d1ebe3f3e13_MD5.png" alt="|500"><br>运行学模型侧重于线性和角速度，有时也使用其导数如线加速度和角加速度作为其输入，而力学模型则侧重于力和扭矩作为输入。在这简单拿一个运动学粒子模型进行了对比。对于路径规划和轨迹优化，我们都是使用运动学模型，使得问题在计算上更容易处理，而将忽略力学模型带来的影响留给控制器去解决。<br>下面重新回顾下车辆的经典运动学模型 – 自行车模型：<br><img src="../../post-images/cf7d6a623c30330c2c8f0d3bb9544adc_MD5.png" alt="|500"><br>车辆的基本坐标用(x, y)来表示，航向设为相对于 x 轴的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span> 。这三个值共同确定了车辆的当前状态。对于自行车模型，在每个时间点给出的输入是速度和转向角。这些输入以及当前状态使我们能够根据自行车模型的运动学方程来计算轨迹如何随时间变化。要注意的是，我们一般是无法直接控制车辆达到某状态的，不能说直接告诉车辆去(x, y)特定位置。但是，我们可以设计一系列控制输入，从而根据车辆的运动学方程到达所述位置。控制输入的顺序与车辆遵循的轨迹相对应。<br>明白这些后，下面就要介绍如何进行操作了。对于车辆的运动方程，其实质就是一个连续时间微分方程，在实际使用中对模型进行离散，从而有效地生成给定控制输入序列的轨迹。离散连续时间微分方程的方法有很多种，我们在这里使用简单的零阶保持。<br><img src="../../post-images/a2bd58ed3d6ab93a0ca9dcd7b967cae9_MD5.png" alt="|500"><br>对这些方程进行离散化的结果，就是我们可以递归地实现实现后面所有的更新，使用给定的输入序列迭代地构建完整的轨迹，也就是 Dynamic Programming 。仅使用先前计算的点来递增地计算轨迹的下一个点，而不是重新计算之前所有的先前更新。<br>简而言之，就是说在得知车辆当前状态及车辆的运动学模型之后，通过改变车辆的控制输入来进行前向积分，迭代地生成轨迹。换句话说，就是在 control space 中 concrete。这个思路同样可以用于车辆的预测。明白这些之后，下面就要考虑如何生成无碰撞的路径了。我们可以通过提供一系列的转角输入，来生成足够多的轨迹，再对每条轨迹进行避障检测。<br><img src="../../post-images/e5927c37572cbc48cd9721eb33f09508_MD5.png" alt="|500"></p><hr><h2 id="2-碰撞检测">2. 碰撞检测</h2><p>根据第一部分，碰撞检测的前提是有一条预定的轨迹，同时获取到周围的环境信息。难点在于，确保安全无冲突的最佳路径不仅需要有关环境的完美信息，而且还需要大量的计算能力，才能以精确的形式进行计算，尤其是对于复杂的形状和环境。 对于需要实时规划的自动驾驶而言都是无法提供的。 从Module2中可以看到，利用网格占用提供给我们的信息是不完美的估计，这意味着我们需要在碰撞检测算法中添加缓冲区，以使它们更具容错性。<br>在这有两种思路来实现，swatch-based和circle-based方法。 二者的区别还是很大的。</p><h3 id="2-1-swatch-based-碰撞检测">2.1 swatch-based 碰撞检测</h3><p>在这先介绍swatch-based算法是如何检测碰撞的。确切的说，碰撞检测其实就是沿着路径的每个点旋转和平移车辆的足迹。足迹可以理解为是长方形的车辆，也就是车辆占的空间。车辆的足迹根据每个点的航向进行旋转，或者根据路径点的位置进行平移。操作结果用集合S来概括，其中 p 是一组路径点， F 表示一个函数，该函数返回需要变换的操作。<br><img src="../../post-images/a3b4a7dc65830e4962acbf9679dbfa37_MD5.png" alt="|500"><br>为了达到目标状态，需要将角度进行偏转 ，然后平移坐标点。沿着路径的每个点执行完相应操作后，汽车沿路径的最终条带(swatch)就生成了,由每一次变换后生成的足迹的并集组成。然后，我们检查条带，看内部是否有障碍。 如果存在，则路径包含碰撞，否则为无碰撞。<br><img src="../../post-images/9ec5dcddbb9015df498aa91e6240ad79_MD5.png" alt="|500"><br>下面，我们需要以抽象形式进行条带计算，并将其转换为可由计算机计算的离散公式。假设我们有一个用占用栅格表示的汽车足迹和路径的离散表示。汽车足迹包含K个点，路径的终点很长。 从算法上讲，计算条幅需要我们旋转和平移汽车足迹中的所有K个点，并对路径中的每个点乘以1。让我们来看一个使用占用栅格的旋转和平移的具体示例。 假设我们的占用栅格的分辨率为1米，并且我们的足迹占用以下三个栅格点； (0，0)，(1，0)和(2，0)。<br><img src="../../post-images/0e3315f5f4cc07d98605ba89344b4153_MD5.png" alt="|500"><br>假设我们有一个要旋转的路径点，并且要平移到(1, 2, )上。首先，我们应该绕着原点将足迹中的每个点旋转 。得到(0, 0) ，(0, 1)和(0, 2)的新网格点。然后进行平移变换，最终得到 (1, 2)，(1, 3)和(1, 4)。 回想一下，此转换中步骤的顺序很重要。 如果先平移然后围绕原点旋转，则对于转换后的点，我们将获得错误的位置。<br><img src="../../post-images/acaa3d4946eac285a0aec0f16c321555_MD5.png" alt="|500"><br>为了获得实际的占用栅格索引，我们用大写的X和Y表示偏移x和y点，它们分别是占用栅格的x和y维度的大小。 我们可以将其除以网格分辨率增量，以获取占用网格中的关联索引。 然后，我们将这些点的每一个添加到一个设置的数据结构中。 由于我们要维护一个集合，因此我们确保在我们的条带中没有重复的点。 可以想象，随着问题的扩展，这种计算变得非常昂贵，这使得在执行实时规划时很难使用。<br><img src="../../post-images/2e11508269402ab7cbcff63e5fd55389_MD5.png" alt="|500"><br>此外，由于我们的信息不完善，在计算条幅时使用准确的足迹可能很危险，因为障碍物位置没有缓冲。 这种基于条带的方法在计算上通常代价很高，所以当我们在运动规划算法中存在大量重复项时（如Lattice Planner中的情况），它通常很有用。<br><img src="../../post-images/2c6c82f03b556f0a618746c1d49e947d_MD5.png" alt="|500"><br>由于我们在Lattice Planner的每个步骤中都受到一小组控制动作的约束，因此我们也受到一小组束约束的约束，可以预先离线地计算它们的并集。 在线执行冲突检查时，问题减少到多个阵列查找。</p><h3 id="2-2-circle-based-碰撞检测">2.2 circle-based 碰撞检测</h3><p>为了帮助缓解信息不充分和大量计算需求的问题，我们经常使用保守近似进行碰撞检查，牺牲最优性以提高速度和鲁棒性。在这种情况下，最优性是由你选择适当的目标函数定义的，由于我们已切换到近似冲突检查以获取计算性能，因此我们必须使用过于保守的近似值。 选择特定近似值的目的是找到一种能够在不牺牲安全性的情况下提高算法速度的方法，同时还能最大程度地减小轨迹变得次优的程度。<br><img src="../../post-images/02944422cd7efaaafdef77a44717df16_MD5.png" alt="|500"><br>在这使用重叠的圆圈来完全覆盖之前汽车矩阵主体的足迹，即汽车的足迹是所有三个圆圈的足迹的子集。对比之前的条带很容易明白，矩形所产生的条带都是重叠圆所产生的条带的子集。这样可以保证轨迹更加安全。假设我们的圆形足迹中存在一个障碍物，但其实从条带来看并没有障碍物，因此碰撞检查会报告。但实际上并不会发生，比较抽象地说，碰撞检查可能包含一些“假性的阳性冲突”(不知道该如何翻译），但不会包含“假性的阴性冲突”。简言之，如果障碍物位于圆圈内，则可能也不会碰撞。但如果在圆圈外，绝对不可能碰撞。这样做为车辆提供了很好的缓冲，有助于减轻信息不充分带来的问题。<br>使用圆近似的好处是，检查点是否在圆内在计算上很方便。只需要检查障碍物的任何一点与圆心之间的距离是否小于半径。例如，此塔从圆心开始的位置小于圆的半径，因此将报告碰撞。 但是，对于第二个圆，吊架位于圆的半径之外，则此特定部分不会发生碰撞。 如果使用栅格，每个栅格点可以很方便地提供最近对象的距离，其实就是数组中的简单查找，相对于检查任意多边形相交而言，提升效果显著。<br><img src="../../post-images/998f628934968f968e3f3f9de9d4ba1b_MD5.png" alt="|500"><br>需要注意的是，使用保守近似很容易丢失掉原本可行的无碰撞路径，或者消除了狭窄开口的通道，使得车辆陷入困境或者冗余计算更多的路线。应该根据使用规划算法和占用栅格的不同，合理地选择碰撞算法。<br><img src="../../post-images/208c6d9b6a736612678e34040bb4490a_MD5.png" alt="|500"><br>最后提及一点，因为轨迹的离散化，所以我们的碰撞检查的精度也会受到离散化时选择的分辨率的影响。假设我们具有相同的路径和足迹，但是计算出的一条带的分辨率比另一条带的分辨率大得多。 我们可以看到，较粗的分辨率会导致条带中的缝隙较大，如果这些位置处有障碍物，则可能会导致错误。 我们为碰撞检查选择的分辨率越精细，它将越准确。 但是，较高的分辨率也会产生计算成本。 因此，我们也需要在准确性和计算速度之间取得适当的平衡。</p><hr><h2 id="3-轨迹扩展算法">3. 轨迹扩展算法</h2><p>经过前两部分的介绍，下面进入 Reactive Planner 的核心部分了。从整体功能上重新梳理遍，首先规划器使用第一部分后面提到的轨迹生成方法来生成一组候选轨迹，即离散控制量进行前向积分获取多条轨迹。车辆可以从当前工作空间开始遵循该轨迹。然后我们获取车辆本地周围环境的障碍物信息，使用第二部分提到的算法确定哪些路径没有碰撞。然后，在这些无冲突的路径中，我们选择一条最大化目标函数的路径，其中将包含一个奖励朝着目标前进的术语。<br><img src="../../post-images/4f6846bd4560bf448617583bc001a848_MD5.png" alt="|500"><br>通过重复执行此操作，我们最终得到了一个 receding horizon planner，该算法对环境做出反应，同时朝着目标不断前进。 下面详细介绍每个步骤：</p><h3 id="3-1-轨迹簇生成">3.1 轨迹簇生成</h3><p>该算法的第一步是在每个时间步生成轨迹簇。对于轨迹展开过程而言，每个轨迹都对应于固定时间范围内的固定输入。我们可以在可用的输入值范围内统一采样这些固定输入，以生成各种潜在的候选轨迹。仍然是那个万年不变的问题，如果我们仅使用较小范围的输入，那么我们的计算时间将会缩短。 但是，在计算中可能会遗漏一些潜在的候选轨迹，这可能会降低生成的轨迹的质量。 但是，对过多的候选轨迹进行采样意味着在每个步骤上我们都会有额外的计算开销，因为每个附加轨迹都需要生成，检查碰撞并进行评分。<br><img src="../../post-images/614b9d91437865892e9a15c77e5cc51e_MD5.png" alt="|500"><br>选择了一组输入后，通过使用第一部分提到的车辆运动学模型向前传播状态来沿轨迹生成未来状态。回想一下，对于自行车模型而言，输入分别是转向角和速度。如果我们保持速度恒定，改变转向角偏移到，可以生成一组弧作为我们的候选轨迹。<br><img src="../../post-images/a1308328fedb852f8530f509b2f0f075_MD5.png" alt="|500"><br>之前在第一课中提到过，这些弧线是通过前向递归计算运动方程得到的。接下来要检查下哪些弧没有碰撞。<br><img src="../../post-images/77bc92ce0db124d03528b4668efa0e13_MD5.png" alt="|500"></p><h3 id="3-2-碰撞检查">3.2 碰撞检查</h3><p>对于碰撞检测算法，我们假设给出了一个栅格，该栅格代表了车辆工作空间的离散化。该离散化以矩阵的形式存储，其中矩阵的每个值将指示工作空间中的相应位置是否被占用。然后，我们使用第二部分所讲的基于条带的方法执行冲突检查。沿着生成的路径变换车辆的足迹，取所有时间生成足迹的并集来生成测绘带。</p><p>在这，汽车所占空间面积对应于栅格中的一组索引。因此，沿路径的每个旋转和平移点也将对应于栅格中的不同索引。这些索引将存储在一组数据结构中，以消除重复项。然后，我们可以检查条带的每个点，以查看条带的哪些点与占用网格的占用元素重叠。通过遍历测绘带集合中的每个点并检查栅格中的相关索引，来判断是否发生碰撞。如果条带中的任何点被占据，则该轨迹包含碰撞。 遍历上一步中生成的每个轨迹后，我们将获得一组无碰撞的运动学上可行的轨迹，然后可以使用目标函数对其进行评分。</p><h3 id="3-3-目标函数">3.3 目标函数</h3><p>目标函数的功能是奖励或惩罚某个目标点和区域的执行。最简单的情况就是，将候选轨迹的末端与目标节点的距离乘以一个参数，加入到目标函数中。除此之外，也可以加入最小化到车道中心线的距离，惩罚路径的曲率。另外，有时候也希望奖励最大化到最近障碍物距离的路径，以最大程度地增加规划器未来时间步骤可用的可行路径的灵活性。需要明白的是，没有完美的目标函数，只能根据需求构建符合自己需求的目标函数。如下图作为参考。<br><img src="../../post-images/5294ef8e14a63155240df048246c4ae5_MD5.png" alt="|500"><br>有了目标函数后，我们就可以遍历无碰撞的轨迹，并根据目标的制定方式选择最大化目标函数或最小化代价的路径。</p><h3 id="3-4-例子">3.4 例子</h3><p>下面根据一个实例进行讲解：<br><img src="../../post-images/43255e5c0cf0991b724781cc5b1bcf1d_MD5.png" alt="|500"><br>如果所以，网格中的障碍物用红色来表示，目标区域用黄色表示。汽车的起点是(0, 0 ,0 )，假设我们的转向角的范围介于到，步长为８，恒定速度魏0.5 m/s。另外，假设规划过程使用的时间步长为0.1s，并且每个规划轨迹总共持续2s。使用在第一部分提到的轨迹传播算法，则可以为转向范围内的每个选定转向角生成一组路径。<br><img src="../../post-images/65b1fe08b9bb0abb0a256805e4b184ea_MD5.png" alt="|500"><br>第一条轨迹的转向角为 ，因此，我们可以看到该轨迹向右弯曲。 我们的下一个轨迹的转向角为 ，并且你可以看到，生成的轨迹的曲率比第一个轨迹小。<br><img src="../../post-images/c6442bbe731260398918d1893c835bee_MD5.png" alt="|500"><br>接下来，我们获得零转向角轨迹，从而使汽车沿直线前进。<br><img src="../../post-images/6f7b11fb2810ce84a67ec2302cee3314_MD5.png" alt="|500"><br>正转向角轨迹与负转向角轨迹对称，并按预期将汽车向左转。<br><img src="../../post-images/6bdfbfcc35f3620651269e447d1d772e_MD5.png" alt="|500"><br>现在有了一组候选轨迹，接下来使用碰撞检测算法检查每个轨迹是否无碰撞。<br><img src="../../post-images/7fb46df4ea142635c3b80213700b9975_MD5.png" alt="|500"><br>在沿着每个轨迹平移和旋转足迹后，我们检查结果条带中的每个栅格索引，以查看是否存在障碍物。 如果任何索引包含障碍物，则该路径将被标记为发生碰撞，我们用红色表示。 所有无碰撞的路径都被涂成绿色，然后我们可以使用目标函数进行评估以找到最佳路径。<br><img src="../../post-images/4c36ad7ae7d62c85794ebfa81b9a38df_MD5.png" alt="|500"><br>在这里我们的目标函数是到目标的距离。现在将此距离目标最小的路径涂成黑色，这样就完成了我们的第一次规划迭代。到这里，我们就有了车辆执行的轨迹，但是我们不会在下一个规划周期之前完全执行此轨迹，相反，我们只执行循环的前几个点，确切的数字取决于规划的频率，我们的规划范围将根据我们的进度向前移动，也是之前讲过的应用于车辆控制的 receding horizon planner 方法。</p><h3 id="3-5-receding-horizon-举例">3.5 receding horizon 举例</h3><p>综上所述，在每个时间段上，我们规划一个两秒钟的轨迹，但一次只执行一秒钟。 这样，每个规划周期，我们的规划范围的结束时间将向前移动一秒钟。<br><img src="../../post-images/60d327aaf4d5f9cb588df175b0ace0ab_MD5.png" alt="|500"><br>这样被称作 receding horizon planner ，因为在每个规划周期中，我们都有一个固定的规划时间范围，其n次缓慢地向我们达到目标的时间点后退。 此处说明了这一点，其中黑色是将在当前循环上执行的轨迹部分，橙色部分是剩余部分。一旦下一个规划周期开始，我们将再次重复整个过程。 我们继续执行此过程，直到计算出到达目标区域的轨迹为止，并在每次迭代结束时进行检查。<br><img src="../../post-images/bfe259cce1cd9a5e425e5e02f9664d92_MD5.png" alt="|500"><br>到目前为止，整个规划算法就基本介绍完了，整体的实现脉络还是很清晰的，需要注意的是，Reactive Planner 算法是属于Local Planner，也就是说，它没有规划直接到达目标的路径，相反，它根据目标函数生成子路径，类似贪婪算法一样对子路径进行采样。这样很可能导致算法陷入僵局，并且通常会导致规划器仅找到次优路径。但是，通过该算法将规划的核心放在目标区域，大大地降低了目标区域的复杂性，并且速度足够快，可以用作实时规划。</p><h2 id="4-动态窗口算法">4. 动态窗口算法</h2><p>对整个算法做一个补充，动态窗口算法的功能在于在车辆的轨迹上设置线性和角加速度的约束，以提高车辆在规划周期内的行驶舒适度。回到第一部分讲到的自行车模型，输入只考虑转向角和线速度，没有考虑诸如加速度和加加速度等高阶项。这些高阶项正是导致乘客体验不好的原因，因此我们应该尝试在运动学模型中解决此问题。限制所选输入，以考虑快速变化对乘坐舒适性的影响。<br><img src="../../post-images/7abf59f3fb066b1f70695101c9404b21_MD5.png" alt="|500"><br>因此，在这我们魏自行车模型添加线速度和角加速度范围的约束。同时我们要权衡这样操作对规划轨迹的影响。 回想一下，自行车模型的角速度由 给出。因此，角加速度的大小大致由起始和结束转向角的角速度之间的绝对值差，除以我们使用的时间步长得出。最后公式转换为如下形式：<br><img src="../../post-images/7b8350a9c536854fe4f7e976cf060ac5_MD5.png" alt="|500"><br>下面以一个具体例子进行说明，假设我们的自行车模型在所有候选轨迹上均以每秒一米的恒定线速度运动，并且当前转向角为。<br><img src="../../post-images/bf80a884bbe65f68b66d0c1fd0fe217e_MD5.png" alt="|500"><br>假设此机器人的最小和最大转向角为分别和，并且我们的转向角步长为。 另外，假设我们的轨迹以0.1秒的时间分辨率进行采样，并且我们的自行车模型的长度为1米。 最后，让我们将角加速度限制为每秒0.6弧度平方。<br><img src="../../post-images/138a83d16534861b616f449b0fa0b72b_MD5.png" alt="|500"><br>然后我们将导出的转向角约束应用到问题。我们当前的转向角增量为。 通过将每个潜在的转向角代入我们的转向角集，我们发现，如果我们将转向角更改为或。 则违反了角加速度约束。<br><img src="../../post-images/e6d76a01d487c2d794850ceb60155d2a_MD5.png" alt="|500"><br>在这我们将不允许的轨迹改为红色，绿色的轨迹仍然可以用于上部分开发的 Reactive Planner 步骤中。由此可以看出增加的约束会一定程度上限制车辆的可操作性，但同时促进更舒适的轨迹。总的来说，动态窗口法可以使我们在规划过程中对轨迹的演变方式施加更多限制，从而使运动能够更好地满足广泛的目标。</p><h2 id="参考文献：">参考文献：</h2><ul><li>Fox, D.; Burgard, W.; Thrun, S. (1997). “The dynamic window approach to collision avoidance”. Robotics &amp; Automation Magazine, IEEE. 4 (1): 23–33.<a href="https://en.wikipedia.org/wiki/Digital_object_identifier">doi</a>:<a href="https://doi.org/10.1109%2F100.580977">10.1109/100.580977</a>. This gives an overview of dynamic windowing and trajectory rollout.</li><li>M. Pivtoraiko, R. A. Knepper, and A. Kelly, “<a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/rob.20285">Differentially constrained mobile robot motion planning in state lattices</a>,” Journal of Field Robotics, vol. 26, no. 3, pp. 308–333, 2009. This paper is a great resource for generating state lattices under kinematic constraints.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Automotive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> Automotive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人在 ROS 工程使用Protobuf的模板和一点心得</title>
      <link href="/posts/System-development/20191127-ros-protobuf-template-insights.html"/>
      <url>/posts/System-development/20191127-ros-protobuf-template-insights.html</url>
      
        <content type="html"><![CDATA[<p>从上周搞定ROS工程下使用Protbuf的问题后，陆续对原有工程进行了更改，在这一过程中，探索了下Protobuf与ROS工程结合的不同方式，暂时总结了一份模板，并在此记录下心得。</p><h3 id="1-使用-proto-的-ros-节点">1. 使用 Proto 的 ROS 节点</h3><p>在这贴下个人使用的范例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── map</span><br><span class="line">│       ├── map.cpp</span><br><span class="line">│       └── map.h</span><br><span class="line">├── package.xml</span><br><span class="line">├── proto</span><br><span class="line">│   └── map.proto</span><br><span class="line">└── src</span><br><span class="line">    └── map_node.cpp</span><br></pre></td></tr></table></figure><p>个人在尝试不同的组织结构的过程中，也试过把proto文件单独设置一个节点，后续节点只需要添加即可，不需要都更改CmakeLists.txt文件。但对比Apollo工程发现，这样做会使工程目录不够清晰，不能直观地看到工程中是否引用了proto文件。再三考虑后还是决定每个节点单独设置proto文件夹来存在proto文件，这样更清晰直观。</p><hr><h3 id="2-cmakelists-txt模板">2. CmakeLists.txt模板</h3><p>目前最终效果如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(map)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">## System dependencies are found with CMake&#x27;s conventions</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake)</span><br><span class="line"><span class="keyword">include</span>(FindProtobuf)</span><br><span class="line"><span class="keyword">find_package</span>(Protobuf REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(proto_dir <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/proto)</span><br><span class="line"><span class="keyword">file</span>(GLOB proto_files <span class="string">&quot;$&#123;proto_dir&#125;/*.proto&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up destination directories</span></span><br><span class="line">catkin_destinations()</span><br><span class="line"><span class="keyword">set</span>(proto_gen_dir <span class="variable">$&#123;CATKIN_DEVEL_PREFIX&#125;</span>/<span class="variable">$&#123;CATKIN_GLOBAL_INCLUDE_DESTINATION&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(proto_gen_cpp_dir <span class="variable">$&#123;proto_gen_dir&#125;</span>)</span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> <span class="variable">$&#123;proto_gen_dir&#125;</span>)</span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> <span class="variable">$&#123;proto_gen_cpp_dir&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(protogen_include_dirs <span class="variable">$&#123;proto_gen_cpp_dir&#125;</span>/../ <span class="variable">$&#123;proto_gen_python_dir&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create lists of files to be generated</span></span><br><span class="line"><span class="keyword">set</span>(proto_gen_cpp_files <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">foreach</span>(proto_file <span class="variable">$&#123;proto_files&#125;</span>)  </span><br><span class="line">  <span class="keyword">get_filename_component</span>(proto_name <span class="variable">$&#123;proto_file&#125;</span> NAME_WE)</span><br><span class="line">  <span class="keyword">list</span>(APPEND proto_gen_cpp_files </span><br><span class="line">       <span class="variable">$&#123;proto_gen_cpp_dir&#125;</span>/<span class="variable">$&#123;proto_name&#125;</span>.pb.h </span><br><span class="line">       <span class="variable">$&#123;proto_gen_cpp_dir&#125;</span>/<span class="variable">$&#123;proto_name&#125;</span>.pb.cc</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">endforeach</span>(proto_file <span class="variable">$&#123;proto_files&#125;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Run protoc and generate language-specific headers.</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT <span class="variable">$&#123;proto_gen_cpp_files&#125;</span></span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;PROTOBUF_PROTOC_EXECUTABLE&#125;</span> --proto_path=<span class="variable">$&#123;proto_dir&#125;</span> --cpp_out=<span class="variable">$&#123;proto_gen_cpp_dir&#125;</span> <span class="variable">$&#123;proto_files&#125;</span></span><br><span class="line">  DEPENDS <span class="variable">$&#123;PROTOBUF_PROTOC_EXECUTABLE&#125;</span> <span class="variable">$&#123;proto_files&#125;</span></span><br><span class="line">  WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_source_files_properties</span>(<span class="variable">$&#123;proto_gen_cpp_files&#125;</span> PROPERTIES GENERATED <span class="keyword">TRUE</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_target</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_headers</span><br><span class="line">  DEPENDS <span class="variable">$&#123;proto_gen_cpp_files&#125;</span> </span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Create proto library for lining.</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROTOBUF_INCLUDE_DIR&#125;</span> <span class="variable">$&#123;PROTOBUF_INCLUDE_DIR&#125;</span>/../../)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_proto <span class="variable">$&#123;proto_gen_cpp_files&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_proto <span class="variable">$&#123;PROTOBUF_LIBRARY&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_proto <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_headers)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line">  INCLUDE_DIRS <span class="variable">$&#123;protogen_include_dirs&#125;</span></span><br><span class="line">  LIBRARIES <span class="variable">$&#123;PROJECT_NAME&#125;</span>_proto</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS <span class="variable">$&#123;PROJECT_NAME&#125;</span>_proto</span><br><span class="line">  ARCHIVE DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span></span><br><span class="line">  LIBRARY DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span></span><br><span class="line">  RUNTIME DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(DIRECTORY <span class="variable">$&#123;proto_gen_cpp_dir&#125;</span>/</span><br><span class="line">  DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125;</span></span><br><span class="line">  FILES_MATCHING PATTERN <span class="string">&quot;*.h&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line">  INCLUDE_DIRS <span class="keyword">include</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">  <span class="variable">$&#123;PROTOBUF_INCLUDE_DIR&#125;</span></span><br><span class="line">  <span class="variable">$&#123;CATKIN_DEVEL_PREFIX&#125;</span></span><br><span class="line">  <span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  <span class="keyword">include</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/map.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(map_node </span><br><span class="line">  src/map_node.cpp</span><br><span class="line">  <span class="keyword">include</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/map.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node </span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">  <span class="variable">$&#123;PROTOBUF_LIBRARIES&#125;</span></span><br><span class="line">  <span class="variable">$&#123;Boost_FILESYSTEM_LIBRARY&#125;</span></span><br><span class="line">  <span class="variable">$&#123;Boost_SYSTEM_LIBRARY&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在使用中，有以下几点需要注意：</p><ol><li>使用时必须保证节点根目录下存在proto文件夹，并放置好proto文件，否则会提示无目标文件错误；</li><li>使用时需对应修改下与节点名称相关的变量</li><li>注意：生成的proto文件存在于devel目录inlude文件夹下，对应生成节点名称的文件夹，下面存在生成的变量。</li><li>include_directories目录中包含${CATKIN_DEVEL_PREFIX}宏，之后才可以引用devel文件目录中的proto生成文件；</li></ol>]]></content>
      
      
      <categories>
          
          <category> System-development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> Protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Smooth Local Planning 实现</title>
      <link href="/posts/Automotive/20191120-smooth-local-planning.html"/>
      <url>/posts/Automotive/20191120-smooth-local-planning.html</url>
      
        <content type="html"><![CDATA[<p>在介绍之前，首先对 Module 6 中的 Reactive Planner 算法进行一个定性的描述，其本质是对Control space 做一个discrete(sample)，基于车体运动学方程进行前向积分从而生成轨迹。是 forward direction。而在该部分中所有介绍的方法，属于 reverse direction，其本质上是在 state space 中进行discrete(sample)。二者的性能区别对比如下(图为高飞老师课程课件，侵权请联系删除)<br><img src="../../post-images/43f50dc4f7fffeb61302cc0f29d240a0_MD5.png" alt="|500"><br>下面进入主题，开始介绍今天的规划实现方法。</p><p>本部分通过引入连续曲线路径优化作为两点边界值问题(BVP, boundary value problem)，该问题在满足曲率约束的同时实现与所需路径的偏差最小化。作为业内一种非常成熟的实现方式，实现的复杂度也丝毫不亚于 Reactive Planner。下面主要分几个部分进行介绍说明：</p><ol><li>参数曲线的含义，运动规划约束和边界值问题的含义</li><li>螺旋曲线和样条曲线的概念，两者的优势和不足，如何进行权衡取舍</li><li>设计优化目标适合特定的运动计划任务，并使用Python库来解决优化问题</li><li>实现基于多项式螺旋优化的conformal lattice planner</li><li>如何计算受曲率，速度限制和动态障碍物约束的速度曲线</li></ol><p>内容比较多，希望大家耐心看</p><h2 id="1-参数曲线">1. 参数曲线</h2><h3 id="1-1-背景介绍">1.1 背景介绍</h3><p>回到最根本的规划问题，其实就是给定一个起点状态，找到一个路径达到终点状态。其中说的状态一般包括位置，朝向，曲率。实现起来困难的地方在于如何满足运动学约束。放在优化的背景下考虑，查找路径的过程其实就是一个BVP(boundary value problem)，而运动学约束可以被理解为对优化变量的连续时间约束。<br><img src="../../post-images/1aa25f050f505bfdb2ef6dfec183259d_MD5.png" alt="|500"><br>在这种情况下，边界条件必须在路径的任一端点上保持，才能将给定的优化解决方案视为可行。 如果违反了这些边界条件，那么无论走什么路，我们都无法达到预期目标。 因此是无用的。这些边界条件最终影响我们决定如何去设置优化问题的基础结构。</p><p>回到车辆运动学约束的问题上来，对于我们的路径规划器而言，我们唯一的运动学约束就是限制沿路径的最大曲率。 一般来说这个很难满足，因为沿连续路径有无数个点。因此，我们通常会沿着路径的不同点进行采样获取每个点的曲率，并约束每个点的曲率。如果这些点的值满足要求，则可以认为整个路径基本满足约束条件。<br><img src="../../post-images/d38c14bcbe6cae3fe7ec986c52878761_MD5.png" alt="|500"><br>为了简化对优化问题的表示，我们将一条路径定义为参数曲线。 参数曲线可以描述为具有特定参数的一组方程的曲线。例如，我们为路径的x和y位置设置了三次样条参数方程。 当我们从路径的起点行进到路径的终点时，方程变量 u 从0到1变化。 向量值函数 r 则为对应于 u值的每个点的x和y位置。<br><img src="../../post-images/47959e1893bab6eb700fed8d88b12d11_MD5.png" alt="|500"><br>对于自动驾驶而言，路径的参数表示可以使设置优化问题变得更加简单。如下图所示，起点状态是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\beta_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，终点状态是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">\beta_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，运动学约束为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>。则车辆的最优化方程可以用 f 来表示。<br><img src="../../post-images/474ea1574d0de369119616886cf4af46_MD5.png" alt="|500"><br>我们可以将这种参数曲线方法与Module6中的 Reactive Planner 进行对比，在该模型中，我们用空间中的点序列来表示轨迹和路径。 由于我们遵循的曲线没有参数表示，因此这被称为非参数路径。<br><img src="../../post-images/4a30770591517f47da03d4c3323749b2_MD5.png" alt="|500"></p><h3 id="1-2-不同类型的参数曲线">1.2 不同类型的参数曲线</h3><p>说完上面简单的参数曲线的背景及含义，下面开始正式说明参数曲线的应用。在自动驾驶领域，路径参数化有两种常见类型。 第一个是“五次样条(quintic splines)” ，是汽车x和y位置的五次多项式函数。 第二个是“多项式螺旋(polynomial spiral)”，由相对于弧长的多项式曲率函数给出。<br><img src="../../post-images/5c9f45631770f6541cb4dc595429a4ef_MD5.png" alt="|500"></p><p>上面分别是五阶样条，三次螺旋，这两个参数化曲线都为我们提供了满足我们刚刚讨论的边界条件的手段，还为我们提供了用于目标函数的参数，以根据我们的要求来设计路径。不同的选择对应于不同的应用，具体根据环境进行权衡。</p><h4 id="quintic-splines-quintic-splines-curvature">Quintic splines &amp; Quintic Splines Curvature</h4><p>首先从五次样条方法开始。 五次样条由两个方程式给出，一个方程式用于x的生成，另一个方程式用于y的生成。 可以看到五次样条具有12个参数，其中x方程为6个，y方程为6个。 这些参数对应于形成曲线形状的多项式系数。 变量u在这里可以任意设置。为简单起见，我们将其范围设为0到1。 此时u等于0对应于路径的起点，而u等于1对应于路径的终点。<br><img src="../../post-images/7ad3da9756f3a0eaa5fc99d188fa8d20_MD5.png" alt="|500"><br>使用五次样条的好处在于，对于给定的位置，航向和曲率的边界条件，存在一个封闭可行解即一组满足条件的样条系数。其实现起来比使用迭代优化方法更加便捷。其不足之处在于，通常很难实现像自动驾驶那样地把曲率限制在一定范围内。从参数曲线的曲率方程中可以看出，对于我们的五次样条而言，曲率是弧长的函数，形式并不是多项式。此时很可能引入尖点，甚至会导致曲率的不连续。这使得很难在五次样条的整个范围内大致满足曲率约束。<br><img src="../../post-images/6034cb2a12835e1ad5106df5513a9bfc_MD5.png" alt="|500"></p><h4 id="polynomial-spirals-polynomial-spiral-position">Polynomial Spirals &amp; Polynomial Spiral Position</h4><p>下面使用多项式螺旋来表示我们的路径，这些曲线为沿其弧长的每个点的曲率提供了一个闭合形式方程。对于自动驾驶而言，通常选择三次多项式作为我们弧长的曲率函数。也可以使用更高阶的来实现。<br>使用多项式螺旋的好处在于，其结构非常容易满足路径规划问题中需要的近似曲率约束。由于螺旋线是曲率的多项式函数，因此曲率值不会像在五次样条曲线中那样迅速变化。所以，通过限制螺旋线和螺旋线中仅几个点的曲率，就很可能满足了整个曲线上的曲率约束。这样大大节省了执行路径优化的计算量，因为对约束的求解会极大地增加优化的计算量。<br><img src="../../post-images/2611d0adbf10b156d2912d5a7b1f429a_MD5.png" alt="|500"><br>使用多项式螺旋的不足之处在于，螺旋的位置和航向没有封闭形式的解，这与五次样条中的情况不同。因此，我们必须进行迭代优化才能生成一个螺旋来满足我们的边界条件。从这里可以看出，位置方程得出的菲涅耳积分没有封闭形式的解。因此，我们需要使用数值逼近来计算螺旋的最终端点。在该部分，我们使用下图中第三行显示的Simpson规则来近似这些菲涅尔积分。Simpson规则比其他逼近方法更加准确，点数更少，这在设置优化问题时很有用。<br><img src="../../post-images/b4c051ba9344014b9cae287eba8e6fa6_MD5.png" alt="|500"><br>综上，对比两种方法，每一种都不是完美的。样条曲线仅基于起点和终点提供封闭形式的解决方案，螺旋线算法无法实现。反之，螺旋线确保沿路径的平滑曲率变化，而样条曲线则无法实现。在个人使用时根据需要进行调用。简而言之，样条曲线可提高计算效率，而螺旋线则可简化曲率约束的实现。下面，以样条曲线为主要实现方式进行介绍。</p><hr><h2 id="2-路径优化">2. 路径优化</h2><p>说完了参数曲线的种类及其目标和约束，下面看一下如何将边界条件下的三次螺旋线与目标约束结合起来，以创建路径规划的优化问题。通过解决该问题来生成满足我们所有约束，同时平滑，可行的路径。过程中我们需要使用多项式螺旋来确定平滑路径规划所需的边界条件和约束，近似一些所需的约束以提高优化问题的可处理性，并且，映射所需的约束参数以使优化问题迅速收敛到可行的解决方案。<br><img src="../../post-images/6436daead8c05ef7f7c8083283fbd2e2_MD5.png" alt="|500"><br>联系上一部分，首先需要说明的是，螺旋曲线虽然可以很容易地满足路径中的曲率约束，但在求解终止位置和航向约束时没有封闭形式的解，因此如果使用螺旋曲线满足约束，需要对其进行数值近似。在这我们可以使用上一节中提到的 Simpson 法则来实现。</p><h3 id="2-1-simpson-法则">2.1 Simpson 法则</h3><p>Simpson 法则是一种常用的数值积分工具，通常比其他形式上简单的数值方法更加精确。这是因为它评估给定函数的二次插值的积分，而不是像某些方法（例如中点和梯形规则）那样评估线性插值的积分。即以<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF">二次曲线</a>逼近的方式取代矩形或梯形积分公式，以求得<a href="https://zh.wikipedia.org/wiki/%E5%AE%9A%E7%A7%AF%E5%88%86">定积分</a>的数值近似解。<br><img src="../../post-images/72470ec0a37cf419810a4103458bfdf8_MD5.png" alt="|500"><br>Simpson 法则在积分域内定义了 n 个等距分割线，然后在每个分割线和边界点进行求和积分。假设 n = 4，则将积分域分为了四个大小相等的段，因此，在积分域中我们一共包含了5个点。总和中的每个项都需要乘以适当的系数，从方程中可以看出，每个项的交变系数分别为4和2，除了端点项的系数为1。随着n增加，可以对积分实现更加精确的近似。</p><p>查看参考链接：<a href="https://riteme.site/blog/2016-11-16/simpson.html">辛普森积分法</a></p><p>回到之前的规划问题，实际上如果我们在 Simpson 法则中近似选取n = 8，那么对于我们要执行的优化来讲已经足够近似准确了，且计算压力不会太大。在这我们只是使用的三次螺旋函数进行积分，因此我们可以为它明确定义一个封闭形式的解决方案，即下图所示的四阶多项式。<br><img src="../../post-images/56b72fef9430a1b6b62d7beed094c375_MD5.png" alt="|500"><br>从上图可以看出，使用 Simpson 法则进行近似，在每个分割点都可以得到一个 值，可以根据 值计算三次螺旋的x和y位置。对于x进行积分的被积数是s的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span> 的余弦，而对y进行积分的被积数是s的 的正弦。于是，在由弧长参数s定义的任何给定弧长点处，我们都有一个有用的近似螺旋的x和y位置。我们用 和 来表示使用 Simpson 法则近似得到的 x 和 y 值。</p><p>回到边界条件，我们已经有了路径终点的近似值，可以根据已知的螺旋参数写出边界条件。现在，我们可以通过迭代优化螺旋的参数及其总弧长 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">s_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 来生成一个从一点到另一点的螺旋，该螺旋满足给定的边界条件。在此之前，需要了解一下要强制执行的运动学约束。<br><img src="../../post-images/a3ab5c10961d64b3215c9b45d46df484_MD5.png" alt="|500"><br>对于自动驾驶的路径规划而言，曲率约束绝对是重中之重。汽车具有绝对的最小转弯半径，需要保持在横向加速度限制内，以保持车轮的牵引力和车辆的乘坐舒适性，后面再具体描述。假设我们的汽车可以得到两米的最小转弯半径，对应于0.5 弧度/米的最大曲率。很难沿着螺旋线的每个点写出此曲率约束。但由于螺旋的多项式性质，我们只需要约束几个均匀间隔的点即可。由于曲率的多项式函数是连续的，因此在执行优化时我们不难生成一个满足曲率要求的螺旋线。<br><img src="../../post-images/534388f079ae821efff69ea21146ef4a_MD5.png" alt="|500"><br>为简单起见，让我们将曲率限制在曲线的三分之一和三分之二处。 起点和终点曲率已在边界条件下受到约束。 完成此操作后，我们现在将曲率约束作为螺旋参数的函数，至此，我们拥有了解决优化问题所需的所有约束。<br><img src="../../post-images/ce07234d345b99d43daf9ba2463414ad_MD5.png" alt="|500"></p><h3 id="2-2-目标函数">2.2 目标函数</h3><p>解决完路径的曲率约束后，最后一个难题在于如何最小化实际目标函数。我们期望规划得到的路径是平稳舒适的。一种方法是沿路径均匀离散绝对曲率，这可以通过最小化我们规划的参数曲线的“弯曲能量”来完成。<br><img src="../../post-images/4e72b194aa865aecd54f78368ab9b2ae_MD5.png" alt="|500"><br>曲线的“弯曲能量”是指沿着路径的整个弧长的平方曲率的积分。 由于我们具有描述三次螺旋的曲率多项式函数，因此“弯曲能量”的积分具有关于螺旋参数的闭合形式的解。 另外，它的梯度也有一个封闭形式的解。 这两个表达式都有很多术语，因此最好由符号求解器来创建它们。 目标函数及其梯度具有闭合形式的解使它成为非常有利于非线性编程的目标函数，在后面具体讨论。</p><h3 id="2-3-初始化优化问题">2.3 初始化优化问题</h3><p>有了目标函数后，我们就可以将所有内容整合到下面的路径规划优化问题中了。为了方便，在这我们假定初始边界条件为0，基于车体定义我们的局部规划问题，同时利用 Simpson 法则得出航向以及x和y近似值的简化表达式。因此在这我们可以删除初始边界值约束，因为我们在积分计算时已经考虑到了。<br><img src="../../post-images/7d5d155000def92854d5f9bda5c489d9_MD5.png" alt="|500"><br>现在我们可以将其用作生成路径的优化问题。但是，如何设置此优化问题也还是个实际问题。因为当使用规范非线性规划求解器进行求解时，该优化问题可能会减慢其速度或使其根本不收敛。</p><h3 id="2-4-软约束">2.4 软约束</h3><p>我们在这里看到的主要问题与最终位置和朝向的相等性约束有关。因为必须严格满足相等性约束，所以数值优化器很难从不可行的起点生成可行的解决方案。而对于任何问题而言，通常都是给优化器提供可行的解决方案。为了缓解此问题，在优化中通常会使用软不平等约束来提高优化程序的性能。软约束将严格约束转换为目标函数中的严重惩罚项。所谓严重惩罚，是指约束惩罚项的系数至少应比一般的优化目标大一个数量级。<br><img src="../../post-images/b4ac9ca72d9f08d2872027da7748375e_MD5.png" alt="|500"><br>尽管这允许优化器违反边界条件相等约束，但是在“弯曲能量”损失项足够大以影响优化器之前，将强烈鼓励优化器收敛到尽可能接近边界条件的解决方案。 我们还将假定初始曲率是已知的，通常将其设置为0，这对应于0等于0。 这样可以将优化变量的数量减少1。 减轻这些约束后，我们的新优化问题如上图所示。 在定义要实施的优化问题的最终版本之前，我们还需要解决另一个问题。</p><h3 id="2-5-参数重映射">2.5 参数重映射</h3><p>最后一个问题与“优化参数”有关。 尽管在目标函数中使用三次螺旋系数更加直观，但实际上可以通过考虑最终曲率边界约束来减少正在搜索的参数数量。 让我们使用由向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 表示的一组不同参数重新定义三次螺旋，其中具有五个元素。 从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">p_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，它表示起点处的曲率，三分之一点和三分之二点以及终点，最终项是路径的最终弧长。于是，我们在曲率参数和螺旋参数之间建立了一个闭合形式的映射，如下图所示。因此，我们可以轻松地根据这些新的p变量而不是螺旋系数来计算所有约束和客观项。<br><img src="../../post-images/32893e15b27881e5895224e6c2bbf684_MD5.png" alt="|500"><br>解决了优化问题后，我们可以在此处使用公式将结果映射回螺旋系数。由于我们已经知道了初始曲率和最终曲率，因此我们可以消除两个变量 和 。于是我们只需要优化问题中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">p_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 这三个变量。 通过使用边界条件，我们减少了优化问题的维数，从而可以显著提高计算速度。</p><h3 id="2-6-最后优化问题形式">2.6 最后优化问题形式</h3><p>最终的优化问题形式如下。在重映射到我们的 参数之后，我们用等效函数替换了螺线形参数的函数。注意，初始和最终路径曲率和是常数。 因此，优化变量现在只有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">p_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。<br><img src="../../post-images/6cbf07fa58e2ef45e3db423410e93747_MD5.png" alt="|500"><br>由于在路径的起点和终点都知道曲率的边界条件，因此可以进行简化。 修改后，可以有效地解决路径规划问题，并大大减少陷入不良的局部最小值的可能性。<br>内容有点多，在这总结下各个部分。 首先，我们审查了此问题所需的边界条件和约束。 然后，我们讨论了如何使用Simpson法则数值计算螺旋的n个位置。 之后，我们引入了“弯曲能量”目标以鼓励平滑性，并形成了一个通用的螺旋优化问题。 最后，我们重映射优化函数的参数，以确保快速收敛到可行的解决方案。 说完理论实现后，下面说下如何进行实践操作。</p><h2 id="3-使用-python-进行最优化">3. 使用 Python 进行最优化</h2><p>在开始之前，首先介绍下 Python 优化的基础知识。一般来说在专业使用中，我们使用SciPy优化库来解决通用非线性优化问题所需的一些功能。优化领域包括非常多问题，在这不一一赘述了。SicPy优化库涵盖了一些最另行的优化算法，使它们易于访问，并确保了合理的实现侠侣。就所需的参数类型而言，许多已实现的优化方法都具有相似的结构。因此，为了将其抽象为一个简单的界面，SciPy优化库包含一个通用的最小化函数。<br><img src="../../post-images/7066c8e8e16ba9d23b95ff1e718c5793_MD5.png" alt="|500"><br>其他一些可选的优化方法包括：conjugate gradient, Nelder-Mead, dogleg, 和BFGS。详细信息可以查看参考链接。对于这些算法来讲，运行哪些特定的优化算法将取决于你传递给此函数的方法参数。方法参数还将确定优化算法需要哪些附加参数。 例如，在我们将使用的L-BFGS-B算法中，我们不仅需要最小化模型，还需要模型Jacobian和可变边界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = sp.minimize(objective_function, x_0, method=<span class="string">&#x27;L-BFGS-B&#x27;</span>,</span><br><span class="line"> jac=objective_jacobian, bounds=bounds,</span><br><span class="line"> options=&#123;<span class="string">&#x27;disp&#x27;</span> : <span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure><p>在模型是单个标量值函数的情况下，Jacobian矩阵减小为梯度。 该Jacobian行列式通过jac参数传递给最小化函数，如该函数调用中所示。我们希望最小化的实际功能是最小化功能的第一个参数。 约束作为字典或对象的列表传递到约束变量。此外，还有一个可选的options参数，高级用户可以使用该参数来定制诸如优化程序输出的内容。这些优化算法还需要对模型或目标函数的优化变量进行初步猜测，这由 在函数调用中给出。下面具体看下如何使用 SciPy 中的BFGS算法进行优化。<br>本质上，对于BFGS算法，我们需要将函数指针传递给我们希望最小化的实际目标函数，以及将函数指针传递给评估目标函数的Jacobian函数的函数。这些函数将采用所有优化变量的向量，以便在特定点评估目标函数和Jacobian行列式。<br><img src="../../post-images/24f2f2ee2b5ba9b42de674e3993853ee_MD5.png" alt="|500"><br>优化完成后，最小化函数将返回结果变量。 用x表示的结果的成员变量将返回已达到局部最小值的优化变量的最终向量。<br><img src="../../post-images/6f74603ff9a8894533c32bdb2cce1b1b_MD5.png" alt="|500"><br>前面提到过，我们还可以为优化问题指定约束。 对于大多数算法，这些约束以列表或字典的形式给出。 最简单的约束类型是对称为边界的目标变量的不等式约束。边界由L-BFGS-B算法指定为列表的列表，其中每个子列表的长度为 2，并包含每个优化变量的上限和下限。 换句话说，第一个子列表与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的边界相对应，第二个子列表与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  的边界相等。然后将这些边界传递到最小化函数的constraint可选参数。<br><img src="../../post-images/9e391be872f428bc13c2651c523914c7_MD5.png" alt="|500"><br>线性和非线性约束也可以传递给优化器，但是现在，我们将重点关注对优化约束使用边界。<br><img src="../../post-images/9afb1d016c6aaf8ca405c9871bf602c0_MD5.png" alt="|500"><br>有关更多详细信息，可以在线查看SciPy优化文档。 还可以通过传递要在优化器函数中使用的每个约束对象的Python列表，来组合多种约束类型。最后看下实际的实现效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nlopt</span></span><br><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> sp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">bounds = [[-<span class="number">10.0</span>, <span class="number">5.0</span>], [-<span class="number">3.0</span>, <span class="number">4.0</span>]]</span><br><span class="line">x_0 = [<span class="number">1.0</span>, <span class="number">1.0</span>]</span><br><span class="line"></span><br><span class="line">linear_constraint = LinearConstraint([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>]], [<span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">objective_function</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> x[<span class="number">0</span>]**<span class="number">2</span> + <span class="number">4</span>*x[<span class="number">0</span>]*x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">objective_jacobian</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> np.array([<span class="number">2</span>*x[<span class="number">0</span>] + <span class="number">4</span>*x[<span class="number">1</span>], <span class="number">4</span>*x[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">result = sp.minimize(objective_function, </span><br><span class="line">                     x_0,</span><br><span class="line"> method=<span class="string">&#x27;L-BFGS-B&#x27;</span>, </span><br><span class="line">                     jac=objective_jacobian,</span><br><span class="line"> bounds=bounds, </span><br><span class="line">                     options=&#123;<span class="string">&#x27;disp&#x27;</span> : <span class="literal">True</span>&#125;</span><br><span class="line">                     )</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result.x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Solution:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[-<span class="number">8.</span> <span class="number">4.</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="4-conformal-lattice-planning">4. Conformal Lattice Planning</h2><p>介绍完前面的参数曲线和优化问题的求解，下面就要考虑如何进行实现了。回想下使用参数曲线进行优化的前提，是有一组起点状态和终点状态，但这些点如何进行选取呢。选取后如何与原有方法进行结合呢。在这引入 Conformal Lattice Planning 算法，下面具体进行介绍。<br>Conformal Lattice Planning 与所有其他算法一样，目的是规划一条从汽车当前状态到给定目标状态的可行无碰撞路径。重点是，该算法利用了道路的结构化特性，在避免障碍的同时加快规划过程。通过仅关注那些稍微偏离目标路径左侧或右侧的平滑路径选项，制定和人类判断相似的规划。简言之，算法默认驾驶的背景和前提是，除非有紧急停车的情况，否则汽车不应考虑离开道路。<br><img src="../../post-images/878a0ac132e619b134f72b3033aff1fc_MD5.png" alt="|500"><br>因此， 算法选取的目标状态一般是在相对于道路的方向，从中心目标状态横向偏移而形成的，其中包括中心状态以及一系列备选目标状态。如上图所示，每个路径的终点从中心路径横向偏移，该中心路径对应于道路上的目标点。 该目标点以金色突出显示。之所以这样做是因为一般来说车辆都是沿着当前车道前进，所以我们不会去关心其它无关车道，因此我们可以极大地减少搜索空间，从而减少算法的运算量。<br>难点在于，如何选择合理的目标状态呢？通常在选择的过程中需要权衡取舍。假如我们选择的目标状态接近当前的车辆位置，那么可以减少生成到目标点路径所需要的计算量。但同时也会降低算法在避开障碍物时所生成路径的平滑性和舒适性，特别是在高速时，车辆在单位规划周期时间内会走更多的距离。因此，一般我们会根据车速和天气状况等因素来动态计算我们规划中设定的目标范围。<br><img src="../../post-images/3faeb12c9cbf1740177e2e3e9e7631c8_MD5.png" alt="|500"><br>在这为了简化运算，我们使用固定的目标范围。将沿车道中心线的点设为目标点，即目标范围就是我们正前方的距离。如上图所示，黄色的点对应于选定的目标位置，而蓝色的点对应于横向偏移的目标点，这些点将作为 Lattice 中每个螺旋线的端点约束。车道中心线的黑色部分的弧长等于我们选择的目标范围。 在每个规划周期中，我们将基于相同的目标范围重新计算目标点，并沿着车道前进。<br>一旦找到了这些目标状态，我们就可以计算生成到达每个目标所需的螺旋线。此时我们不用担心路径是否冲突，只要求得到运动学上可行的，到达每个目标状态的路径即可。因此，我们可以使用第二部分提到的优化公式来求解从当前状态到每个目标状态的三次螺旋。如果任一螺旋线在运动学上不可行或无法达到所需的目标状态，则将其丢弃，不再视为潜在路径。<br><img src="../../post-images/bd502a42f98da88130f5e91110f62a6f_MD5.png" alt="|500"><br>利用优化公式求解后，我们就得到了结果参数向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 。此时，我们必须停止最初对螺旋系数执行的变换，以便从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 向量中检索它们。一旦有了螺旋系数，我们就可以沿螺旋曲线采样点，以获得整个路径的离散表示。<br><img src="../../post-images/6a62429652a465d4c8b082135ee79cc9_MD5.png" alt="|500"><br>同样，由于我们无法使用螺旋线方程得到目标位置的闭合形式的解，因此需要再次执行数值积分。但是这一次因为我们需要评估多个螺旋线的积分以及多个点，所以需要一种更有效的方法来求解这些积分。在这里，我们采用线性插值方法 – 梯形法则。在这种情况下，梯形法则比 Simpson 法则有效得多，因为沿曲线的每个后续点都可以从前一个法则构建。因此，我们只需要对螺旋进行一次扫描就可以得到所有要求的数值。 而使用 Simpson 法则将要求我们为每个点求解积分近似值，效率要低得多。<br><img src="../../post-images/cbd66c751dbeb8f8bd32c9dc657287b7_MD5.png" alt="|500"><br>在Python中，我们可以使用累积梯形函数cumulative_trapezoid()来实现这一点。一旦应用了梯形规则，对应每个目标点的每个螺旋就都有一个离散表示。重点是，我们要跟踪每个点的曲率，位置和航向，方便我们后面进行速度规划。此时我们有曲率和航向的封闭解，所以不需要数值积分。<br>使用梯形规则后，我们可以为此处显示的每个目标状态生成对应的路径。 在这我们已经有了完整的路径集，下面要看下哪些路径没有冲突。<br><img src="../../post-images/2eb82b34d36e4953ee3502b16831d7e4_MD5.png" alt="|500"><br>在这我们可以使用 Reactive Planner 算法中讨论到的任何一种 Collision check 方法。一般，我们使用二进制栅格进行处理，如果一个单元被占用则记为1，否则为0。然后，我们可以根据栅格中的占用来计算汽车的足迹，将足迹扫过螺旋中的每个点以生成路径的范围。例如，如果条幅中的一个单元的栅格包含障碍物，则此路径将与障碍物发生碰撞，此时对路径进行标记。如果沿整个路径的条带中的任何单元格都从未发生这种情况，则认为该路径没有碰撞。<br>或者我们可以使用圆环检查，将车辆和当前通道中的每个障碍物都作为一个圆来近似。然后，将车辆的圆圈放置在路径上的每个点，并检查与处于当前车道内的每个障碍物的碰撞情况。为了说明碰撞检查的结果，我们在路径中添加了我们现在需要规划的停放车辆。与上一种方法相似，沿着每个路径扫描之后，我们将无碰撞的路径标记为绿色，将与障碍物碰撞的路径标记为红色。<br><img src="../../post-images/308449027bfff324bdbdf827d33e3f7c_MD5.png" alt="|500"><br>注意对每个路径的排序选择，通过目标函数对每个路径进行“惩罚”和“奖励”。离中心目标越远，惩罚越大。仅当参考路径不可行或与障碍物碰撞时才让它偏离参考路径。简单起见，可以将目标函数假设为要检查的路径从中心目标状态到目标状态的位移。然后，我们遍历该路径集中的每个路径，找到最小化此代价的路径，然后选择它作为最终路径发布即可。如下图所示，所选路径以蓝色突出显示。<br><img src="../../post-images/7cc56658e57dc0af4014bb8b40262bf0_MD5.png" alt="|500"><br>沿着路径行驶时多次重复此过程，即可规划出一条收敛到目标状态的路径，同时还可以避免障碍。与之前提到的 Reactive Planner 相似，车辆以渐进的方式朝着远处的目标前进。此时，我们生成的路径是平滑无碰撞的，可以发布给控制器去执行。<br><img src="../../post-images/948c858567dc78ff8139c083f065c76e_MD5.png" alt="|500"></p><h2 id="5-速度曲线生成">5. 速度曲线生成</h2><p>与之前提到的 Reactive Planner 算法不同，在这生成的只是路径集，每个路径点并没有包含参考速度。如何生成合理的速度曲线呢？特别是，规划过程中提供的参考速度，我们前方的动态障碍物的速度，以及保证乘客舒适度和车辆稳定性所需的速度等，都会影响我们速度曲线的生成。下面具体来看下。</p><h3 id="4-1-影响速度的几个因素">4.1 影响速度的几个因素</h3><h4 id="a-behavioral-planner-reference-velocity">a. Behavioral Planner Reference Velocity</h4><p>生成速度曲线的第一步是确定最终所需的速度。一般来说是以Planner给我们的参考速度作为初始值。该参考速度很大程度上受基于当前驾驶场景选择的行为决策的影响。例如我们在十字路口停下来，behavior planner 将向 local planner 发出停止的操作，其中包括输出0速度的参考值。如果我们当前正沿着指定的道路前行，则参考速度可能只是当前道路的速度限制。我们后面用  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mrow><mi>r</mi><mi>e</mi><mi>f</mi></mrow></msub></mrow><annotation encoding="application/x-tex">v_{ref}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 来表示。</p><h4 id="b-dynamic-obstacles">b. Dynamic Obstacles</h4><p>另一个影响因素是动态障碍物，特别是正前方车辆。前车速度时刻影响着我们的速度，因为如果我们超过前车车速则会发生碰撞。回想下，碰撞时间是我们与前方车辆的相对速度以及由s表示的与前方车辆的路径长度的函数。因此，为了保证安全的碰撞时间，我们将参考速度设为前方车辆速度，行为规划速度以及参考速度三者中的最小值。此外，在到达此规划迭代的当前位置之前，我们需要确保当前速度低于前方车辆的速度，否则，我们仍然有与它们碰撞的风险。 通常，在处理动态障碍时，为安全起见，最好在我们的计算中留出空间和时间缓冲。<br><img src="../../post-images/f42af44593c1c9beca9bac15fb2e7ae6_MD5.png" alt="|500"><br>因此，如果我们的路径末端位于前方车辆的当前位置之前，我们需要确保在该点之前达到最终速度，并且留下空间缓冲区，如路径上的红色点所示。当我们到达速度曲线上的红点时，如果它的速度比我们慢，我们就需要达到领先的车速。当我们到达当前位置时，前方的车辆将向前移动。在那一点上，我们将达到它的速度，防止我们与它相撞。请注意，我们还可以进一步引导车辆跟踪，并在给定引导车辆速度的情况下直接确保碰撞或分离距离的安全时间，但这会将控制功能从相对速度跟踪更改为相对距离跟踪。</p><h4 id="c-curvature-and-lateral-acceleration">c. Curvature and Lateral Acceleration</h4><p>影响速度的最后一点是沿规划路径的最大曲率。在上一部分提到，当我们采样优化路径时，我们记录了由大写字母 L 表示的每个点处的螺旋线的曲率。此外，我们在第一部分中提到过，最大的横向加速度也需要限制在以舒适度为边界的“长方形”内。横向加速度取决于瞬时曲率以及沿曲线的纵向速度。 因此，曲率限制了我们在遍历路径时可以采取的纵向速度。我们可以通过确保路径上的每个点的速度保持在限制以下来实现。但是，如果曲率变化很快，我们可能无法在保持在纵向加速度范围内的同时达到所需的速度。因此，我们找到了路径中所有点的最大曲率，然后找到了该点的关联最大速度。<br><img src="../../post-images/264c227110de0940ae3478a18f30eaeb_MD5.png" alt="|500"><br>然后，我们整体必须通过路径上的点达到此所需速度。因此，我们会在最小点上减速至所需速度，并随后进行加速。对于下一个最大的曲率约束我们也重复此过程。以此类推，直到速度曲线沿其长度满足曲率约束为止。就像赛车在经过大转弯时所做的那样，因为转弯的曲率约束限制，首先进行减速操作，达到所需速度后再恢复速度。另一种更简单的方法是，确定最大曲率点，设置关联的速度，然后简单地保持该速度，直到我们通过该点为止。由于我们以回滚方式不断进行重新规划，因此，一旦达到高曲率点，则基于先前定义的其他目标，生成的新速度曲线自然会提高速度。<br>总结下，速度分布图的生成过程，就是将基于曲率的最大速度，行为规划的参考速度以及引导车辆的最大速度这三个速度进行结合的过程。通过选择三个中的最小值来满足最终的期望速度。</p><h3 id="4-2-生成速度曲线">4.2 生成速度曲线</h3><p>接下来，我们需要讨论速度分布图的形状。 最简单的情况是，从当前速度到我们先前计算的所需最终速度间生成线性斜坡曲线。在规划时，我们知道路径的总弧长（表示为s）以及初始速度和最终速度。<br><img src="../../post-images/28f613f935aceed191da100968d3dbdb_MD5.png" alt="|500"><br>我们需要计算的第一件事是所需的加速度，我们可以使用给定的输入直接解决该问题。 我们必须小心确保计算出的加速度不会超出本课程前面所述的舒适矩形。 如果它确实超过了舒适矩形，那么我们将需要对其进行收敛限制。<br><img src="../../post-images/11052b3ae78eb20633935bfbcda65644_MD5.png" alt="|500"><br>如果出于安全考虑（例如在紧急停止操作期间）需要超过舒适矩形的加速度或减速度，那么我们可以绕过该舒适矩形以防止碰撞。 如果要钳制加速度，则需要使用最大加速度max而不是计算出的加速度来相应地更新最终速度。有了加速度曲线后，我们可以通过查看到第i个点的弧长来计算路径上每个点的速度。 通过遍历整个路径并计算每个点所需的速度，我们已经完全沿着路径生成了速度曲线，以达到所需的最终速度。 另一种轮廓是梯形轮廓。<br><img src="../../post-images/053a3031ae24801409ab05ae2f435448_MD5.png" alt="|500"><br>当汽车接近停车标志，并且我们希望从标称速度减速到较低的行驶速度，然后再减速到停车标志处停车时，此功能很有用。 对于此速度曲线，我们将初始速度和最终速度，所需的通过速度和所需的减速度作为输入。 通常选择这种减速度在我们的舒适矩形内，以使轮廓尽可能平滑。<br><img src="../../post-images/106074d82ef95b88b1093ab8fcb73b8e_MD5.png" alt="|500"></p><h4 id="第一段">第一段</h4><p>第一步是计算从初始速度减速到达目标速度需要经过的距离，如图所示是在梯形曲线的第一段期间行进的弧长，在这由第一个等式计算得出，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">S_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 来表示 。因此可以看出，沿着初始路径的弧长应被用作初始减速。这里的初始计算参数包括我们给出的初始速度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，目标速度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">v_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和值为0的加速度。有了该弧长值后，就可以遍历该弧长上的所有点，并使用所示的第二个方程式计算第 i 点所需的速度。<br><img src="../../post-images/167bff904f8d1643360f80f28d5bd59d_MD5.png" alt="|500"></p><h4 id="第三段">第三段</h4><p>然后，我们可以对最后的减速过程（从过程速度到终止速度）重复一个类似的过程。我们将路径的整个弧长表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">S_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。因此，第三部分的长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">S_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 减去 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">S_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。然后，我们可以按如下方式求解 。 一旦有了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">S_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，我们就可以遍历此弧长范围内的所有点，并为它们分配所需的速度，以实现缓慢减速至停止。 然后，轮廓中间的其余点采用我们恒定的过程速度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">S_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<br><img src="../../post-images/ece7f5a4dd5fe32fed6f03dc1a8cfec9_MD5.png" alt="|500"></p><h4 id="所有段">所有段</h4><p>将所有部分组合在一起后可以看到，速度曲线中共有三个区域：初始速度下降缓慢行驶速度，以该速度匀速运行，最后减速到停止点。在这展示了两种生成速度曲线的方法，但还有许多其他方法可以使用使用，例如高阶的biquadratic速度规划器，同样可以最小化轨迹的jerk。可以通过在这使用的两种方法在速度斜坡中应用高阶函数，从而生成更平滑，更舒适的速度曲线。 最终，根据要执行的行为，可以优化速度曲线以满足多个目标，同时满足舒适性和安全性约束。<br><img src="../../post-images/42fdb71ee9163fef196246acf31ce41e_MD5.png" alt="|500"></p><h2 id="5-总结">5. 总结</h2><p>内容很多，总结下。首先我们介绍了路径规划中两种参数曲线类型：螺旋线和样条。之后定义了路径规划问题所需的目标和约束。后面学习了如何进行优化以及将其应用到 Conformal lattice planner，以实现无碰撞的路径。最后，了解了如何沿着路径构造速度分布图，依次满足多个约束条件。</p><h2 id="参考文献">参考文献</h2><ul><li>A. Kelly and B. Nagy, “<a href="https://journals.sagepub.com/doi/abs/10.1177/02783649030227008?casa_token=1eJaU-j-rQMAAAAA%3AkOxyZCACePcPX12nrkI9ytr-xQC0KY9nZ_TZ4m7ClMuSbHmpA8TOnlmNMDQVxa7-K_9bEtOFm820&amp;">Reactive Nonholonomic Trajectory Generation via Parametric Optimal Control,</a>” The International Journal of Robotics Research, vol. 22, no. 7, pp. 583–601, 2003. This paper discusses the math behind generating spirals to desired terminal states.</li><li>A. Piazzi and C. G. L. Bianco, “<a href="https://ieeexplore.ieee.org/abstract/document/898341">Quintic G/sup 2/-splines for trajectory planning of autonomous vehicles</a>,” Proceedings of the IEEE Intelligent Vehicles Symposium 2000 (Cat. No.00TH8511). This paper discusses the math behind generating quintic splines to desired terminal states.</li><li>M. Mcnaughton, C. Urmson, J. M. Dolan, and J.-W. Lee, “<a href="https://ieeexplore.ieee.org/abstract/document/5980223">Motion planning for autonomous driving with a conformal spatiotemporal lattice</a>,” 2011 IEEE International Conference on Robotics and Automation, 2011. This paper introduces the concepts behind generating a conformal spatiotemporal lattice for on-road motion planning.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Automotive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Automotive </tag>
            
            <tag> Path-Planning </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐：可能是目前最好的自动驾驶教程</title>
      <link href="/posts/Automotive/20191025-amazing-automotive-course.html"/>
      <url>/posts/Automotive/20191025-amazing-automotive-course.html</url>
      
        <content type="html"><![CDATA[<p>从年初到现在，终于搞定了这个专项。Coursera平台推出的自动驾驶教程：Self-Driving Cars。在这对四期课程做个比较全面的总结，同时向大家推荐下，希望帮大家在自动驾驶学习路上添砖加瓦。<br>课程github整理：<a href="https://github.com/qiaoxu123/Self-Driving-Cars">链接</a></p><h3 id="1-前言">1. 前言</h3><p><a href="https://zhuanlan.zhihu.com/write">Coursera</a>是国际上很著名的付费学习平台，其中耳熟能详的课程包括吴恩达的《机器学习教程》，《算法》等，该平台由国外内知名大学在线推出课程供大家学习。在2018年中由多伦多大学推出了一套自动驾驶专项，<a href="https://www.coursera.org/specializations/self-driving-cars">链接</a>。其中包括了四期课程，如图所示：</p><p><img src="../../post-images/acb0696c4e61154580eae013a046323f_MD5.png" alt=""><br>关于这套课程的具体信息和推荐，网上有很多，大家可以查阅下<a href="https://zhuanlan.zhihu.com/p/56167613">链接</a>。而在这我想以一个学习者的身份向大家重新介绍一下这个课程，以及从中收货的一些心得体会。</p><hr><h3 id="2-课程内容介绍">2. 课程内容介绍</h3><p>课程总共分为四部分，因为个人方向关系，刚开始我把兴趣点放在了Part4:Motion Planning部分，考虑到尽可能体系化学习，同时仿真器环境直接上手可能不习惯，因此决定从Part1部分慢慢学起，从此一发不可收拾。</p><p>目前网上能找到的资料，最多的是优达学城的自动驾驶教程，或者是麻省理工学院的强化学习自动驾驶教程。与上面提到的两个课程类似，多伦多大学这套课程很注重体系化的教学，从一开始的车辆控制部分课程入手，到最后的运动规划，循序过渡。进入课程中具体来看，每门课的理论知识点都有的放矢，不放过简单的知识点，让新手能成功上手，又在重点难点的部分多多着墨，让行业工作者也能耳目一新。放下Part4课程对比下（因为图片尺寸关系，只有部分，一共7课）</p><p><img src="../../post-images/9ae719b09e4ae761646fd97a6e093136_MD5.png" alt="|470"><br>对于课程的内容，从制作的PPT中可以看出，主办方真的很用心去做，使用各种插图还有车辆仿真行驶的动态图来充分说明知识点，给出的公式一般也会一一说明，同时关键算法部分也会使用配图进行解释。对于新手而言真的很友好。</p><p><img src="../../post-images/22555490a29a3e19925b0ad3d4acb362_MD5.png" alt=""></p><p><img src="../../post-images/7f262a777a854214bd1a00cc778666cd_MD5.png" alt=""></p><p>在这就不一一列举了，大家具体可以去我整理的Github仓库看一下。</p><p>想重点说明一下的是，课程中的实践部分对整个课程的理解帮助很大，在课程中间会不定地穿插使用jupyter notebook写好的练习题目，让大家在理解课程的基础上进行补充。课程全部使用python语言，要求对python的基本语法熟练掌握，同时了解并可以使用各种算法库。另外，在课程的最后，除了Part3外，都使用Carla仿真器作为作业平台。Carla是由Intel开源的自动驾驶仿真平台，其使用的广泛程度也不亚于优达学城的仿真器。想重点说明下，如果按照网上的安装方法，在电脑上进行完整安装，性能差的笔记本是很难搞定的，特别是显卡差的情况。在这出品方多伦多大学给出一个简易版安装方法，由其使用python进行适配，普通电脑也可以使用。</p><p>在这放下我的Part4期末作业的效果图：</p><p><img src="../../post-images/b9d7b568fbd6dcf5947f33d28ded6636_MD5.jpg" alt=""></p><hr><h3 id="3-个人学习体会">3. 个人学习体会</h3><p>整个专项课程分为四部分，从官方的介绍中大家可以了解的更深入，在这不再赘述。根据个人学习过程的体会和感受，对于该课程，每个人需要根据个人情况合理划分下学习重心和分配精力，不应该简单地一概而论。既可以进行框架型的理解，也可以就某个部分进行深度研究学习（通过参考文献）。</p><p>课程总体是偏难的，面向的对象应该对自动驾驶的整体框架有一定认识，同时具备一定的代码功底和数学功底。我强烈推荐大家根合理对这门课进行重心分配，如果有条件，根据个人专业方向进行二刷可以吸收的更多。</p><p>课程中一开始会对行业中各种基本概念进行介绍，包括算法的来源，在自动驾驶中的应用场景以及基本原理等。这一部分建议大家花费较多时间去理解和吸收，毕竟这是行业的根基。当能够熟练复述相关的知识点后，最好是把给出的参考论文对应进行阅读，如果不能理解可以放在课程结束后再重新阅读，作为个人视野的扩展和丰富。除此之外，课程中的知识点很多，最好根据官方给出的框架进行定位和联系。在复习的过程中，可以重新提炼和思考。通过仿真平台，大家可以亲自上手多次重复进行练习，如果时间允许可以根据个人需要添加自己的实现代码进行测试。</p><p>目前所有课程官方均已更新完毕，强烈建议大家注册课程学习（可以申请奖学金），这样可以通过作业对学到的知识点进行强化，同时收货证书嘻嘻。</p><hr><h3 id="4-资料整理">4. 资料整理</h3><p>所有课程资源，视频，PPT以及字幕等均已更新到个人github。</p>]]></content>
      
      
      <categories>
          
          <category> Automotive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Automotive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18下 ROS 使用 Protobuf 共享内存实现节点通信</title>
      <link href="/posts/System-development/20190806-ubuntu18-ros-protobuf-shared-memory-communication.html"/>
      <url>/posts/System-development/20190806-ubuntu18-ros-protobuf-shared-memory-communication.html</url>
      
        <content type="html"><![CDATA[<p>最近在折腾ROS两个节点之间的通信实现，每个的功能都很简单，需要解决的地方在于两个之间的通信量很大，延迟要很低才行。确定使用protobuf共享内存后，网上查阅了好多资料才最终实现。在这实现一个最小的demo作为记录，希望能对后来者有帮助！ <a href="https://github.com/qiaoxu123/demo_project/tree/master/work_ws">github链接</a></p><h2 id="1-protobuf-与共享内存">1. protobuf 与共享内存</h2><p>关于二者的概念，网上资料很多，在这最基本的说明下。ROS中传统的通信方式是socket实现，通过订阅和发布信息实现通信，另外服务和参数服务器因为暂未涉及在这不进行比较。这种方式虽然延时也很低但当数据量比较大，对传输稳定性要求高或者更高传输速率时，便显得不那么合适了。</p><p>共享内存指的是通过对一块固定内存进行映射，使得不同程序或线程可以异步访问。通过这种数据拷贝的方式实现通信，速率和稳定性上有极大的提升。另外介绍下protobuf，可以简单理解为一种数据封装通信协议，可以实现不同语言之间的数据通信，而且可以离线更改和扩展，具体请查阅资料。</p><ul><li><a href="https://blog.csdn.net/xiexievv/article/details/47396725">protohuf安装</a></li><li><a href="https://www.cnblogs.com/cv-pr/p/6296587.html">proto文件编写</a><br>关于安装的具体步骤以及具体语法在这不一一细谈了，可以查看参考链接自行安装。在过程中，个人感觉有几点需要注意的在这说明下： 1. Ubuntu自身带有protobuf，最好提前卸载，替换成官方最新的，网上有资料自行查阅 2. 关于protobuf的安装路径说法不一，个人倾向于默认安装也就是官方安装，如自己指定安装目录后面程序运行还需要自己配置环境变量，有点麻烦</li></ul><h2 id="2-实现细节">2. 实现细节</h2><p>下面通过client和server两个节点之间最简单通信，来比较详细的说明protobuf与共享内存结合实现通信的过程。</p><h3 id="2-1-创建工程">2.1 创建工程</h3><p>创建ros工作空间，并创建server和client两个节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir work_ws</span><br><span class="line">cd work_ws &amp; mkdir src</span><br><span class="line">catkin_init_workspace</span><br><span class="line">cd ..</span><br><span class="line">catkin_make</span><br><span class="line">cd src</span><br><span class="line">catkin_create_pkg server roscpp</span><br><span class="line">catkin create_pkg client roscpp</span><br></pre></td></tr></table></figure><p>下面分别在两个节点下创建文件，最后创建完结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── client</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── client</span><br><span class="line">│   │       ├── client.cc</span><br><span class="line">│   │       └── client.h</span><br><span class="line">│   ├── package.xml</span><br><span class="line">│   ├── proto</span><br><span class="line">│   │   └── agreement.proto</span><br><span class="line">│   └── src</span><br><span class="line">│       └── client_node.cc</span><br><span class="line">├── CMakeLists.txt </span><br><span class="line">└── server</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── include</span><br><span class="line">    │   └── server</span><br><span class="line">    │       ├── server.cc</span><br><span class="line">    │       └── server.h</span><br><span class="line">    ├── package.xml</span><br><span class="line">    └── src</span><br><span class="line">        └── server_node.cc</span><br></pre></td></tr></table></figure><h3 id="2-2-proto文件编写">2.2 proto文件编写</h3><p>在client节点中单独创建一个proto文件夹，用于存放proto文件。关于其具体语法请自行查阅，在这使用protobuf3版本，与版本2相比有些许不同。程序为一个最简单的message信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">message agreement &#123;</span><br><span class="line">  <span class="type">double</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">double</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="type">double</span> y = <span class="number">3</span>;</span><br><span class="line">  <span class="type">double</span> z = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> flag = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是最复杂的地方，也就是CMakeLists.txt文件的编写，网上资料很少，在这给出一个<a href="https://blog.csdn.net/weixin_40528417/article/details/89374397">参考链接</a>。可以结合我工程中的代码仔细理解下(我也不是很理解。。。)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(client)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">## System dependencies are found with CMake&#x27;s conventions</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake)</span><br><span class="line"><span class="keyword">include</span>(FindProtobuf)</span><br><span class="line"><span class="keyword">find_package</span>(Protobuf REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(proto_dir <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/proto)</span><br><span class="line"><span class="keyword">file</span>(GLOB proto_files <span class="string">&quot;$&#123;proto_dir&#125;/*.proto&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up destination directories</span></span><br><span class="line">catkin_destinations()</span><br><span class="line"><span class="keyword">set</span>(proto_gen_dir <span class="variable">$&#123;CATKIN_DEVEL_PREFIX&#125;</span>/<span class="variable">$&#123;CATKIN_GLOBAL_INCLUDE_DESTINATION&#125;</span>/proto)</span><br><span class="line"><span class="keyword">set</span>(proto_gen_cpp_dir <span class="variable">$&#123;proto_gen_dir&#125;</span>)</span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> <span class="variable">$&#123;proto_gen_dir&#125;</span>)</span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> <span class="variable">$&#123;proto_gen_cpp_dir&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(protogen_include_dirs <span class="variable">$&#123;proto_gen_cpp_dir&#125;</span>/../ <span class="variable">$&#123;proto_gen_python_dir&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create lists of files to be generated</span></span><br><span class="line"><span class="keyword">set</span>(proto_gen_cpp_files <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">foreach</span>(proto_file <span class="variable">$&#123;proto_files&#125;</span>)  </span><br><span class="line">  <span class="keyword">get_filename_component</span>(proto_name <span class="variable">$&#123;proto_file&#125;</span> NAME_WE)</span><br><span class="line">  <span class="keyword">list</span>(APPEND proto_gen_cpp_files </span><br><span class="line">       <span class="variable">$&#123;proto_gen_cpp_dir&#125;</span>/<span class="variable">$&#123;proto_name&#125;</span>.pb.h </span><br><span class="line">       <span class="variable">$&#123;proto_gen_cpp_dir&#125;</span>/<span class="variable">$&#123;proto_name&#125;</span>.pb.cc</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">endforeach</span>(proto_file <span class="variable">$&#123;proto_files&#125;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Run protoc and generate language-specific headers.</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT <span class="variable">$&#123;proto_gen_cpp_files&#125;</span></span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;PROTOBUF_PROTOC_EXECUTABLE&#125;</span> --proto_path=<span class="variable">$&#123;proto_dir&#125;</span> --cpp_out=<span class="variable">$&#123;proto_gen_cpp_dir&#125;</span> <span class="variable">$&#123;proto_files&#125;</span></span><br><span class="line">  DEPENDS <span class="variable">$&#123;PROTOBUF_PROTOC_EXECUTABLE&#125;</span> <span class="variable">$&#123;proto_files&#125;</span></span><br><span class="line">  WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_source_files_properties</span>(<span class="variable">$&#123;proto_gen_cpp_files&#125;</span> PROPERTIES GENERATED <span class="keyword">TRUE</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_target</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_headers</span><br><span class="line">  DEPENDS <span class="variable">$&#123;proto_gen_cpp_files&#125;</span> </span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Create proto library for lining.</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROTOBUF_INCLUDE_DIR&#125;</span> <span class="variable">$&#123;PROTOBUF_INCLUDE_DIR&#125;</span>/../../)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_proto <span class="variable">$&#123;proto_gen_cpp_files&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_proto <span class="variable">$&#123;PROTOBUF_LIBRARY&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_proto <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_headers)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line">  INCLUDE_DIRS <span class="variable">$&#123;protogen_include_dirs&#125;</span></span><br><span class="line">  LIBRARIES <span class="variable">$&#123;PROJECT_NAME&#125;</span>_proto</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS <span class="variable">$&#123;PROJECT_NAME&#125;</span>_proto</span><br><span class="line">  ARCHIVE DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span></span><br><span class="line">  LIBRARY DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span></span><br><span class="line">  RUNTIME DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(DIRECTORY <span class="variable">$&#123;proto_gen_cpp_dir&#125;</span>/</span><br><span class="line">  DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125;</span></span><br><span class="line">  FILES_MATCHING PATTERN <span class="string">&quot;*.h&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line">  INCLUDE_DIRS <span class="keyword">include</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">  <span class="variable">$&#123;PROTOBUF_INCLUDE_DIR&#125;</span></span><br><span class="line">  <span class="variable">$&#123;CATKIN_DEVEL_PREFIX&#125;</span></span><br><span class="line">  <span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  <span class="keyword">include</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/client.cc</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(client_node src/client_node.cc <span class="keyword">include</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/client.cc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node </span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">  <span class="variable">$&#123;PROTOBUF_LIBRARIES&#125;</span></span><br><span class="line">  <span class="variable">$&#123;Boost_FILESYSTEM_LIBRARY&#125;</span></span><br><span class="line">  <span class="variable">$&#123;Boost_SYSTEM_LIBRARY&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最后实现效果是在work_ws工作空间的devel文件夹下创建include文件夹放置生成的proto头文件。因为关于ROS中使用protobuf没有足够的参考的资料，所以就随性发挥了。也想过参考Apollo放置在节点的proto文件夹下，但是节点之间message的引用也很麻烦，细想放在devel文件夹下引用可能会更方便，所以就没有再花费时间更改。生成文件效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include/</span><br><span class="line">└── proto</span><br><span class="line">    ├── agreement.pb.cc</span><br><span class="line">    └── agreement.pb.h</span><br></pre></td></tr></table></figure><p>大家可以对照CMakeLists.txt文件理解其中的实现过程。需要注意的是，如果其他节点想要调用生成的proto头文件，需要在其本身的CMakeLists.txt中的include_directories中包含devel文件夹的位置变量，否则引用会报错，如下</p><h2 id="code-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include_directories(</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125; </span><br><span class="line">  $&#123;PROTOBUF_INCLUDE_DIR&#125;</span><br><span class="line">  $&#123;CATKIN_DEVEL_PREFIX&#125;  # this should be added</span><br><span class="line">  include</span><br><span class="line">)</span><br></pre></td></tr></table></figure></h2><h3 id="2-3-主程序编写">2.3 主程序编写</h3><p>下面以client节点为例说明下主程序的实现，并介绍共享内存的调用实现。整个工程代码已上传github，请自行查阅 client.h文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLIENT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/proto/agreement.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Client &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">client</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">client</span>();</span><br><span class="line">  ~<span class="built_in">client</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> shmID;              <span class="comment">// 共享内存标识符</span></span><br><span class="line">  <span class="type">void</span> *shm = <span class="literal">nullptr</span>;    <span class="comment">// 与进程内存连接地址</span></span><br><span class="line">  agreement *mem = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace Client</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>关于共享内存只需要记住三个头文件，四个函数即可，理解起来比多进程容易多了。详细查阅<a href="https://blog.csdn.net/mybelief321/article/details/9170041">参考资料</a>。下面是client.cc文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;client/client.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Client;</span><br><span class="line"></span><br><span class="line">client::<span class="built_in">client</span>() &#123;</span><br><span class="line">  shmID = <span class="built_in">shmget</span>((<span class="type">key_t</span>)<span class="number">1933</span>, <span class="built_in">sizeof</span>(agreement), <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">  <span class="keyword">if</span> (shmID != <span class="number">-1</span>) &#123;</span><br><span class="line">    shm = <span class="built_in">shmat</span>(shmID, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Cann&#x27;t get shared memory,error num is %d, for %s\n&quot;</span>, errno,</span><br><span class="line">              <span class="built_in">strerror</span>(errno));</span><br><span class="line">  &#125;</span><br><span class="line">  mem = (agreement *)shm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> client::<span class="built_in">sendMessage</span>() &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Ready to send message to client &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">double</span> id = <span class="number">1</span>, x = <span class="number">2</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    mem-&gt;<span class="built_in">set_flag</span>(<span class="literal">true</span>);</span><br><span class="line">    mem-&gt;<span class="built_in">set_id</span>(id++);</span><br><span class="line">    mem-&gt;<span class="built_in">set_x</span>(x++);</span><br><span class="line">    mem-&gt;<span class="built_in">set_y</span>(y++);</span><br><span class="line">    mem-&gt;<span class="built_in">set_z</span>(z++);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client::~<span class="built_in">client</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">shmdt</span>(shm) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Error is %d, cann&#x27;t not release shared memory. for %s\n&quot;</span>, errno,</span><br><span class="line">              <span class="built_in">strerror</span>(errno));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照参考资料，代码很容易理解，需要注意的是，在这直接指定了共享内存标识符，目的是方便后面的节点直接访问。</p><hr><h3 id="2-4-程序运行">2.4 程序运行</h3><p>最后程序运行效果如下：</p><p><img src="../../post-images/bafdd41c8398c8eac0c12aadf4de52e3_MD5.png" alt=""></p><p>client节点计数，server节点读取打印。</p><hr><h3 id="3-总结">3. 总结</h3><p>综上，在ros环境下实现了protobuf共享内存的节点通信，复杂之处主要在于包含了protobuf文件的CMakeLists.txt文件的编写，后面就简单多了。</p>]]></content>
      
      
      <categories>
          
          <category> System-development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> Protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scan Line Run 聚簇算法原理与实现</title>
      <link href="/posts/Automotive/20190627-scan-line-run-algorithm.html"/>
      <url>/posts/Automotive/20190627-scan-line-run-algorithm.html</url>
      
        <content type="html"><![CDATA[<p>参考论文： <a href="https://ieeexplore.ieee.org/abstract/document/7989591">Fast segmentation of 3D point clouds: A paradigm on LiDAR data for autonomous vehicle applications</a> <a href="https://github.com/VincentCheungM/Run_based_segmentation/blob/master/nodes/clustering/scanlinerun.cpp">代码地址</a></p><h3 id="1-提取地面点-gpf算法">1．提取地面点(GPF算法)</h3><p><a href="https://blog.csdn.net/AdamShan/article/details/84569000">参考博客</a></p><h3 id="2-聚类-slr算法">2.  聚类(SLR算法)</h3><blockquote><p>下面的文章主要是Paper原文的翻译，为了补充理解添加个人注释</p></blockquote><h4 id="2-1-基本原理">2.1 基本原理</h4><p>不属于地面的剩余点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>n</mi><mi>g</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P_{ng}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>需要形成要使用的簇，用在更高级别的后处理方案中。 我们的目标是为每个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>k</mi><mo>∈</mo><msub><mi>P</mi><mrow><mi>n</mi><mi>g</mi></mrow></msub></mrow><annotation encoding="application/x-tex">pk∈P_{ng}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 获取一个代表其集群标识的标签 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，同时使用简单的机制来确保过程的快速运行时间和低复杂性。伪算法如下<br><img src="../../post-images/bc55f30cf40a0d2cd4a0977d3d847f97_MD5.png" alt="在这里插入图片描述"><br>从伪代码中可以提取这几个关键量，为了后面的理解方便：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> ：输入点云</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mrow><mi>s</mi><mi>c</mi><mi>a</mi><mi>n</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">N_{scanlines}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> : 扫描行数</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><msub><mi>h</mi><mrow><mi>r</mi><mi>u</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Th_{run}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> : 属于同一 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">run</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span></span></span></span> 的点的阈值</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>h</mi><msub><mi>j</mi><mrow><mi>m</mi><mi>e</mi><mi>r</mi><mi>g</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Thj_{merge}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> : 合并相邻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">run</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span></span></span></span> 的阈值</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>w</mi><mi>L</mi><mi>a</mi><mi>b</mi><mi>e</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">newLabel</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">L</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> :标签标识</li></ul><p>在360°LiDAR传感器数据的情况下，3D点云的多层结构很类似于2D图像的行方向结构，主要差异在于每层中的元素的不均匀数量及其圆形形式。 <strong>所提出的解决方案将3D点视为图像的像素，并且从二进制图像调整两次运行的连通分量标记技术以产生实时3D聚类算法。</strong></p><p>我们将从同一个LiDAR环产生的一层点称为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>a</mi><mi>n</mi><mo>−</mo><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">scan-line</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span></span></span></span> (扫描线）。 在每个扫描线中，其元素被组织在称为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">runs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> (运行)的连续点的向量中。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">runs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 中的元素共享相同的标签，并且是集群的主要构建块。<br><img src="../../post-images/8d611adef639ea7b18f13fd5ee9e1355_MD5.png" alt="在这里插入图片描述"><br>根据图2，在不失一般性的情况下，我们假设点云 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>n</mi><mi>g</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P_{ng}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 从顶部扫描线开始以光栅逆时针方式遍历。形成第一扫描线的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">runs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 并且每个扫描线都接收其自己的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>w</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>e</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">new label</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> ，该标签由其所有点元素继承。然后，第一条扫描线的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">runs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 成为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi><mi>s</mi><mi>A</mi><mi>b</mi><mi>o</mi><mi>v</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">runsAbove</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">A</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span></span></span></span>，用于将其标签传播到后续扫描线中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">runs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 。当新运行点与上一扫描线中最近邻点之间的距离小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><msub><mi>h</mi><mrow><mi>m</mi><mi>e</mi><mi>r</mi><mi>g</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Th_{merge}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 时，标签将传播到新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">runs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 。当同一 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">runs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 中的多个点具有不同的可继承标签的最近邻居时，获胜标签是最小的。另一方面，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">runs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 中的任何点都找不到合适的最近邻居时，它会收到一个新的标签。以上是通过点云单次执行的，当完成此操作时，执行第二次传递以最终更新点标签和提取簇。</p><p><img src="../../post-images/7e1323a8569ac5eb26d5d307549a90bc_MD5.png" alt="在这里插入图片描述"></p><p>附图1的以下示例覆盖了所提出的算法的主要实例，其中白色和彩色圆圈分别代表地面和非地面点。蓝色圆圈是尚未访问过的非地面点。</p><ul><li><strong>步骤 a</strong> 中，第一扫描线初始化为两次运行（橙色和绿色），每次运行接收新标签（三角形内的1和2）。</li><li><strong>步骤 b</strong> 演示了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>w</mi><mi>L</mi><mi>a</mi><mi>b</mi><mi>e</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">newLabel</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">L</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 的分配和两个标签的传播。特别是，最近的8的非地面邻居是2并且它们的距离大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><msub><mi>h</mi><mrow><mi>m</mi><mi>e</mi><mi>r</mi><mi>g</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Th_{merge}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。在这种情况下，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>b</mi><mi>e</mi><mi>l</mi><mi>s</mi><mi>T</mi><mi>o</mi><mi>M</mi><mi>e</mi><mi>r</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">labelsToMerge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span></span></span></span> 为空，第8点代表新的集群。另一方面，最近的10的非地面邻居是3，其距离小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><msub><mi>h</mi><mrow><mi>m</mi><mi>e</mi><mi>r</mi><mi>g</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Th_{merge}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，这使得标签1传播到点10。类似地，点12和13都接近它们各自的邻居5和6，并基于非空  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>b</mi><mi>e</mi><mi>l</mi><mi>T</mi><mi>o</mi><mi>M</mi><mi>e</mi><mi>r</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">labelToMerge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span></span></span></span>，标签2分配给它们。</li><li><strong>步骤 c</strong> 中考虑最终扫描线，其中存在一次运行。点17和19具有邻居10和12，它们属于不同的簇并且都适合于传播它们的标签。根据我们的算法逻辑，两个标签中的最小标签（即标签1）是继承的。</li><li><strong>步骤 d</strong> 中，注意并标记两个标记1和2的合并，并通过下面讨论的标签等效解析技术进行处理。</li></ul><hr><h4 id="2-2-实现细节">2.2 实现细节</h4><p>算法的概要是直截了当的，但为了有效实现，我们提出了（i）如何创建 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">runs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>，（ii）如何寻找最近邻居，以及（iii）当合并两个或多个连接组件如何解决标签冲突的解决方案。<br><img src="../../post-images/62370e6200807c078fb422010dc4c43c_MD5.png" alt="在这里插入图片描述"></p><p>i）在扫描线的第一次访问时创建 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">run</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span></span></span></span> 作为索引的向量，并且保持关于哪些连续点足够接近被认为是扫描线内的单个块的信息。 考虑到扫描线的圆形形式，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">run</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span></span></span></span> 可以桥接第一个和最后一个凹槽。 当检测到时，通过在第一次 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">run</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span></span></span></span> 的开始处附加扫描线末端的凹口来解决这种情况，如图3的示例所示。</p><p>ii）当输入点云以圆柱坐标表示，其中点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">[</mo><mi>r</mi><mi>θ</mi><mi>z</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x = [r θ z]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">]</span></span></span></span>，则可以将上面扫描线中最近邻居的索引视为简单地比较θ值。然而，在自动驾驶车辆应用中，聚类是更大的传感器和算法系统的一个小组件，并且出于兼容性原因，优选笛卡尔坐标系。在实现方面，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>a</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">naive</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span></span></span></span> 的解决方案是<strong>使用上面扫描线中的所有非接地点构建 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>d</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">kdtree</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span></span></span></span> 结构，并使用它来查找每个最近邻居</strong>，从而产生可以进一步细化的次优但可行的解决方案。</p><p>假设扫描线中的点沿整个扫描线均匀分布，我们采用智能索引方法，克服了不同扫描线中元素数量不均匀的问题，并大大减少了查询最近的邻居的数量。假设每个扫描线具有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">N_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个点，并且每个点具有两个空位;一个全局 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><msub><mi>d</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">ind_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示它在整个点云中的位置，一个本地 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><msub><mi>d</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">ind_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示扫描线内的点。可以通过以下方式轻松地在扫描线 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 的凹槽之间切换：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><msub><mi>d</mi><msub><mi>l</mi><mi>K</mi></msub></msub><mo>=</mo><mi>i</mi><mi>n</mi><msub><mi>d</mi><mi>g</mi></msub><mo>−</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>K</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>N</mi><mi>i</mi></msub><mo separator="true">,</mo><mtext> </mtext><msub><mi>N</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i n d_{l_{K}}=i n d_{g}-\sum_{i=0}^{K-1} N_{i},   \ N_{0}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.944745em;vertical-align:-0.250305em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.01968em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.250305em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.1060050000000006em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>给定具有局部索引 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><msub><mi>d</mi><msub><mi>l</mi><mi>i</mi></msub></msub></mrow><annotation encoding="application/x-tex">ind_{l_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9445399999999999em;vertical-align:-0.2501em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.01968em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span> 的扫描线 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 中的点索引，可以通过以下等式直接在上述扫描线 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 中的实际最近邻居的附近找到邻居 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><msub><mi>d</mi><msub><mi>l</mi><mi>i</mi></msub></msub></mrow><annotation encoding="application/x-tex">ind_{l_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9445399999999999em;vertical-align:-0.2501em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.01968em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span> 的局部索引：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><msub><mi>d</mi><msub><mi>l</mi><mi>j</mi></msub></msub><mo>=</mo><mi>f</mi><mi mathvariant="normal">loor</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><msub><mi>N</mi><mi>j</mi></msub><msub><mi>N</mi><mi>i</mi></msub></mfrac><mi>i</mi><mi>n</mi><msub><mi>d</mi><msub><mi>l</mi><mi>i</mi></msub></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">i n d_{l_{j}}=f \operatorname{loor}\left(\frac{N_{j}}{N_{i}} i n d_{l_{i}}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04176em;vertical-align:-0.34731999999999996em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.01968em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm">o</span><span class="mord mathrm">r</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.01968em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>和从公式3计算它的全局系数相同</p><blockquote><p>放弃对最佳匹配的追求，考虑算法的开销提出解决方案</p></blockquote><p>根据扫描线内部点的分布，索引可能不会指示最近的邻居，而是指示足够接近的点。在这种情况下，可能需要在其周围的多个点中搜索最近的邻居，但是该数量远小于考虑整个扫描线。在运行中，识别潜在邻居并搜索其周围环境以获得最佳匹配会导致大量开销，从而破坏算法的性能。考虑到这一点，所提出的解决方案是通过<strong>智能索引</strong>找到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>u</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">run</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span></span></span></span> 的第一个和最后一个点的最近邻居，形成具有该范围内的所有非地面点的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>d</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">kdtree</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span></span></span></span> 结构，并使用它来搜索最近的邻居。<br><img src="../../post-images/07b3d504f3e91c51a87c71ba5fb5ec5a_MD5.png" alt="在这里插入图片描述"><br>智能索引的两个可视化示例可以在图4中看到。在a）中，虽然两条扫描线中的点数完全不同，但是随机选择的点在外部具有局部凹陷8,16,26和32扫描线表示为内部扫描线中分别具有局部凹陷5,9,15和18的点的最近邻居。此外，在b）点的分布非常不均匀，但智能索引仍然成功地表明适当的邻居。这些情况对于前几条扫描线是常见的，因为它们的一些激光束由于吸收或非常高的距离而永远不会返回。在极少数情况下，连续扫描线之间的点数差别很大或者扫描线的很大一部分缺失，智能索引很可能会失败。在这些情况下，将整个扫描线视为潜在最近邻居的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>a</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">naive</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span></span></span></span> 解决方案仍然可以产生良好的结果。</p><p>iii）在[13]中引入了解决标签合并冲突的方法，其中提供了实施和深入理解的所有细节。下面简要介绍要点和简单示例。</p><p>当两个或更多不同的标记组件需要合并时，出现标签合并冲突。据He等人说。通过在同一组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>  中累积它们的标签 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 并利用具有三个一维阵列的复杂方法来捕获它们的层次结构和连接来给出解决方案。所有三个向量都具有在第一次通过点云期间创建的总标签数量的大小。第一个向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>“</mtext><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mtext>”</mtext></mrow><annotation encoding="application/x-tex">“next”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">“</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mord">”</span></span></span></span> 的每个条目在其 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 中存储下一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> ，并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 中最后一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 的条目为-1。接下来，向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>“</mtext><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi><mtext>”</mtext></mrow><annotation encoding="application/x-tex">“tail”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">“</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">”</span></span></span></span> 将索引存储到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 的最后一个。最后一个向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>“</mtext><mi>r</mi><mi>t</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mtext>”</mtext></mrow><annotation encoding="application/x-tex">“rtable”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">“</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord">”</span></span></span></span> 具有报告每个l的最终标签在任何给定时刻将是什么的辅助作用。在第一次通过结束时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>t</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">rtable</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> 用作最终标签的查找表。</p><p>让我们从三个向量的角度来看待图2的例子。在第一步a）中，创建两个标签（1和2）并填充 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">l1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">l2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">2</span></span></span></span> 条目。两个集合中的每一个只有一个元素，因此下一个条目都是-1，尾部条目表示S中最后一个元素的索引，对于两个集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 分别是1和2，并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>t</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">rtable</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> 表示最终的代表性标签。接下来，在b）中创建 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">l3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">3</span></span></span></span> 并且向量填充与之前相同的向量。最后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">S2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span></span></span></span> 合并，这意味着 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">next</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span> 的第一个条目将指向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span></span></span></span> 中下一个元素的索引，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span></span></span></span> 中两个元素的尾部是相同的，并指向该集合的最后一个元素的索引，并更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>t</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">rtable</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> 以正确描绘最终标签。</p><hr><h4 id="2-3-实验结果">2.3. 实验结果</h4><p><img src="../../post-images/6fca74e1844d5410b5b62f76427a47ca_MD5.png" alt="在这里插入图片描述"><br>得到的簇可以在图7中的黄色边界框内看到。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>L</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">SLR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 算法利用了点云的结构，并且比以不规则方式遍历点云的算法执行得快得多。 图5b中所示的图表示随着点数的增加，时间的线性增加。 相比之下，欧几里德群集提取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（</mtext><mi>E</mi><mi>C</mi><mi>E</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">（ECE）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">）</span></span></span></span>算法随着点数的增加呈指数级增长。 需要在整个数据集中搜索邻居的聚类算法，其性能基于云的总点数。 另一方面，对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>L</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">SLR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 的搜索受其运行大小的限制，并且仅在一条扫描线上考虑邻居以实现更好的性能。<br><img src="../../post-images/cb1d97c3d33ebe15aa8709a4477f51a1_MD5.png" alt="在这里插入图片描述"><br>如图8所示，点云中的点密度的降低影响 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>L</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">SLR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 分割，其中过度分割的情况在8b中呈现。 该算法对于传感器附近的物体表现令人满意，因为相邻车辆已被正确分割。 在图9中提供了用于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>L</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">SLR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>C</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">ECE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> 之间的比较的更多结果，其中注意到两种算法的类似行为。 由于阈值参数和3D点访问顺序的差异，存在小的变化。<br><img src="../../post-images/3cca5b1ff25e9afc6c5818954aa1824f_MD5.png" alt="在这里插入图片描述"><br><img src="../../post-images/d50ca61a0f4e79c544d57d0ee022f752_MD5.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Automotive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> Automotive </tag>
            
            <tag> 点云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM 开发板开机自启</title>
      <link href="/posts/System-development/20190314-ARM-board-autostart.html"/>
      <url>/posts/System-development/20190314-ARM-board-autostart.html</url>
      
        <content type="html"><![CDATA[<p>最近调试工程，ARM开发板开机自启问题，困扰了一周左右，现在终于解决，整理记录！</p><h3 id="一-背景">一、背景</h3><blockquote><p>开发板型号：飞凌嵌入式OKMX6X-S3（<a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.24252e8dR0TiLL&amp;id=540409490040&amp;_u=k25861s80f54">地址</a>）<br>4G模块：华为me909s模块</p></blockquote><p>问题来源：因为开发板需要商业应用，所以需要配置自动联网。而在官网提供的文档中，对于华为me909s模块的启动，需要通过拨号命令来实现，所以开始进行问题尝试。</p><hr><h3 id="二-解决">二、解决</h3><p>网上搜索ARM开发板开机自启，会有非常多的教程。现在分析自己的需求和问题有两个：</p><ul><li>开机启动后自动进行命令行</li><li>自动启动4G模块<br>实际应用参考这篇<a href="https://www.linuxidc.com/Linux/2011-05/36109.htm">博客</a>即可。而我在实际应用中遇到的问题是，可以启动4G模块的命令，但一直处于申请连接状态<code>“sending discover”</code>。<br>启动命令如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//启动命令</span><br><span class="line">./root/me909s.sh &amp;</span><br></pre></td></tr></table></figure><p>具体代码因此项目交付没有保存。</p><h4 id="进入正题-实际原因是需要等其它模块初始化结束再启动4g模块">进入正题，实际原因是需要等其它模块初始化结束再启动4G模块</h4><p>因为4G模块拨号需要等USB驱动初始化结束才能执行，而加入初始化程序中的4G模块启动命令并没有等待。因此加入延时，再启动即可。（具体初始命令放置位置可以参考网上博客，不用一概而论，实际测试为准）<br>如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/rc.d/rc.local</span><br><span class="line">vi rc.local</span><br><span class="line"></span><br><span class="line">//加入启动代码</span><br><span class="line">sleep 5   </span><br><span class="line">./root/me909s.sh</span><br></pre></td></tr></table></figure><p>延时5s启动，问题解决！</p>]]></content>
      
      
      <categories>
          
          <category> System-development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文笔记：Lane-changing model</title>
      <link href="/posts/Automotive/20190210-lane-changing-model-note.html"/>
      <url>/posts/Automotive/20190210-lane-changing-model-note.html</url>
      
        <content type="html"><![CDATA[<p>主要介绍SUMO的一篇换道模型论文：Lane-changing model in SUMO</p><blockquote><p>Abstract：SUMO is an open source microscopic traffic simulation. A major component of modelling microscopic vehicle behavior is the lane-changing behavior on multi-lane roads. We describe a new model which uses a 4-layered hierarchy of motivations to determine the vehicle behavior during every simulation step and motivate in which ways it improves the current lane-changing model.<br><a href="https://www.researchgate.net/publication/270793471_Lane-changing_model_in_SUMO">论文地址</a></p></blockquote><h2 id="1-introduction">1. Introduction</h2><p>主要介绍了SUMO中的几个运动模型：</p><ul><li><strong>Car-following model</strong>: determines the speed of a vehicle in relation to the vehicle ahead of it.</li><li><strong>Intersection model</strong>: determines the behavior of vehicles at different types of intersections in regard to right-of-way rules, gap acceptance and avoiding junction blockage.</li><li><strong>Lane-changing model</strong>: determines lane choice on multi-lane roads and speed adjustments related to lane changing.</li></ul><p>该模型仍然是与之前的老式模型进行对比，老式模型在不同交通场景中不断改善，使得单独进行分析变得困难。新的模型主要考虑了两个方面：</p><ul><li>变道的决定（the change decision of a vehicle）</li><li>变道的速度（changes in the velocity for the vehicle itself）</li></ul><p>在该部分，作者强调了本文的创新点：<strong>该模型明确区分了四种不同的车道变换动机</strong></p><hr><h2 id="2-architecture">2. Architecture</h2><blockquote><p>重点介绍了变道过程中的技术细节</p></blockquote><p>车辆速度主要取决于前车的速度或者倾向的继承车辆的速度<br><em>The speed of a vehicle is mainly determined by the next vehicle in front of it called the leader, which may be on the same lane or on the preferred successor lane after the current lane</em></p><p>在这要根据跟车模型来进行计算，文中没有提到。引用文献：<em>Metastable states in a microscopic model of traffic flow</em></p><p><strong>文章的重点也在这部分提到，即汽车变道规划的四个子步骤：</strong></p><ol><li>计算优选后继车道；</li><li>在保持当前车道的假设下，计算安全速度，并整合来自先前模拟步骤的车道变换相关速度请求；</li><li>车道变换模型计算变更请求（左，右，停留）；</li><li>执行换道操作或计算下一个模拟步骤的速度请求（包括提前计划多个步骤）。是否请求速度变化取决于变道请求的紧急程度；</li></ol><p>原文：</p><ol><li>Computation of preferred successor lanes (called <strong>bestLanes</strong>)</li><li>Computation of safe velocities under the assumption of staying on the current lane and integration with lane-changing related speed requests from the previous simulation step</li><li>Lane-changing model computes change request (left, right, stay)</li><li>Either execute lane-changing maneuver or compute speed request for the next simulation step (involves planning ahead for multiple steps). Whether speed changes are requested depends on the urgency of the lane-changing request</li></ol><p>其中3,4由SUMO中<code>laneChangingModel</code>组件控制处理，并且可以被替换。</p><hr><h3 id="1-4-strategic-lane-changing">1.4 Strategic lane changing</h3><blockquote><p>汽车变道进入下一条边的行为，叫做汽车本身的变道策略。汽车必须在达到道路终点前进行变道规划</p></blockquote><h4 id="1-4-1-evaluating-subsequent-lanes">1.4.1 Evaluating subsequent lanes</h4><blockquote><p>评估子线路的标准</p></blockquote><ul><li>bestLanes（不需要换道）</li><li>occupation（沿着最优道路的车辆密度）</li><li>bestLaneOffset（车道偏移量）</li></ul><h4 id="1-4-2-determining-urgency">1.4.2 Determining Urgency</h4><p>定义几个参量来评估换道行为的紧急程度,同时进一步说明了它的整个行为。</p><p><code>A strategic change is deemed urgent if the following relation holds true</code></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>−</mo><mi>o</mi><mo>&lt;</mo><mi>l</mi><mi>o</mi><mi>o</mi><mi>k</mi><mi>A</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>s</mi><mi>p</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo>×</mo><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false">(</mo><mi>b</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>L</mi><mi>a</mi><mi>n</mi><mi>e</mi><mi>O</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo><mo>×</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">d-o &lt;lookAheadspeed \times abs(bestLaneOffset)\times f </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">o</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">A</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">L</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span></span></p><h4 id="1-4-3-speed-adjustment-to-support-lane-changing">1.4.3 Speed adjustment to support lane-changing</h4><blockquote><p>主要探究vechicle 与blocking vehicle的关系，并根据两者之间的关系来相应地改变行为</p></blockquote><p>每当由于阻挡车辆而不能执行期望的车道变换时，车辆可以调整其速度以允许车道变换在后续步骤中成功。 此外，车辆可能对阻挡车辆的速度产生影响（实际上，这通常作为对观察自我车辆的转向信号的反应而发生）。</p><h4 id="1-4-4-preventing-deadlock">1.4.4 Preventing deadlock</h4><p>两车由于一些原因，同时到达道路的终点，此时两车都希望可以实现换道，这种情况便发生了死锁（deadlock）。</p><p><em>if two vehicles on adjacent lanes both need to change to the lane occupied<br>by the other vehicle (counterLaneChange) and both vehicles reach the end of a dead lane, a deadlock occurs</em></p><p>为了避免这种情况，对车进行分类（更靠近道路终点的称为<code>blocking leader</code>，另一个称为<code>the blocking follower</code>)。后者要预先进行减速，以为前车留出足够的距离进行变道操作。</p><p><em>the blocking follower slows down when approaching the dead-end to ensure that the blocking leader has enoughspace to complete its lane change</em></p><p>尽管采取这种操作，死锁仍然可能无法避免，因为会存在多车道的情况。因此，采用的方法是预留出20~40m范围进行变道。</p><p><em>additional space of 20m is reserved for vehicles which need to change to the right across and 40m for vehicles which need to change to the left.</em></p><hr><h3 id="1-5-cooperative-lane-changing">1.5 Cooperative lane-changing</h3><p>在某些场景下，有些车辆执行变道行为仅仅为了帮助其他车辆执行变道。<br><strong>太难了，完全不懂。。。</strong></p><h3 id="1-6-tactical-lane-changing-策略变道">1.6 Tactical lane-changing（策略变道）</h3><blockquote><p>Tactical lane-changing refers to maneuvers <strong>where a vehicle attempts to avoid following a slow leader</strong> （简单明了的解释）</p></blockquote><p>如果不这样做会导致速度差异较小的车辆成为交通流量的主要障碍。</p><p>变量：<code>speedGainProbability</code><br>描述：<em>Each vehicle maintains a signed variable speedGainProbability which by its sign indicates the beneficial change direction and by its magnitude the expected benefit</em></p><p>配置参数：<code>--lanechange.overtake-right</code></p><h3 id="1-7-obligation-to-clear-the-overtaking">1.7 Obligation to clear the overtaking</h3><p>注意该部分的描述是<code>Obligation</code>，所以在这其实现基本上是强制性的。目的与之前1.5描述类似，为了其它车辆更快行驶。在这位置作者的描述是<code>Mandated by traffic laws</code>。</p><p>变量：<code>keepRightProbability</code></p><p>公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mo>=</mo><mi>p</mi><mo>−</mo><mfrac><mrow><mi>t</mi><mo>∗</mo><mi>l</mi></mrow><mrow><mi>V</mi><mo>∗</mo><mi>v</mi><mo>∗</mo><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">p := p-\frac{t*l}{V*v*T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><h3 id="1-8-remote-controlled-lane-changing-traci">1.8 Remote controlled lane changing(TraCI)</h3><p>远程请求改变到目标通道或保持当前通道必须与由通道改变模型计算的“固有”请求集成。 这是通过让用户通过设置适当的标志（新）来确定远程请求的紧急程度和优先级来实现的。</p><h3 id="1-9-a-hierarchy-of-lane-changing">1.9 A hierarchy of lane changing</h3><p>以上四个动机进行分层描述。</p><ol><li>Urgent strategic change to d needed: change</li><li>Change to d would create an urgent situation: stay</li><li>Vehicle is a blocking follower for another vehicle with urgent strategic change<br>request: change</li><li>speedGainProbability above threshold and its sign matches d: change</li><li>non-urgent strategic change to d needed: change (new)</li></ol><h3 id="1-10-improvements-over-earlier-model">1.10 Improvements over earlier Model</h3><blockquote><p>选取几个参量作为标准，与之前的模型进行对比</p></blockquote><ul><li><strong>avgWaitingTime</strong>: the average time each vehicle spent with speed below 0.1m/s</li><li><strong>wrongLaneTeleports</strong>: the count of vehicles which had to be moved artificially (teleported) because they could not complete a strategic lane change (after a threshold time t)</li><li><strong>jamTeleports</strong>: the count of vehicles which had to be moved artificially (teleported) because the successor lane was occupied (after a threshold time t)</li></ul><p>改变换道模型，然后对比不同的交通场景进行性能测试<br><img src="../../post-images/4c777a5412967fb3f96c514e389123d4_MD5.png" alt="在这里插入图片描述"></p><p>最后列举了新模型的一些提升</p><ul><li>在多道迂回中采用特殊行为确保所有车道都被使用，而先前的模型只使用外侧的车道</li></ul>]]></content>
      
      
      <categories>
          
          <category> Automotive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Automotive </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年吉林大学软件学院学硕初试专业课考题回忆</title>
      <link href="/posts/Others/20181231-2019-JLU-kaoyan-note.html"/>
      <url>/posts/Others/20181231-2019-JLU-kaoyan-note.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载一位学弟的，回忆难免出错，请理解。</p></blockquote><h3 id="一-数据结构">一、数据结构</h3><ol><li>求两点之间的最大路径长度；</li><li>中缀表达式变后缀表达式，并说明栈的变化过程；</li><li>树的先根遍历对应二叉树先序遍历，树的后根遍历对应二叉树的中序遍历。问根据树的先根和后根能否确定唯一的一棵树，并举例说明；</li><li>在n个没有顺序的序列中，取前k和最小的元素，k远小于n。你认为哪种排序方式比较好。根据你选择的排序方式，在给出的一串数中取前几个元素，然后问比较次数是多少；</li><li>散列表拉链法，然后求最好和最坏的查找次数；</li></ol><hr><h3 id="二-计算机网络">二、计算机网络</h3><blockquote><p>三个大题，每个25分</p></blockquote><ol><li>计算机网络拓扑结构及其特点；</li><li>TCP层与MAC层都用的滑动串口流量控制，说出他们的工作原理和差异；</li><li>用文字和图画描述数字签名工作流程；</li></ol><blockquote><p>数字签名应该是吉大课本中网络安全那一章的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年吉林大学软件学院软件工程专硕复试题目回忆</title>
      <link href="/posts/Others/20181220-2018-JLU-kaoyan-note-4.html"/>
      <url>/posts/Others/20181220-2018-JLU-kaoyan-note-4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章由笔者研友回忆，特此注明转载，希望对大家有帮助！</p></blockquote><h2 id="一-计算机网络">一、计算机网络</h2><h3 id="1-名次解释">1.名次解释</h3><p>共30分，每问5分</p><p>CIDR,RIP,DNS,CSMA/CD,SMTP,IGMP</p><h3 id="2-问答">2.问答</h3><ol><li>简述CSMA/CD的工作过程（10分）</li><li>简述二进制指数退避算法（15分）</li></ol><hr><h2 id="二-操作系统">二、操作系统</h2><ol><li>死锁的概念，死锁发生的必要条件，说一下死锁怎么预防？</li><li>页面的最适大小是什么，设定页面大小需要考虑哪些因素，说明原因</li><li>内存问题：一块硬盘原有的内存是xx,格式化后内存缩小为xx，操作系统显示的内存容量为xx，这三个内存之间什么关系？</li><li>进程的概念，进程状态之间的转换</li><li>描述文件的索引存储，如果要直接访问内存地址为2000的文件，过程是什么</li></ol>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年吉林大学软件学院软件工程学硕复试笔试题回忆</title>
      <link href="/posts/Others/20180324-2018-JLU-kaoyan-note-2.html"/>
      <url>/posts/Others/20180324-2018-JLU-kaoyan-note-2.html</url>
      
        <content type="html"><![CDATA[<p>备注：笔试编程题目为手写，满分150分，时间为2小时。</p><p>今年为第二年招生，从题目类型上看，大体有递归，穷举，数组和字符串这几种类型。比较容易归纳</p><h3 id="1-完数-判断-40分">1.“完数“判断（40分）</h3><p>一个正整数的所有因子之和等于它本身，这样的数称为完数。如：1 + 2 + 3 = 6，则6为完数。输出100以内的所有完数。</p><p><strong>参考代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//包含所有库函数 </span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isWholeNUM</span><span class="params">(<span class="type">int</span> n)</span>&#123;<span class="comment">//使用函数进行判断 </span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i == <span class="number">0</span>)</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; <span class="number">100</span>;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(isWholeNUM(i))</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="2-序列输出-40分">2.序列输出（40分）</h3><p>假定序列满足：</p><ol><li>第一位数是1；</li><li>第二位数是2；</li><li>奇数位为前两项之和，偶数项为前两项之差；</li></ol><p>将100以内序列按<strong>递增排序</strong>并输出</p><p><strong>参考代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">r_list</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> r_list(n - <span class="number">1</span>) + r_list(n <span class="number">-2</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> r_list(n - <span class="number">1</span>) - r_list(n <span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;++i)&#123;</span><br><span class="line">num = r_list(i);</span><br><span class="line"><span class="built_in">array</span>.push_back(num);</span><br><span class="line">&#125;</span><br><span class="line">sort(<span class="built_in">array</span>.begin(),<span class="built_in">array</span>.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">array</span>.size();++i)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">array</span>[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="3-最短线段-40分">3.最短线段（40分）</h3><p>平面上存在100个点，任意两点之间可以连接成一条线段。假设存在点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（</mtext><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mtext>）</mtext></mrow><annotation encoding="application/x-tex">（x1,y1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span>,点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（</mtext><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mtext>）</mtext></mrow><annotation encoding="application/x-tex">（x2,y2）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mord cjk_fallback">）</span></span></span></span>,则两点之间的距离公式为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mrow><mo stretchy="false">(</mo><mi>x</mi><mn>1</mn><mo>−</mo><mi>x</mi><mn>2</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mn>1</mn><mo>−</mo><mi>y</mi><mn>2</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{(x1-x2)^2+(y1-y2)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.25612499999999994em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.983875em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.9438750000000002em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25612499999999994em;"><span></span></span></span></span></span></span></span></span></span></p><p>求所有线段中的最短线段<br><strong>参考代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125; <span class="built_in">array</span>[<span class="number">99</span>];<span class="comment">//包含100个点，从0开始 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> length = <span class="number">0</span>,max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;++i)<span class="comment">//输入100个点的坐标 </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;<span class="built_in">array</span>[i].x&gt;&gt;<span class="built_in">array</span>[i].y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;++i)&#123;<span class="comment">//计算100个点之间所有组合的线段长度 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">100</span>;++j)&#123;</span><br><span class="line">length = (<span class="built_in">array</span>[i].x - <span class="built_in">array</span>[j].x)^<span class="number">2</span> + (<span class="built_in">array</span>[i].y - <span class="built_in">array</span>[j].y)^<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(max &lt; length)</span><br><span class="line">max = length;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">sqrt</span>(max);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-0串数目-30分">4.0串数目（30分）</h3><p>输入一段序列，连续两个0及以上称为0串。假如为001000，其中0串的数目为2。输入以2为结束，问序列中是否存在两个或两个以上的0串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">string</span> num;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>,n = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//while((cin&gt;&gt;num) != &#x27;2&#x27;);//题意要求应该是这样，当输入2时自动终止输入，但是报错 </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num;<span class="comment">//因此手工输入 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; num.length();++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">m++;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m &gt;= <span class="number">2</span> &amp;&amp; num[i + <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">2</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;OK&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年吉林大学软件学院软件工程学硕复试回忆</title>
      <link href="/posts/Others/20180324-2018-JLU-kaoyan-note-3.html"/>
      <url>/posts/Others/20180324-2018-JLU-kaoyan-note-3.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-复试时间安排">1.复试时间安排</h3><ul><li>综合面试<ul><li>时间：3月22日（周四）上午8：00－11：30（学硕）</li><li>地点：吉林大学南校区计算机大楼B339（软件学院研究生办公室）</li></ul></li><li>复试笔试<ul><li>内容：<ul><li>听力：3月22日（周四）下午13：30－14：00</li><li>编程：3月22日（周四）下午14：00－16：00</li></ul></li><li>地点：吉林大学南校区计算机大楼A310</li></ul></li></ul><h3 id="2-复试方式">2.复试方式</h3><ul><li>笔试<br>考试时间为2小时，满分150分，主要为专业素质和能力测试。考试科目按照招生简章中公布的科目考核 考试方式为闭卷。</li><li>面试<br>满分150分，包括综合素质和能力面试100分，外语听说能力测试50分（听力30分在笔试之前测试、口语20分在面试中测试</li></ul><h3 id="3-个人心得">3.个人心得</h3><ul><li><strong>关于面试</strong><br>首先将所有人进行分组，每组大约10人左右，单独去一间教室面试。<br>其次关于面试内容，英语口语会进行抽签，条上写有提问的问题。基本都有两个问题，会让你先读一遍，然后进行翻译，之后进行口头表达。</li></ul><p>口语内容大体有：</p><ul><li>你为什么准备考研？</li><li>你的家庭？</li><li>你的兴趣爱好？你喜欢团队合作吗？</li><li>你有工作吗？你的工作打算是什么？</li><li>你的未来学习计划是什么？</li><li>中国最火的运动是什么？你喜欢什么运动</li></ul><p>关于英语口语，总体而言题目比较多样化，但重点应该放在基本的沟通理解上，流畅表达即可，对于语法和复杂句不用过多纠结。口语时间自定，老师不会中途打断。</p><p>最后关于面试内容，每人都有一个<strong>中文的自我介绍</strong>，务必重点准备。老师会根据你自我介绍内容进行相应提问，包括你的经历，你的性格，你的理想等等。比较吸引老师的是你的项目经历和获奖经历等。有一点值得注意的是，老师可能会问你一句有没有定好导师，可能这个时候回答”是“会有加分。不知道真假。</p><p>老师都很和蔼，气氛很轻松。个人觉得说话要适度，一方面不要拘束，另一方面不要侃侃而谈。根据你的个人情况，老师可能会有些专业问题，但具体因人而异，这也是我之前提到的自我介绍的重要性所在，留一些”话柄“给老师，防止老师与你展开专业对话。<strong>仅供参考</strong></p><ul><li><strong>关于笔试</strong><br>笔试包括听力还有编程。<br>听力总体和4，6级听力相同，最后有一篇填空。总体难度为6级吧，当然，因人而异。时间为30分钟。<br>编程为手写，具体题目我的博客已有，并且附录我个人的代码，仅供参考。说到技巧，最好是写出你的思路，并且关键地方进行注释。同时尽可能精简。没有注明使用语言，个人觉得最好不要超出C.C++和Java。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM Linux SocketCAN驱动编译记录</title>
      <link href="/posts/System-development/20180324-ARM-linux-socketCAN-driver-compilation-note.html"/>
      <url>/posts/System-development/20180324-ARM-linux-socketCAN-driver-compilation-note.html</url>
      
        <content type="html"><![CDATA[<p>最近调试时使用了相关工具，参考了相关博客终于编译通过。特此汇总各博客内容进行整理</p><h3 id="1-编译环境所需工具：">1.编译环境所需工具：</h3><ul><li><a href="https://public.pengutronix.de/software/libsocketcan/">libsocketcan-0.0.10.tar.bz2</a></li><li><a href="https://public.pengutronix.de/software/socket-can/canutils/v4.0/">canutils-4.0.6.tar.bz2 </a></li></ul><p>交叉编译工具链根据每个开发板所提供的类型进行设置，我的工具链名称为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-fsl-linux-gnueabi-gcc</span><br></pre></td></tr></table></figure><p>后面实际配置时请注意</p><hr><h3 id="2-参考博客">2.参考博客</h3><p><a href="https://www.cnblogs.com/eaggle/p/7641526.html">https://www.cnblogs.com/eaggle/p/7641526.html</a><br><a href="https://blog.csdn.net/sinat_35706094/article/details/79537749">https://blog.csdn.net/sinat_35706094/article/details/79537749</a><br><a href="https://blog.csdn.net/sno_guo/article/details/17029295">https://blog.csdn.net/sno_guo/article/details/17029295</a></p><hr><h3 id="3-具体配置">3.具体配置</h3><h4 id="第一步：配置交叉编译工具链">第一步：配置交叉编译工具链</h4><p>配置好交叉编译工具链为全局环境，也就是将其添加到环境变量中，具体因人而异。在这不具体说明，请自行查找资料</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm</span><br><span class="line">export CROSS_COMPILE=/opt/freescale/usr/local/gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12/fsl</span><br><span class="line">-linaro-toolchain/bin/arm-none-linux-gnueabi-</span><br><span class="line">export PATH=/opt/freescale/usr/local/gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12/fsl-linaro-toolch</span><br><span class="line">ain/bin:$PATH</span><br></pre></td></tr></table></figure><h4 id="第二步-交叉编译libsocketcan">第二步 交叉编译libsocketcan</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd libsocketcan-0.0.10  //进入目录</span><br><span class="line">mkdir out              //创建文件夹，放置生成文件</span><br><span class="line">./configure --prefix=/文件夹路径/libsocketcan-0.0.10/out --host=arm-fsl-linux-gnueabi</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>此时生成文件会出现在<code>out/lib</code>文件夹下，将这些生成的库复制到开发板的文件系统内，可以放在lib目录下，也可以放在<code>usr/lib</code>里面<br>（每篇博客的设置都不同，该步的生成文件我没有拷贝到开发板。以防后面配置出现问题，可以设置上）</p><hr><h4 id="第三步-编译安装canutils-4-0-6-tar-bz2">第三步 编译安装<code>canutils-4.0.6.tar.bz2</code></h4><p>先将 libsocketcan 里面的头文件 <code>libsocketcan.h</code>， <code>can_netlink.h</code> 复制到 canutils 的 <code>include</code> 里面。这些文件在<code>out/include</code>目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd canutils-4.0.6/</span><br><span class="line">mkdir out</span><br><span class="line">//进行实际配置,可直接复制下面代码，务必仔细修改文件夹路径和交叉编译工具链</span><br><span class="line">./configure --host=arm-fsl-linux-gnueabi   \</span><br><span class="line">--prefix=/文件夹路径/canutils-4.0.6/out li   \</span><br><span class="line">bsocketcan_LIBS=-lsocketcan LDFLAGS=&quot;-L/   \</span><br><span class="line">文件夹路径/libsocketcan-0.0.10/out/lib/&quot; l   \  </span><br><span class="line">ibsocketcan_CFLAGS=&quot;-I/文件夹路径/libsocke   \ </span><br><span class="line">tcan-0.0.10/out/include&quot;</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>最后在 <code>out/sbin</code> 下能见到 <code>canconfig</code> 命令，在<code>out/bin</code> 下面 <code>candump/canecho/cansend/cansequence</code><br>将这些文件拷贝到开发板<code>/usr</code>目录下即可。</p><p>具体请看参考博客</p><hr><h3 id="4-高级设置">4.高级设置</h3><p>关键词：Linux SocketCAN工具<code>can-utils</code>中多线程设置</p><p>实际使用时，将接收到的CAN数据发送到远程，同时远程服务器会再发送数据过来，所以需要多线程的需求。写好编译时，会出现这样的报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined reference to `pthread_create&#x27;</span><br></pre></td></tr></table></figure><p>很明显是由于设置多进程导致的，添加相应库后无效。经搜索发现需要在编译时进行相应设置，问题如下：</p><p><strong>问题：</strong> <code>pthread</code> 库不是 Linux 系统默认的库，连接时需要使用静态库 <code>libpthread.a</code>，所以在使用<code>pthread_create()</code>创建线程，以及调用 <code>pthread_atfork()</code>函数建立fork处理程序时，需要链接该库。</p><p>**解决：**在编译中要加 <code>-lpthread</code>参数（最好加在最后面，我到貌似就是这样才行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc thread.c -o thread -lpthread</span><br></pre></td></tr></table></figure><p><code>thread.c</code>为你些的源文件，不要忘了加上头文件<code>#include&lt;pthread.h&gt;</code></p><p>但由于<code>can-utils</code>是通过Makefile管理，因此需要找到相关的编译设置。摸索一小时终于找到~</p><p>在工具链<code>\src\GNUmakefile</code>中，第96行添加<code>-lpthread</code>，效果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS = -Wall -g -lpthread -O2</span><br></pre></td></tr></table></figure><p>同时在第365行添加<code>-lpthread</code>，效果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.c.o:</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(COMPILE) -MT <span class="variable">$@</span> -MD -MP -MF $(DEPDIR)/$*.Tpo -lpthread -c -o <span class="variable">$@</span> $&lt;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po</span></span><br></pre></td></tr></table></figure><p>之后执行<code>make</code>,<code>make install</code>编译即可。</p>]]></content>
      
      
      <categories>
          
          <category> System-development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> 调试记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Pybombs安装GNURadio</title>
      <link href="/posts/System-development/20180221-install-gnuradio-with-pybombs.html"/>
      <url>/posts/System-development/20180221-install-gnuradio-with-pybombs.html</url>
      
        <content type="html"><![CDATA[<p>之前安装过几次，最近安装时又出现问题。记录下安装过程</p><h2 id="一-工具">一、工具</h2><p>Ubuntu desktop 14.04（建议使用双系统）<br>官方安装也用过16.04，不过为了稳定性最好使用14.04<br>在这提供官方的测试live系统，只能装载在U盘使用，无法安装。<br><a href="https://wiki.gnuradio.org/index.php/GNU_Radio_Live_SDR_Environment">https://wiki.gnuradio.org/index.php/GNU_Radio_Live_SDR_Environment</a></p><h2 id="二-过程">二、过程</h2><p>安装依照官方最新Pybombs安装，不使用之前的代码安装方法。会自动解决依赖问题。<br>参考链接：</p><ol><li>使用国内的镜像源来加速PyBOMBS安装GNURadio<br><a href="http://www.hackrf.net/2016/06/pybombs-mirror-tuna/">http://www.hackrf.net/2016/06/pybombs-mirror-tuna/</a></li><li>GNURadio官方安装<br><a href="https://github.com/gnuradio/gnuradio">https://github.com/gnuradio/gnuradio</a></li><li>Pybombs安装<br><a href="https://github.com/gnuradio/pybombs">https://github.com/gnuradio/pybombs</a></li></ol><h3 id="第一步：安装-pip"><strong>第一步</strong>：安装 pip</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure><p><code>pip</code>为<code>Python</code>的包管理程序</p><h3 id="第二步：安装-pybombs"><strong>第二步</strong>：安装 Pybombs</h3><blockquote><p><a href="http://gnuradio.org/redmine/projects/pybombs/wiki">PyBOMBS</a> (Python Build Overlay Managed Bundle System) 是 <a href="http://gnuradio.org/">GNU Radio</a> 的包管理系统。详细介绍参考链接3</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sudo] pip install PyBOMBS</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/gnuradio/pybombs.git</span><br><span class="line">cd pybombs</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><p>第一种为直接安装，第二种为源码安装。实际安装时直接安装会报错，具体原因不知，因此笔者采用的是源码安装的方法。具体可参考链接2和链接3<br><strong>注意</strong>：源码安装可能出错，笔者安装时也报错，但换了目录后成功了，实在是。。。</p><h3 id="第三步：初始化"><strong>第三步</strong>：初始化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.pybombs</span><br><span class="line">pybombs recipes add gr-recipes git+https://mirrors.tuna.tsinghua.edu.cn/pybombs/recipes/gr-recipes.git</span><br><span class="line">pybombs recipes add gr-etcetera git+https://mirrors.tuna.tsinghua.edu.cn/pybombs/recipes/gr-etcetera.git</span><br><span class="line">mkdir gnuradio-prefix</span><br><span class="line">cd gnuradio-prefix</span><br><span class="line">pybombs prefix init//初始化</span><br></pre></td></tr></table></figure><p>此处添加库时改成国内清华大学的库，具体参考链接1。如果使用链接2中官方的安装方法，会报错，网上也有对应的解决方法，链接如下：<br><a href="http://www.cnblogs.com/bitspace/p/6032279.html">http://www.cnblogs.com/bitspace/p/6032279.html</a><br><strong>注意Ubuntu的语言问题，如果安装时为中文，则中途会出现莫名的错误提示ascii错误，大体意思时python对中文的支持有问题，重装到英文版本后成功。</strong></p><h3 id="第四步：安装"><strong>第四步</strong>：安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pybombs install gnuradio</span><br></pre></td></tr></table></figure><p>此处安装时间很长，可能要1小时左右。直接添加<code>sudo</code>,中途就不用管了，会默认同意。</p><h3 id="第五步：配置环境"><strong>第五步</strong>：配置环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pybombs install rtl-sdr hackrf bladeRF gr-osmosdr gr-bluetooth gr-ieee-80211 uhd</span><br></pre></td></tr></table></figure><p>安装各种硬件驱动，大家可以根据自己的硬件设备，有选择的安装。</p><h3 id="第六步：启动"><strong>第六步</strong>：启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. ./setup_env.sh</span><br><span class="line">gnuradio-companion</span><br></pre></td></tr></table></figure><p>通过命令<code>gnuradio-companion</code>命令来启动GRC，但关闭终端窗口再此敲入命令则无法启动。原因是没有配置全局变量。网上有很多配置gnuradio全局变量的方法，但操作麻烦。笔者摸索时找到一个方法成功配置。大家可以参考<br>打开终端，执行<code>gnuradio-companion</code>，会提示没有gnuradio并提示安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnuradio</span><br></pre></td></tr></table></figure><p>此时并不是重新安装，大约2分钟便安装结束。安装成功后便成功配置了全局变量。</p><h2 id="总结">总结</h2><ol><li>安装过程最好使用root用户进行，否则会因为莫名的权限问题报错；</li><li>注意报错的原因进行调试，或者路径或者版本；</li></ol>]]></content>
      
      
      <categories>
          
          <category> System-development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> 软件无线电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gr-analysis 安装问题解决</title>
      <link href="/posts/System-development/20180206-gr-analysis-installation-error-fix.html"/>
      <url>/posts/System-development/20180206-gr-analysis-installation-error-fix.html</url>
      
        <content type="html"><![CDATA[<h2 id="一-介绍">一、介绍</h2><p>先前因为需要调试<code>GNURadio</code> 程序缘故，需要实时处理大量数据，每次都会出现突发溢出，所以尝试安装<code>gr-analysis</code> 工具进行离线接收处理。安装过程简单，但中途有小问题耗了一天，特此记录。</p><p><a href="http://www.trondeau.com/grcon15-presentations#wednesday_Lincoln_Synchronized">http://www.trondeau.com/grcon15-presentations#wednesday_Lincoln_Synchronized</a></p><h3 id="features">Features</h3><p>Tools for High Sample Rate Recording and Post-Processing in GNURadio</p><ul><li>metadata_to_csv: Convert metadata to comma-separated value (.csv) format for import into MATLAB, Octave, etc.</li><li>specrec: High sample-rate recording (~30 MSPS) program with metadata. Scheduled, time-syncronized records with GPSDO. Linux-only as of now.</li><li>gr_fileman: File manipulation program. Can convert between data formats, cut out a subsection of data, interpolates timestamps, etc. Somewhat like SoX but exploits metadata and timestamps</li><li>gr_mkheader: Generate headers for data which previously had none</li><li>gr_fstat: Compute statistics of .sc16 and .fc32 files (mean,var,max,min)</li><li>read_file_metadata: Display metadata headers in human-readable format<br>具体可参考<code>github</code> <a href="https://github.com/garverp/gr-analysis#gr-analysis">https://github.com/garverp/gr-analysis#gr-analysis</a></li></ul><h2 id="二-安装">二、安装</h2><p>These tools are primarily Linux-based. All tools but specrec should theoretically work, but untested on OSX/Windows.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/garverp/gr-analysis</span><br><span class="line">cd gr-analysis</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><h2 id="三-问题">三、问题</h2><h3 id="1-c-14-报错">1.C++14 报错</h3><p>我的<code>ubuntu</code>环境是14.04，在安装到第5步时会出现Error，大体内容是不支持<code>C++14</code>环境。搜索之后得知需要<code>gcc 6.0</code>及以上版本，安装过程涉及到<code>ubuntu</code>上<code>gcc</code>的版本切换，很折腾，在这推荐一个博客，一步到位解决！<br><a href="http://www.cnblogs.com/BlackStorm/p/5183490.html">http://www.cnblogs.com/BlackStorm/p/5183490.html</a><br>关键操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-5 g++-5//安装gcc-5版本，实测足够</span><br><span class="line"></span><br><span class="line">//更新链接</span><br><span class="line">update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 53 \</span><br><span class="line">--slave /usr/bin/g++ g++ /usr/bin/g++-5 \</span><br><span class="line">--slave /usr/bin/gcc-ar gcc-ar /usr/bin/gcc-ar-5 \</span><br><span class="line">--slave /usr/bin/gcc-nm gcc-nm /usr/bin/gcc-nm-5 \</span><br><span class="line">--slave /usr/bin/gcc-ranlib gcc-ranlib /usr/bin/gcc-ranlib-5</span><br></pre></td></tr></table></figure><p>升级之后错误解决，进入第6步</p><h3 id="2-uhd缺少头文件">2.UHD缺少头文件</h3><p>编译第6步会提示<code>UHD</code>缺少头文件，因此我又重新安装了一番，折腾好久还是不行。问题如下：<br><img src="../../post-images/4c57f47b02a728f0def6f6fa29c2689b_MD5.png" alt="这里写图片描述"></p><p>碰巧看了github上的<code>issue</code>提交，修改之后成功，很关键的错误。我把提交的<code>issue</code>复制过来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">With UHD <span class="number">3.10</span><span class="number">.2</span> PyBOMBS compilation fails due to a wrong uhd included header. </span><br><span class="line">To solve the issue, it is enough to replace </span><br><span class="line">line <span class="number">20</span> of specrec.cpp with</span><br><span class="line">`<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uhd/utils/thread_priority.hpp&gt;</span>`</span></span><br></pre></td></tr></table></figure><p>按照路径打开 <code>gr-analysis/app/record/specrec.cpp</code>，修改第20行代码为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uhd/utils/thread_priority.hpp&gt;</span></span></span><br></pre></td></tr></table></figure><p>即可。</p><p>结果之后编译就能成功了！</p>]]></content>
      
      
      <categories>
          
          <category> System-development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug调试 </tag>
            
            <tag> 软件无线电 </tag>
            
            <tag> 通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年吉林大学软件工程979学硕题目回忆版</title>
      <link href="/posts/Others/20171225-2018-JLU-kaoyan-note-1.html"/>
      <url>/posts/Others/20171225-2018-JLU-kaoyan-note-1.html</url>
      
        <content type="html"><![CDATA[<p>昨天刚结束考试，整理下，有很多不全，后续想起来会继续补充，希望有帮助！</p><blockquote><p>备注：979学硕，属于吉林大学软件学院软件工程专业学硕题目。今年为第二次招生。</p></blockquote><h2 id="考试情况">考试情况</h2><h4 id="注意事项">注意事项</h4><p>专业课题目密封袋很简陋，我现在还怀疑自己有没有密封彻底，因为我直接把袋子割开了，没有沿着封边割开，失误，上天保佑运输过程中不会开。里面没有答题纸，没有封条。</p><p>题目总体难度中等，但因为出题方向之前不了解，初做起来很不适应，但内容上来说王道的复习书就够了。</p><h4 id="补充-2018-4-4">补充-2018/4/4</h4><p>最近复试成绩下来了，成功录取。同时给大家打一针强心剂，所有进入复试的名单中，专业课成绩均130左右，高分有149的，大部分在134左右。意思是吉大专业课阅卷很松，希望大家放心复习，没有那么高的门槛，但一定要扎实复习。以往年考题为主认真复习，没必要做太难的题目。</p><p>录取人数学硕55人，专硕65+1（士官计划）+1（非全日制）</p><p>希望大家加油！</p><hr><h2 id="考试内容-数据结构">考试内容-数据结构</h2><blockquote><p>题目没有选择题，数据结构题型为<strong>简答题</strong>和<strong>编程题</strong>，计算机网络题型为<strong>简答题</strong>，<strong>思考题</strong>和<strong>论述题</strong>。</p></blockquote><h4 id="简答题-不全">简答题（不全）</h4><ol><li>给出后序遍历序列和结点次数，求二叉树（吉大往年考题有）；</li><li>给出二叉树的不同度的结点个数，求度为0的结点个数；</li><li>给出一组值，构造哈夫曼树；</li><li>关键字比较次数与序列初始状态无关的排序算法是哪两个；</li></ol><h4 id="编程题">编程题</h4><ol><li>寻找单链表中数据域大小为k的结点，并与前一结点交换，如果前一结点存在的情况下；</li><li>对二叉树进行层次遍历，顺序为从下往上，从左往右；</li><li>一数组前m部分递增有序，后n部分递减有序，对整个数组进行排序，要求整个数组递减有序；</li></ol><hr><h2 id="考试内容-计算机网络">考试内容-计算机网络</h2><blockquote><p>备注：自我感觉来看，对于计算机网络考察特别侧重基础，对于概念理解非常细致，没有路由器，IP地址等的计算题。</p></blockquote><h4 id="简答题：">简答题：</h4><ol><li>计算机网络的通信指标有哪些？</li><li>计算机网络通信网络环境差的原因？</li><li>计算机网络中包交换和电路传输的主要区别是？</li></ol><h4 id="思考题-20分">思考题(20分)</h4><p>CRC校验：给出待发送数据部分，给出多项表达式，求实际发送部分。</p><h4 id="论述题-25分">论述题（25分）</h4><ol><li>说明TCP是如何设置超时重传时间的？</li><li>说明TCP的连接建立和断开的数据包发送过程，可用时序图或者文字描述；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017年吉林大学软件学院学硕高级程序设计复试题回忆</title>
      <link href="/posts/Others/20170302-2017-JLU-kaoyan.html"/>
      <url>/posts/Others/20170302-2017-JLU-kaoyan.html</url>
      
        <content type="html"><![CDATA[<p>吉林大学软件学院学硕从2017年开始招生，复试为高级程序语言设计。此题目为学姐回忆，特此转载记录，并添加个人测试代码，希望对大家有帮助！</p><h3 id="一-验证哥徳巴赫猜想">一、 验证哥徳巴赫猜想</h3><p>输入一个大于等于 6 的偶数，偶数等于两个素数之和。<br>参考代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span>&#123;<span class="comment">//判断是否是素数 </span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">if</span>(n%i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num;<span class="comment">//输入数</span></span><br><span class="line"><span class="keyword">while</span>((num%<span class="number">2</span> != <span class="number">0</span>)||(num &lt; <span class="number">6</span>))&#123;<span class="comment">//判断数字是否满足要求 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Error! Please enter another num&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; num;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; i;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(((i + j) == num) &amp;&amp; isPrime(i) &amp;&amp; (isPrime(j)))</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;+&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="二-求数列前100行之和">二、 求数列前100行之和</h3><p>定义一个数列 k（n）:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k[n]=</span><br><span class="line">&#123;</span><br><span class="line">    第一行 <span class="number">1</span> ，n=<span class="number">1</span></span><br><span class="line">    第二行 k(n- <span class="number">1</span>)×（- <span class="number">2</span>）+<span class="number">1</span> ，n 为偶数</span><br><span class="line">    第三行 k(n- <span class="number">1</span>)×（- <span class="number">3</span>）+<span class="number">1</span> ，n 为奇数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出数列前 100 行之和。<br>参考代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">k</span><span class="params">(<span class="type">int</span> m)</span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">if</span>(m == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">0</span>)&#123; </span><br><span class="line"><span class="keyword">return</span> (k(m<span class="number">-1</span>)*(<span class="number">-2</span>) + <span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(m%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (k(m<span class="number">-1</span>)*(<span class="number">-3</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//数列之和 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;++i)&#123;<span class="comment">//计算数列前100项之和 </span></span><br><span class="line">sum += k(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sum = &quot;</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="三-求数字序列平台长度">三、 求数字序列平台长度</h3><p>给出一个数字序列，数字序列的平台长度就是数列中数字重复了几次，求出该数列平台的最长长度。 （注意：不要丢掉负数这种情况）<br>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//因为复试手写代码，建议使用该头文件，防止漏掉</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">string</span> num;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line"><span class="type">int</span> arrayA[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;,arrayB[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; num.length();++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] -<span class="string">&#x27;0&#x27;</span> &gt; <span class="number">0</span> &amp;&amp; num[i] != <span class="string">&#x27;-&#x27;</span>)  <span class="comment">//正数计数</span></span><br><span class="line">arrayA[num[i] - <span class="string">&#x27;0&#x27;</span>]++; </span><br><span class="line"><span class="keyword">if</span>(num[i] == <span class="string">&#x27;-&#x27;</span>)&#123;   <span class="comment">//判断是否是负数</span></span><br><span class="line">arrayB[<span class="built_in">abs</span>(num[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>)]++;</span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>;    <span class="comment">//寻找最大值，也可以使用库函数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)</span><br><span class="line"><span class="keyword">if</span>(max &lt; arrayA[i])</span><br><span class="line">max = arrayA[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)</span><br><span class="line"><span class="keyword">if</span>(max &lt; arrayB[i])</span><br><span class="line">max = arrayB[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;max is &quot;</span>&lt;&lt;max&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="四-输出数列-a-的前-100-项">四、 输出数列 A 的前 100 项</h3><p>数列 A 的定义：</p><ol><li>数 1 是数列中的数；</li><li>若 x 是数列中得数那么 2x,3x 也是数列中的数；</li><li>数列中无其他的数；<br>参考代码：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">num.insert(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="type">int</span>&gt;::iterator it_begin = num.begin();</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="type">int</span>&gt;::iterator it_end   = num.end();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="type">int</span>&gt;::iterator it = it_begin;num.size() &lt; <span class="number">100</span>;++it)&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;*it&lt;&lt;endl;</span></span><br><span class="line">num.insert(<span class="number">2</span>*(*it));</span><br><span class="line">num.insert(<span class="number">3</span>*(*it));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="type">int</span>&gt;::iterator it = it_begin; it != it_end; it++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
